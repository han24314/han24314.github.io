<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> J`Han&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">J`Han&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['落霞与孤鹜齐飞，秋水共长天一色。 - 《滕王阁序》王勃（唐）', '', ''],
        startDelay: 0,
        typeSpeed: 250,
        loop: true,
        backSpeed: 150,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  <ul class="ads">
    
        <li>
            <a href="">
                <img src="" width="0" alt="">
            </a>
        </li>
    
        <li>
            <a href="">
                <img src="" width="0" alt="">
            </a>
        </li>
    
</ul>
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">Welcome to my Blog - J`Han</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-Java8手册 - Java8新增特性详解"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/11/29/Java8%E6%89%8B%E5%86%8C%20-%20Java8%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/"
    >Java8手册 - Java8特性详解</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/11/29/Java8%E6%89%8B%E5%86%8C%20-%20Java8%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3/" class="article-date">
  <time datetime="2021-11-29T00:55:03.000Z" itemprop="datePublished">2021-11-29</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p>笔者注：本手册暂未全部完成，暂且仅完成1/3的进度，预计3个月之内全部完成，吧~<br><br/><br><a name="CifN6"></a></p>
<h1 id="行为参数化-Behavior-Parameterization"><a href="#行为参数化-Behavior-Parameterization" class="headerlink" title="行为参数化(Behavior Parameterization)"></a>行为参数化(Behavior Parameterization)</h1><p>行为参数化是一种程序设计的理念，可以简单的理解为将函数作为参数以实现方法的多样化适应性。<br><a name="LTruc"></a></p>
<h2 id="谓词-Predicte"><a href="#谓词-Predicte" class="headerlink" title="谓词(Predicte)"></a>谓词(Predicte)</h2><p><a name="noXsM"></a></p>
<h3 id="谓词概念"><a href="#谓词概念" class="headerlink" title="谓词概念"></a>谓词概念</h3><p>谓词是对事物的判断的函数表达，即用一个函数来断言一个事物的行为或状态，以下是谓词的要素：</p>
<ol>
<li><p>谓词是一个函数/方法；</p>
</li>
<li><p>谓词在执行判断，所以会返回布尔值；</p>
</li>
<li><p>谓词判断的是事物的要素。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weather</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String weather;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 谓词接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeatherPredicate</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> Boolean <span class="title">weatherPredicate</span><span class="params">(Weather weather)</span></span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 谓词实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">whatEver</span> <span class="keyword">implements</span> <span class="title">WeatherPredicate</span></span>&#123;</span><br><span class="line">	   <span class="function"><span class="keyword">public</span> Boolean <span class="title">weatherPredicate</span><span class="params">(Weather weather)</span></span>&#123;</span><br><span class="line">       		<span class="keyword">return</span> weather.getWeather().equals(<span class="string">&quot;Sunny&quot;</span>);   </span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是一个简单的谓词示例，用来判断天气是否为晴天的谓词示例。<br><a name="e6hlM"></a></p>
<h3 id="Predicate接口"><a href="#Predicate接口" class="headerlink" title="Predicate接口"></a>Predicate接口</h3><p>Predicte接口是一个函数式接口，定义了一个抽象方法test，接收泛型对象，并返回一个布尔值。即我们可以使用这个函数式接口进行事务的行为或状态的判断。<br />以下是PredicateAPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断现有天气是否为晴天</span></span><br><span class="line">Predicate&lt;Weather&gt; p = (Weather w) -&gt; w.getWeather().equals(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate.nagate() 对现有Predicate取非</span></span><br><span class="line"><span class="comment">// 判断现有天气是否不是晴天</span></span><br><span class="line">Predicate&lt;Weather&gt; p2 = p.nagate();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate.or() 两个Predicate取并集，天气是否为晴天或者雨天</span></span><br><span class="line">Predicate&lt;Weather&gt; p3 = p.or((Weather w) -&gt; w.getWeather().equals(<span class="string">&quot;Rainy&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate.and() 两个Predicate取交集，天气是否为晴雨天</span></span><br><span class="line">Predicate&lt;Weather&gt; p4 = p.and((Weather w) -&gt; w.getWeather().equals(<span class="string">&quot;Rainy&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Predicate.or().and() 天气是否为晴雪天或者晴雨天 =&gt; 布尔表达式 (p || p1) &amp;&amp; p2</span></span><br><span class="line">Predicate&lt;Weather&gt; p5 = p.or((Weather w) -&gt; w.getWeather().equals(<span class="string">&quot;Rainy&quot;</span>)).and((Weather w) -&gt; w.getWeather().equals(<span class="string">&quot;Snowy&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>​<br /><br><a name="rufWt"></a></p>
<h2 id="消费-消耗-Consumer"><a href="#消费-消耗-Consumer" class="headerlink" title="消费/消耗(Consumer)"></a>消费/消耗(Consumer)</h2><p><a name="qEiIo"></a></p>
<h3 id="消费概念"><a href="#消费概念" class="headerlink" title="消费概念"></a>消费概念</h3><p>消费表示某个事务执行的一系列的行为，比如让一个去翻一个跟头，其中<code>翻一个跟头</code>就是一个消费(Consumer)，以下是消费的要素：</p>
</li>
<li><p>消费需要有一个主语，即执行动作的主角；</p>
</li>
<li><p>消费是一个动作，所以没有返回值；</p>
</li>
<li><p>消费可以有一个动作，但是动作不是必须的，所以函数主体可以是空的。<br><a name="R8zOE"></a></p>
<h3 id="Consumer接口"><a href="#Consumer接口" class="headerlink" title="Consumer接口"></a>Consumer接口</h3><p>Consumer接口是一个函数式接口，定义了一个抽象方法accept，接受一个泛型对象，没有返回值。一般我们用这个函数式接口执行一些操作。<br />示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="comment">// 函数式接口Consumer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Consumer</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 唯一抽象方法</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(List&lt;T&gt; list, Consumer&lt;T&gt; c)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(T t : list)&#123;</span><br><span class="line">        <span class="comment">// 调用函数式接口的唯一抽象方法</span></span><br><span class="line">    	c.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	forEach(</span><br><span class="line">    	Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>),</span><br><span class="line">        <span class="comment">// 此处是Consumer.accept()方法的具体实现，也就是所谓函数主体</span></span><br><span class="line">        (Integer i) -&gt; System.out.println(i)</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a name="aL51x"></a></p>
<h2 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数(Function)"></a>函数(Function)</h2><p><a name="ArxnC"></a></p>
<h3 id="函数概念"><a href="#函数概念" class="headerlink" title="函数概念"></a>函数概念</h3><p>函数表示一个事物动态的映射演变，比如生物学说中猴子演变成人类，就是猴子逐渐演变成了人，以下是函数的要素：</p>
</li>
<li><p>函数有两个主体，演变前的原主体，演变后的现主体；</p>
</li>
<li><p>函数有一个过程，将原主体演变成现主体；</p>
</li>
<li><p>函数是一个演变的过程，入参是原主体，返回值是现主体；<br><a name="IzvWn"></a></p>
<h3 id="Function接口"><a href="#Function接口" class="headerlink" title="Function接口"></a>Function接口</h3><p>Function接口是一个函数式接口，定义了一个抽象方法apply，接受一个泛型对象，返回另一个泛型对象。一般我们用这个函数式接口进行类型转换。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注释基本和Consumer的代码块一致，此处就不写注释了，因为我懒</span></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Function</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt;</span>&#123;</span><br><span class="line">	<span class="function">R <span class="title">apply</span><span class="params">(T t)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, R&gt; <span class="function">List&lt;R&gt; <span class="title">map</span><span class="params">(List&lt;T&gt; list, Function&lt;T, R&gt; f)</span></span>&#123;</span><br><span class="line">	List&lt;R&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(T s: list)&#123;</span><br><span class="line">    	result.add(f.apply(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;Integer&gt; l = map(</span><br><span class="line">	Arrays.asList(<span class="string">&quot;为了联盟&quot;</span>,<span class="string">&quot;为了部落&quot;</span>,<span class="string">&quot;为了希尔瓦娜斯&quot;</span>),</span><br><span class="line">    (String s) -&gt; s.length()</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>以下是FunctionAPI：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Function&lt;T, R&gt;().andThen() 衔接两个Function</span></span><br><span class="line"><span class="comment">// 给定数字+1</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x +<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 给定数字*2</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f1 = x -&gt; x * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 使用Function&lt;T, R&gt;().andThen() 衔接f和f1，效果相当于执行了f之后，将f的结果传给f1作为参数，即f1(f(x))</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f2 = f.andThen(f1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = f2.apply(<span class="number">1</span>); <span class="comment">// 此处结果为4 = (1+1)*2;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Function&lt;T, R&gt;().compose() 衔接两个Function</span></span><br><span class="line"><span class="comment">// 给定数字+1</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f = x -&gt; x +<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 给定数字*2</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f1 = x -&gt; x * <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 使用Function&lt;T, R&gt;().compose() 衔接f和f1，效果相当于将f1的执行结果给f作为参数，即f(f1(x))</span></span><br><span class="line">Function&lt;Integer, Integer&gt; f2 = f.andThen(f1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> result = f2.apply(<span class="number">1</span>);<span class="comment">// 此处结果为3 = (1*2)+1;</span></span><br></pre></td></tr></table></figure>
<p><a name="Gb1Tn"></a></p>
<h2 id="原始类型特化类"><a href="#原始类型特化类" class="headerlink" title="原始类型特化类"></a>原始类型特化类</h2><p>Java8新增的接口接受的都是泛型，泛型是引用数据类型，所以不支持原始数据类型。虽然我们可以使用包装数据类型进行兼容，但是性能上是有损耗的，因此对于原始数据类型进行了特化。<br><a name="mTfvh"></a></p>
<h3 id="谓词特化"><a href="#谓词特化" class="headerlink" title="谓词特化"></a>谓词特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Predicate&lt;R&gt; =&gt; T -&gt; boolean</span><br><span class="line">								IntPredicate</span><br><span class="line">                LongPredicate</span><br><span class="line">                DoublePredicate</span><br></pre></td></tr></table></figure>
<p><a name="Owocq"></a></p>
<h3 id="消费特化"><a href="#消费特化" class="headerlink" title="消费特化"></a>消费特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Consumer&lt;T&gt; =&gt; T -&gt; void</span><br><span class="line">								IntConsumer</span><br><span class="line">                LongConsumer</span><br><span class="line">                DoubleConsumer</span><br></pre></td></tr></table></figure>
<p><a name="JwSde"></a></p>
<h3 id="函数特化"><a href="#函数特化" class="headerlink" title="函数特化"></a>函数特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Function&lt;T, R&gt; =&gt; T -&gt; R</span><br><span class="line">									IntFunction&lt;R&gt;</span><br><span class="line">                  IntToDoubleFunction</span><br><span class="line">                  IntToLongFunction</span><br><span class="line">                  LongFunction&lt;R&gt;</span><br><span class="line">                  LongToDoubleFunction</span><br><span class="line">                  LongToIntFunction</span><br><span class="line">                  DoubleFunction&lt;R&gt;</span><br><span class="line">                  ToIntFunction&lt;T&gt;</span><br><span class="line">                  ToDoubleFunction&lt;T&gt;</span><br><span class="line">                  ToLongFunction&lt;T&gt;</span><br></pre></td></tr></table></figure>
<p><a name="qg3jg"></a></p>
<h3 id="其他特化"><a href="#其他特化" class="headerlink" title="其他特化"></a>其他特化</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// 供应，抽象接口用于获取泛型中的数据</span><br><span class="line">Supplier&lt;T&gt; =&gt; () -&gt; T</span><br><span class="line">									BooleanSupplier</span><br><span class="line">                  IntSupplier</span><br><span class="line">                  LongSupplier</span><br><span class="line">                  DoubleSupplier</span><br><span class="line">// 一元操作，抽象接口用于获取一元操作本身</span><br><span class="line">UnaryOperator&lt;T&gt; =&gt; T -&gt; T</span><br><span class="line">                  	IntUnaryOperator</span><br><span class="line">                    LongUnrayOperator</span><br><span class="line">                    DoubleUnrayOperator</span><br><span class="line">// 二元操作，同上</span><br><span class="line">BinaryOperator&lt;T&gt; =&gt; (T, T) -&gt; T</span><br><span class="line">                    	IntBinaryOperator</span><br><span class="line">                      LongBinaryOperator</span><br><span class="line">                      DoubleBinaryOperator</span><br><span class="line">// 双参谓词</span><br><span class="line">BiPredicate&lt;L, R&gt; =&gt; (L, R) -&gt; boolean</span><br><span class="line">// 双参消费</span><br><span class="line">BiConsumer&lt;T, U&gt; =&gt; (T, U) -&gt; void</span><br><span class="line">                      ObjIntConsumer(T)</span><br><span class="line">                      ObjLongConsuemr(T)</span><br><span class="line">                      ObjDoubleConsumer(T)</span><br><span class="line">// 双参函数</span><br><span class="line">BiFunction&lt;T, U, R&gt; =&gt; (T, U) -&gt; R</span><br><span class="line">                      	ToIntBiFunction&lt;T, U&gt;</span><br><span class="line">                        ToLongBiFunction&lt;T, U&gt;</span><br><span class="line">                        ToDoubleBiFunction&lt;T, U&gt;</span><br></pre></td></tr></table></figure>
<p><a name="NMKky"></a></p>
<h2 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h2><p>Lambda表达式的本质是简化书写的匿名类的方法，因此Lambda表达式有以下特点：</p>
</li>
<li><p>匿名性 - Lambda表达式和匿名函数一样，没有引用，即用即抛；</p>
</li>
<li><p>函数性 - 因为是简化的匿名方法，因此和普通方法一样，具有参数、返回值、主体和异常；</p>
</li>
<li><p>可传递性 - Lambda表达式和匿名方法一样，可以作为参数进行传递；</p>
</li>
<li><p>简洁性 - 如其名。</p>
</li>
</ol>
<ul>
<li>注：Lambda表达式中，仅作为表达式默认自带return，带上函数主体需要显示写出return<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lambda表达式</span></span><br><span class="line">(Integer i, Integer j) -&gt; &#123;i.compareTo(j);&#125;</span><br><span class="line">---------------------- == ------------------</span><br><span class="line"> 		Lambda参数	 箭头 	Lambda主体</span><br><span class="line"><span class="comment">// 传统写法</span></span><br><span class="line">Comparator&lt;Integer&gt; isTheSame = <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer i, Integer j)</span></span>&#123;</span><br><span class="line">    	<span class="keyword">return</span> i.compareTo(j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Lambda表达式仅作为表达式写法</span></span><br><span class="line">item-&gt;item <span class="comment">//会return item</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lambda表达式带上函数主体写法</span></span><br><span class="line">item -&gt; &#123;item;&#125;<span class="comment">//没有返回值</span></span><br></pre></td></tr></table></figure>
Lambda表达式运用场景，用在函数式接口上。<br><a name="HIyjh"></a><h3 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h3>函数式接口就是只<strong>定义</strong>了<strong>一个抽象方法</strong>的<strong>接口</strong>，以下为结论：</li>
</ul>
<ol>
<li>它是一个接口；</li>
<li>可以拥有默认方法，但是仅有一个抽象方法；</li>
<li>可以继承和被继承，如果继承了父类，加上父类的抽象方法在内，仅能有一个抽象方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 传入一个接口并调用接口的待实现方法，可以理解为触发器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shot</span><span class="params">(Say say)</span></span>&#123;</span><br><span class="line">        say.say(<span class="string">&quot;芜湖！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过Lambda表达式调用并实现函数式接口</span></span><br><span class="line">        <span class="keyword">new</span> App().shot((String str) -&gt; System.out.println(str));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义函数式接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Say</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">(String str)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<a name="ymhYf"></a><h3 id="函数描述符"><a href="#函数描述符" class="headerlink" title="函数描述符"></a>函数描述符</h3>函数描述符由返回值和入参构成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String word)</span></span>; ===&gt; String -&gt; String  </span><br><span class="line">									<span class="comment">// 入参     返回值</span></span><br></pre></td></tr></table></figure>
<a name="Agoe3"></a><h3 id="方法签名"><a href="#方法签名" class="headerlink" title="方法签名"></a>方法签名</h3>方法签名由参数列表和方法名构成。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">say</span><span class="params">(String word)</span></span>; ===&gt; say(String)</span><br></pre></td></tr></table></figure>
<a name="rJQS8"></a><h3 id="Lambda原理和运用"><a href="#Lambda原理和运用" class="headerlink" title="Lambda原理和运用"></a>Lambda原理和运用</h3><a name="AA52l"></a><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4>Lambda的类型是根据调用Lambda的上下文（传参和返回值）进而推断出来的，以下为一个Lambda的类型检查的一个过程示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isTodaySunny = isSunny(today, (Weather weather) -&gt; weather.equals(<span class="string">&quot;Sunny&quot;</span>));</span><br><span class="line"><span class="comment">// 1 =&gt; 查看调用方的定义</span></span><br><span class="line">isSunny() =&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isSunny</span><span class="params">(Weather today, Predicate&lt;Weather&gt; p)</span></span>;</span><br><span class="line"><span class="comment">// 2 =&gt; 确认Lambda的目标类型</span></span><br><span class="line">(Weather weather) -&gt; weather.equals(<span class="string">&quot;Sunny&quot;</span>) =&gt; Predicate&lt;Weather&gt;</span><br><span class="line"><span class="comment">// 3 =&gt; 确认调用方法，即函数式接口的唯一抽象方法</span></span><br><span class="line">(Weather weather) -&gt; weather.equals(<span class="string">&quot;Sunny&quot;</span>) =&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(Weather weather)</span></span>;</span><br><span class="line"><span class="comment">// 4 =&gt; 确认函数描述符</span></span><br><span class="line">Weather -&gt; <span class="keyword">boolean</span> </span><br><span class="line"><span class="comment">// 5 =&gt; 函数式接口的函数描述符和调用方的函数描述符一致，类型检查无误</span></span><br><span class="line">Weather -&gt; <span class="keyword">boolean</span> === Weather -&gt; <span class="keyword">boolean</span></span><br></pre></td></tr></table></figure>
<a name="erwmw"></a><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4>Java编译器会从上下文中通过函数描述符来推断参数类型，因此可以省略掉入参的数据类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isTodaySunny = isSunny(today, weather -&gt; weather.equals(<span class="string">&quot;Sunny&quot;</span>));</span><br></pre></td></tr></table></figure>
<a name="aDeRA"></a><h4 id="Lambda和变量"><a href="#Lambda和变量" class="headerlink" title="Lambda和变量"></a>Lambda和变量</h4>Lambda可以无限制的赋值给实例变量和静态变量，当赋值给局部变量时候，局部变量必须为final或者实际上的final（即仅被赋值一次）。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Lambda和闭包(closure)</span><br><span class="line">Q：什么是闭包？</span><br><span class="line">A：闭包是程序语言中的一种参数绑定的概念，闭包是一个结构体，它在被捕捉时确认结构体内自由变量的值，即脱离上下文程序也能正常运行。</span><br><span class="line">Q：Lambda是闭包吗？</span><br><span class="line">A：Lambda不是闭包，但是能实现类似闭包的效果。</span><br></pre></td></tr></table></figure>
<a name="rfDGZ"></a><h4 id="Lambda方法引用"><a href="#Lambda方法引用" class="headerlink" title="Lambda方法引用"></a>Lambda方法引用</h4>Lambda的方法引用是一种特殊的语法，格式是<code>类名</code>+<code>::</code>+<code>方法名</code>，它是使用Lambda的一种语法糖(在不影响程序的基础上，使得语法更加简洁、易读、易用)。<br />Lambda的方法引用主要有三类，用法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.指向静态方法</span></span><br><span class="line">Integer::parseInt =&gt; Integer.parseInt();</span><br><span class="line"><span class="comment">// 注意，此处的Integer::parseInt实际指向的是一个函数式接口，意思是需要用一个函数式接口的引用去接收, 相当于将一个函数式接口进行了实现</span></span><br><span class="line"><span class="comment">// 例如 Function&lt;String, Integer&gt; f = Integer::parseInt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.指向实例方法的的方法引用</span></span><br><span class="line">String::length =&gt; String.length();</span><br><span class="line"><span class="comment">// 上述简写是对Lambda的简写，完整的Lambda如下</span></span><br><span class="line">(String s) -&gt; s.length() =&gt; String::length</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指向现有对象的实例方法的引用</span></span><br><span class="line">easyTransaction::getValue =&gt; easyTransaction.getValue();</span><br><span class="line"><span class="comment">// 上述简写是对Lambda的简写，完整的Lambda如下</span></span><br><span class="line">() -&gt; easyTransaction.getValue() =&gt; easyTransaction::getValue</span><br></pre></td></tr></table></figure>
注：进行方法引用的使用需要注意<code>函数描述符</code>需要一致，示例如下。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">&quot;d&quot;</span>,<span class="string">&quot;c&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.sort(String::compareToIgnoreCase);</span><br><span class="line"><span class="comment">// 拆解讲解</span></span><br><span class="line"><span class="comment">// 此处Lambda方法引用替换掉了Comparator&lt;String&gt;.compare(String o1, String o2);</span></span><br><span class="line"><span class="comment">// 即 Comparator&lt;String&gt;.compare(String o1, String o2) = String::compareToIgnoreCase</span></span><br><span class="line"><span class="comment">// Comparator&lt;String&gt;.compare(String o1, String o2) 的函数描述符是 String, String -&gt; int</span></span><br><span class="line"><span class="comment">// String::cmpareToIgnoreCase 的函数描述符也是 String, String -&gt; int</span></span><br></pre></td></tr></table></figure>
<a name="Tv4Ym"></a><h4 id="Lambda构造函数引用"><a href="#Lambda构造函数引用" class="headerlink" title="Lambda构造函数引用"></a>Lambda构造函数引用</h4>无参构造函数就如同Supplier的方法签名<code>() -&gt; T</code>，有参构造函数就如同Function&lt;T, R&gt;的方法签名<code>(T) -&gt; R</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参构造函数示例</span></span><br><span class="line">Weather weather = <span class="keyword">new</span> Weather();</span><br><span class="line"><span class="comment">// Lambda构造函数引用</span></span><br><span class="line">Supplier&lt;Weather&gt; s = Weather::<span class="keyword">new</span>; <span class="comment">// 拆解 Supplier&lt;Weather&gt; s = () -&gt; new Weather(); </span></span><br><span class="line">Weather w = s.get();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 带参构造函数示例</span></span><br><span class="line">Weather weather = <span class="keyword">new</span> Weather(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"><span class="comment">// Lambda构造函数引用</span></span><br><span class="line">Function&lt;String, Weather&gt; f = Weather::<span class="keyword">new</span>; <span class="comment">// 拆解 Function&lt;String, Weather&gt; f = (String s) -&gt; new Weather(s);</span></span><br><span class="line">Weather w = f.apply(<span class="string">&quot;Sunny&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/** ============================== 间隔 ============================== **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Q:如果有两个以上参数的构造函数咋办？A:麻烦自己封装一下</span></span><br></pre></td></tr></table></figure>
​</li>
</ol>
<p><a name="a9bAe"></a></p>
<h1 id="StreamAPI"><a href="#StreamAPI" class="headerlink" title="StreamAPI"></a>StreamAPI</h1><p>StreamAPI是基于Stream的一个API库，Stream（又称流）是<code>基于支持数据处理操作的源中生成的元素序列</code>，以下为Steam的要素的释义：</p>
<ul>
<li>元素序列 —— 如果需要给流一个强定义（流是什么），那么流就是元素序列。集合是对集合内元素的管理和访问。流则是一个操作的过程。</li>
<li>源 —— 源就是生成流的源，例如数组、集合…。</li>
<li>数据处理操作 —— 流支持对流的数据进行操作。</li>
<li>流水线 —— 这是流的很大的一个特性，也是为什么可以将流理解为操作过程的原因。很多流操作会返回流的操作本体，因此就能形成链式调用，也就是一条流水线。</li>
<li>内部迭代 —— 与Iterator的显示迭代不同，流的迭代是在背后进行的。</li>
</ul>
<p>Stream和Collection的区别：</p>
<ul>
<li>Stream是需求驱动（需要时计算），Collection是供应商驱动（先供应再计算）</li>
<li>Stream只能遍历一次，Collection可以遍历多次</li>
<li>Stream是内部迭代，Collection是外部迭代（增强for循环/for-each语法，Iterator迭代）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">外部迭代：</span><br><span class="line">	需要显式的取出每一个项目然后进行处理。</span><br><span class="line">内部迭代：</span><br><span class="line">	需要定义如何进行操作然后Stream自动进行。</span><br></pre></td></tr></table></figure>
<a name="KkSfp"></a><h2 id="流操作"><a href="#流操作" class="headerlink" title="流操作"></a>流操作</h2>StreamAPI定义了很多操作，它们分作两大类：中间操作和终端操作。<br><a name="h15xr"></a><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3>定义：中间操作会返回流本身，多个中间操作链接起来可以形成查询，但除非整个流操作中执行了中断操作，否则整个流操作不会执行任何处理。<br />注：<strong>流操作不影响流中的元素本身</strong>！！！<br><a name="TCnFt"></a><h4 id="筛选"><a href="#筛选" class="headerlink" title="筛选"></a>筛选</h4>使用<code>filter</code>方法进行筛选，它接受一个谓词作为参数，并返回一个包括所有谓词判断为<code>true</code>的元素的流。<br><a name="CvEwo"></a><h4 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h4>使用<code>distinct</code>方法进行去重，它会根据流中元素的<code>hashCode</code>和<code>equals</code>方法进行判断去重，并返回包含去重后的元素的流。<br><a name="OBjYE"></a><h4 id="定长"><a href="#定长" class="headerlink" title="定长"></a>定长</h4>使用<code>limit</code>方法进行限制长度，它会返回不超过给定长度（可能不足，但是不会超过）的流。如果流是<strong>有序</strong>的，那么会返回<strong>前n个</strong>元素。<br><a name="RJKku"></a><h4 id="忽略"><a href="#忽略" class="headerlink" title="忽略"></a>忽略</h4>使用<code>skip</code>方法，返回丢弃掉前n个元素的流，若流中元素不足n个，则返回空流。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 忽略的定长的互动</span></span><br><span class="line"><span class="comment">//	limit和skip是互补的，例如以下代码。</span></span><br><span class="line"></span><br><span class="line">Integer[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;;</span><br><span class="line">Arrays.asList(arr).stream().limit(<span class="number">3</span>).skip(<span class="number">2</span>).forEach(System.out::println); <span class="comment">// 输出为3</span></span><br><span class="line">Arrays.asList(arr).stream().skip(<span class="number">2</span>).limit(<span class="number">3</span>).forEach(System.out::println); <span class="comment">// 输出为3 4 5</span></span><br></pre></td></tr></table></figure>
<a name="nZQN7"></a><h4 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h4>使用<code>map</code>方法进行映射（转换），它接受函数（Function&lt;T, R&gt;）作为参数，因此也返回对应函数的返回值。<br><a name="e7Zsi"></a><h4 id="扁平化"><a href="#扁平化" class="headerlink" title="扁平化"></a>扁平化</h4>使用<code>flatMap</code>方法将多个数组/集合转换成的流映射成当前流的内容，示例如下。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Integer[] a1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">Integer[] a2 = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">Integer[] a3 = &#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">List&lt;Integer[]&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(a1);</span><br><span class="line">list.add(a2);</span><br><span class="line">list.add(a3);</span><br><span class="line">list.stream().flatMap(Arrays::stream).forEach(System.out::println);</span><br><span class="line"><span class="comment">// 输出结果为 1 2 3 4 5 6 7 8 9</span></span><br></pre></td></tr></table></figure>
<a name="wWpT4"></a><h3 id="终端操作"><a href="#终端操作" class="headerlink" title="终端操作"></a>终端操作</h3>定义：终端操作会使流操作生成结果，其结果可以是任何不是流的值，包括void在内。<br><a name="RM9so"></a><h4 id="匹配"><a href="#匹配" class="headerlink" title="匹配"></a>匹配</h4>使用<code>anyMatch</code>方法，它接受一个谓词，检查流中元素是否至<strong>少有一个</strong>元素满足谓词条件，并返回结果（布尔值），短路操作（不需要全部判断）。<br />使用<code>allMatch</code>方法，它接受一个谓词，检查流中元素是否全部<strong>都能</strong>满足谓词条件，并返回结果（布尔值），短路操作（不需要全部判断）。<br />使用<code>noneMatch</code>方法，它接受一个谓词，检查流中元素是否全部<strong>都不能</strong>满足谓词条件，并返回结果（布尔值），短路操作（不需要全部判断）。<br><a name="bhh92"></a><h4 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h4>使用<code>findAny</code>方法，它将返回当前流中<strong>任意一个</strong>符合流操作的Optional<T>元素，一般可以搭配<code>filter</code>方法使用。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;T&gt;类，是一个容器类</span><br><span class="line">.isPresent() -&gt; Optional包含值则返回true，反之返回false</span><br><span class="line">.ifPresent(Consumer consumer) -&gt; 接受一个Consumer，会在存在值时执行Consumer</span><br><span class="line">.get() -&gt; 会在存在值时返回值，反之抛出NoSuchElement异常</span><br><span class="line">.orElse(T other) -&gt; 会在存在值时返回该值，反之返回other</span><br></pre></td></tr></table></figure>
使用<code>findFirst</code>方法，它将返回当前流中顺序上的第一个Optional<T>元素。（findAny耗时上比findFirst少）。<br><a name="coSgi"></a><h4 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h4>归约：归约在广义的概念是将A问题的解决方法归约到B问题中来，意思是A问题也可以通过B问题的解决方式进行处理。在Stream中归约是一个终端操作，表示将流中的<strong>所有元素通过一系列操作结合起来</strong>，得到一个值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求和示例1</span></span><br><span class="line">Optional&lt;Integer&gt; reduce = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce((a, b) -&gt; a + b);</span><br><span class="line"><span class="comment">// 求和示例2  第一个0是起始值</span></span><br><span class="line">Integer reduce = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce(<span class="number">0</span>, Integer::sum);</span><br><span class="line"><span class="comment">// 最大值示例</span></span><br><span class="line">Optional&lt;Integer&gt; max = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce(Integer::max);</span><br><span class="line">Optional&lt;Integer&gt; max_ = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce((n1, n2) -&gt; n1 &gt; n2 ? n1 : n2);</span><br><span class="line"><span class="comment">// 最小值示例</span></span><br><span class="line">Optional&lt;Integer&gt; min = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce(Integer::min);</span><br><span class="line">Optional&lt;Integer&gt; min_ = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).reduce((n1, n2) -&gt; n1 &lt; n2 ? n1 : n2);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">延伸阅读 - 名词解释：状态 &amp; 界</span><br><span class="line">- 编程界内含义（状态）</span><br><span class="line">状态分作有状态和无状态 - </span><br><span class="line">·有状态：有状态代表有数据存储功能，线程不安全。</span><br><span class="line">·无状态：无状态代表仅是一次操作，不能保存数据，线程安全。</span><br><span class="line">- Stream内含义（状态）</span><br><span class="line">·有状态操作：操作需要依托于内部状态（例如count求和之类的），就称之为有状态操作</span><br><span class="line">·无状态操作：操作不需要依托于内部状态，就称之为无状态操作</span><br><span class="line">- 编程界内含义（界）</span><br><span class="line">界的含义基本一致，界分作有界和无界 - </span><br><span class="line">·有界：数据存储有固定大小</span><br><span class="line">·无界：数据存储没有固定大小</span><br></pre></td></tr></table></figure>
<a name="GFMuR"></a><h2 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">中间操作</span><br><span class="line"></span><br><span class="line">操作					类  型					返回类型					操作参数									函数描述符					特殊备注</span><br><span class="line">filter				中间						Stream&lt;T&gt;				Predicate&lt;T&gt;						 T -&gt; boolean</span><br><span class="line">distinct			中间						Stream&lt;T&gt;																									有状态-无界</span><br><span class="line">skip					中间						Stream&lt;T&gt;				long																			有状态-无界</span><br><span class="line">limit					中间						Stream&lt;T&gt;				long																			有状态-无界</span><br><span class="line">map						中间						Stream&lt;T&gt;				Function&lt;T, R&gt;					 T -&gt; R</span><br><span class="line">flatMap				中间						Stream&lt;T&gt;				Function&lt;T, Stream&lt;R&gt;&gt;	 T -&gt; Stream&lt;R&gt;</span><br><span class="line">sorted				中间						Stream&lt;T&gt;				Comparator&lt;T&gt;						 (T, T) -&gt; int		有状态-无界</span><br><span class="line"></span><br><span class="line">anyMatch			终端						boolean					Predicate&lt;T&gt;						 T -&gt; boolean</span><br><span class="line">noneMatch			终端						boolean					Predicate&lt;T&gt;						 T -&gt; boolean</span><br><span class="line">allMatch			终端						boolean					Predicate&lt;T&gt;						 T -&gt; boolean</span><br><span class="line">findAny				终端						Optional&lt;T&gt;</span><br><span class="line">findFirst			终端						optional&lt;T&gt;</span><br><span class="line">forEach				终端						void						Consumer&lt;T&gt;							 T -&gt; void</span><br><span class="line">collect				终端						R								Collector&lt;T,A,R&gt;</span><br><span class="line">reduce				终端						Optional&lt;T&gt;			BinaryOperator&lt;T&gt;				 (T,T) -&gt; T				有状态-无界</span><br><span class="line">count					终端						long</span><br></pre></td></tr></table></figure>
<a name="hWRts"></a><h2 id="数值流"><a href="#数值流" class="headerlink" title="数值流"></a>数值流</h2>数值流是将流内元素特化为特定原始数据类型（int、long、double），并返回特定的数据流以及提供特定的方法。<br><a name="lxpCM"></a><h3 id="映射到数值流（原始流）"><a href="#映射到数值流（原始流）" class="headerlink" title="映射到数值流（原始流）"></a>映射到数值流（原始流）</h3><code>mapToInt</code>发方法转为IntStream，在IntStream内只能生成int，<code>mapToLong</code>、<code>mapToDouble</code>同理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为int流</span></span><br><span class="line">IntStream intStream = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToInt(item -&gt; item);</span><br><span class="line"><span class="comment">// 转为long流</span></span><br><span class="line">LongStream longStream = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToLong(item -&gt; item);</span><br><span class="line"><span class="comment">// 转为double流</span></span><br><span class="line">DoubleStream doubleStream = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToDouble(item -&gt; item);</span><br></pre></td></tr></table></figure>
<a name="V40Oe"></a><h3 id="原始流重新封装"><a href="#原始流重新封装" class="headerlink" title="原始流重新封装"></a>原始流重新封装</h3><code>boxed</code>方法可以将原始数据流转为一般流<code>Stream</code>（int -&gt; Integer）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int -&gt; Integer</span></span><br><span class="line">Stream&lt;Integer&gt; boxedInt = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToInt(item -&gt; item).boxed();</span><br><span class="line"><span class="comment">// long -&gt; Long</span></span><br><span class="line">Stream&lt;Long&gt; boxedLong = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToLong(item -&gt; item).boxed();</span><br><span class="line"><span class="comment">// bouble -&gt; Double</span></span><br><span class="line">Stream&lt;Double&gt; boxedDouble = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToDouble(item -&gt; item).boxed();</span><br></pre></td></tr></table></figure>
<a name="Am65z"></a><h3 id="Optional特化"><a href="#Optional特化" class="headerlink" title="Optional特化"></a>Optional特化</h3><code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>是数值流中特化的<code>Optional</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int特化</span></span><br><span class="line">OptionalInt optionalInt = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToInt(item -&gt; item).max();</span><br><span class="line"><span class="comment">// long特化</span></span><br><span class="line">OptionalLong optionalLong = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToLong(item -&gt; item).max();</span><br><span class="line"><span class="comment">// double特化</span></span><br><span class="line">OptionalDouble optionalDouble = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;).mapToDouble(item -&gt; item).max();</span><br></pre></td></tr></table></figure>
<a name="NwDjv"></a><h3 id="范围取值"><a href="#范围取值" class="headerlink" title="范围取值"></a>范围取值</h3><code>IntStream</code>和<code>LongStream</code>提供<code>.range</code>方法和<code>.rangeClose</code>方法以获取一个范围值的原始数值流，两个方法的区别是前者提供<code>前闭后开区间的范围值</code>，后台提供<code>闭区间的范围值</code>。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntStream的前闭后开区间</span></span><br><span class="line">IntStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(item-&gt; System.out.print(item+<span class="string">&quot;,&quot;</span>)); <span class="comment">// 打印1,2,3,4,5,6,7,8,9,</span></span><br><span class="line"><span class="comment">// IntStream的闭区间</span></span><br><span class="line">IntStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>).forEach(item-&gt; System.out.print(item+<span class="string">&quot;,&quot;</span>)); <span class="comment">// 打印1,2,3,4,5,6,7,8,9,10,</span></span><br><span class="line"><span class="comment">// LongStream的前闭后开区间</span></span><br><span class="line">LongStream.range(<span class="number">1</span>,<span class="number">10</span>).forEach(item-&gt; System.out.print(item+<span class="string">&quot;,&quot;</span>)); <span class="comment">// 打印1,2,3,4,5,6,7,8,9,</span></span><br><span class="line"><span class="comment">// LongStream的闭区间</span></span><br><span class="line">LongStream.rangeClosed(<span class="number">1</span>,<span class="number">10</span>).forEach(item-&gt; System.out.print(item+<span class="string">&quot;,&quot;</span>)); <span class="comment">// 打印1,2,3,4,5,6,7,8,9,10,</span></span><br></pre></td></tr></table></figure>
<a name="W3KFo"></a><h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Stream.of接受一个对象，并生成对应的对象流</span></span><br><span class="line">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">Stream&lt;String&gt; stringStream = Stream.of(<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>);</span><br><span class="line"><span class="comment">// Stream.empty生成一个空的对象流</span></span><br><span class="line">Stream&lt;Object&gt; empty = Stream.empty();</span><br><span class="line"><span class="comment">// 泛型Object可以修改</span></span><br><span class="line">Stream&lt;String&gt; empty = Stream.empty();</span><br><span class="line"><span class="comment">// Arrays.stream接受数组并生成数组内元素对应的流</span></span><br><span class="line">Stream&lt;Integer&gt; stream = Arrays.stream(<span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;);</span><br><span class="line"><span class="comment">// 由文件生成流 Files.lines会将给定文件转成流，流中每个元素都是文件中的一行</span></span><br><span class="line"><span class="keyword">long</span> uniqueWords = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Stream&lt;String&gt; lines = Files.lines(Paths.get(<span class="string">&quot;data.txt&quot;</span>), Charset.defaultCharset());</span><br><span class="line">            uniqueWords = lines.flatMap(line -&gt; Arrays.stream(line.split(<span class="string">&quot; &quot;</span>)))</span><br><span class="line">                    .distinct()</span><br><span class="line">                    .count();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 由函数生成无限流，生成无限流的地方都应该显式的进行限制</span></span><br><span class="line"><span class="comment">// Stream.iterate接受一个初始值，和一个迭代方法，因为会一直计算下去所以需要加上limit进行限制</span></span><br><span class="line">Stream.iterate(<span class="number">0</span>, n -&gt; n + <span class="number">1</span>).limit(<span class="number">10</span>).forEach(item -&gt; System.out.println(item));</span><br><span class="line"><span class="comment">// Stream.generate接受一个Supplier&lt;T&gt;类型的Lambda提供值</span></span><br><span class="line">Stream.generate(Math::random).limit(<span class="number">5</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<a name="JAE7Z"></a><h2 id="收集数据"><a href="#收集数据" class="headerlink" title="收集数据"></a>收集数据</h2><code>collect</code>方法接受一个<code>Collector</code>并将流内的元素按照要求进行归约并形成指定的对象。<br><a name="h2P5C"></a><h4 id="归约汇总"><a href="#归约汇总" class="headerlink" title="归约汇总"></a>归约汇总</h4><code>summarizing*</code>系列的方法能够处理对应的数据类型，且获得更多的信息。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器规则</span></span><br><span class="line">Comparator&lt;Person&gt; personComparator = Comparator.comparingInt(Person::getAge);</span><br><span class="line"><span class="comment">// 最大最小值</span></span><br><span class="line">Optional&lt;Person&gt; max = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(maxBy(personComparator));</span><br><span class="line">Optional&lt;Person&gt; min = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(minBy(personComparator));</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line">Integer sum = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summingInt(Person::getAge));</span><br><span class="line"><span class="comment">// 求总（总共多少个）</span></span><br><span class="line">Long count = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(counting());</span><br><span class="line"><span class="comment">// 平均数</span></span><br><span class="line">Double average = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(averagingInt(Person::getAge));</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;max=%d,min=%d,sum=%d,count=%d,average=%d.&quot;</span>, max.get().getAge(), min.get().getAge(), sum, count, average.intValue())); <span class="comment">// 输出 =&gt; max=3,min=1,sum=6,count=3,average=2.</span></span><br><span class="line"><span class="comment">// 最大最小值</span></span><br><span class="line"><span class="keyword">int</span> max1 = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summarizingInt(Person::getAge)).getMax();</span><br><span class="line"><span class="keyword">int</span> min1 = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summarizingInt(Person::getAge)).getMin();</span><br><span class="line"><span class="comment">// 求和</span></span><br><span class="line"><span class="keyword">long</span> sum1 = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summarizingInt(Person::getAge)).getSum();</span><br><span class="line"><span class="comment">// 求总（总共多少个）</span></span><br><span class="line"><span class="keyword">long</span> count1 = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summarizingInt(Person::getAge)).getCount();</span><br><span class="line"><span class="comment">// 平均数</span></span><br><span class="line"><span class="keyword">double</span> average1 = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(summarizingInt(Person::getAge)).getAverage();</span><br><span class="line">System.out.println(String.format(<span class="string">&quot;max1=%d,min1=%d,sum1=%d,count1=%d,average1=%d.&quot;</span>, max1, min1, sum1, count1, (<span class="keyword">int</span>) average1)); <span class="comment">// 输出 =&gt; max1=3,min1=1,sum1=6,count1=3,average1=2.</span></span><br></pre></td></tr></table></figure>
<a name="MjLd9"></a><h4 id="最大最小值"><a href="#最大最小值" class="headerlink" title="最大最小值"></a>最大最小值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 比较器规则</span></span><br><span class="line">Comparator&lt;Person&gt; personComparator = Comparator.comparingInt(Person::getAge);</span><br><span class="line"><span class="comment">// 最大值</span></span><br><span class="line">Optional&lt;Person&gt; max = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(maxBy(personComparator));</span><br><span class="line"><span class="comment">// 最小值</span></span><br><span class="line">Optional&lt;Person&gt; min = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(minBy(personComparator));</span><br></pre></td></tr></table></figure>
<a name="kk9sY"></a><h4 id="字符串连接"><a href="#字符串连接" class="headerlink" title="字符串连接"></a>字符串连接</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// joining可以将流内的字符串进行拼接（内部使用StringBuilder），无参则无缝连接，有参则作为间隔符</span></span><br><span class="line">Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;1&quot;</span>), <span class="keyword">new</span> Person(<span class="string">&quot;2&quot;</span>), <span class="keyword">new</span> Person(<span class="string">&quot;3&quot;</span>)&#125;).map(Person::getName).collect(joining(<span class="string">&quot;,&quot;</span>));</span><br></pre></td></tr></table></figure>
<a name="rPmtG"></a><h4 id="自定义归约汇总"><a href="#自定义归约汇总" class="headerlink" title="自定义归约汇总"></a>自定义归约汇总</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自定义求和</span></span><br><span class="line">Integer collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="number">1</span>), <span class="keyword">new</span> Person(<span class="number">2</span>), <span class="keyword">new</span> Person(<span class="number">3</span>)&#125;).collect(</span><br><span class="line">    reducing(<span class="number">0</span>, <span class="comment">// 当流内没有元素时的默认返回值</span></span><br><span class="line">             Person::getAge, <span class="comment">// 定义用于归约的数值</span></span><br><span class="line">             Integer::sum <span class="comment">// 定义归约的操作</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<a name="K50Vq"></a><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单级分组</span></span><br><span class="line">Map&lt;Gender, List&lt;Person&gt;&gt; collect = Arrays.stream(</span><br><span class="line">    <span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE)&#125;</span><br><span class="line">)</span><br><span class="line">    .collect(groupingBy(p -&gt; p.getGender()));</span><br><span class="line">System.out.println(collect); </span><br><span class="line"><span class="comment">/** 输出 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">FEMALE=[</span></span><br><span class="line"><span class="comment">Person(name=Anna, gender=FEMALE, age=0), </span></span><br><span class="line"><span class="comment">Person(name=Mia, gender=FEMALE, age=0)], </span></span><br><span class="line"><span class="comment">MALE=[</span></span><br><span class="line"><span class="comment">Person(name=Mike, gender=MALE, age=0), </span></span><br><span class="line"><span class="comment">Person(name=Jack, gender=MALE, age=0)</span></span><br><span class="line"><span class="comment">]</span></span><br><span class="line"><span class="comment">&#125; **/</span></span><br><span class="line"><span class="comment">// 多级分类</span></span><br><span class="line">Map&lt;Gender, Map&lt;String, List&lt;Person&gt;&gt;&gt; collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE)&#125;)</span><br><span class="line">                .collect(groupingBy(Person::getGender, groupingBy(p -&gt; &#123; <span class="comment">// 一级分组内带入了二级分组的条件</span></span><br><span class="line">                    <span class="keyword">if</span> (p.getName().startsWith(<span class="string">&quot;A&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;A_start&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.getName().startsWith(<span class="string">&quot;M&quot;</span>)) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;M_start&quot;</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="string">&quot;J_start&quot;</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;)));</span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">/** 输出 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">MALE=&#123;</span></span><br><span class="line"><span class="comment">M_start=[Person(name=Mike, gender=MALE, age=0)], </span></span><br><span class="line"><span class="comment">J_start=[Person(name=Jack, gender=MALE, age=0)]&#125;,</span></span><br><span class="line"><span class="comment">FEMALE=&#123;</span></span><br><span class="line"><span class="comment">M_start=[Person(name=Mia, gender=FEMALE, age=0)], </span></span><br><span class="line"><span class="comment">A_start=[Person(name=Anna, gender=FEMALE, age=0)]</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">&#125; **/</span></span><br><span class="line"><span class="comment">// 分组收集数据</span></span><br><span class="line">Map&lt;Gender, Long&gt; collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE)&#125;)</span><br><span class="line">                .collect(groupingBy(Person::getGender, counting()));</span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">/** 输出 &#123;MALE=2, FEMALE=2&#125; **/</span></span><br><span class="line"><span class="comment">// 混合使用，求分组内年纪最大的</span></span><br><span class="line">Map&lt;Gender, Person&gt; collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE, <span class="number">2</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE, <span class="number">2</span>)&#125;)</span><br><span class="line">                .collect( <span class="comment">// collect-Start</span></span><br><span class="line">                        groupingBy(Person::getGender,  <span class="comment">// groupingBy-Start</span></span><br><span class="line">                                   <span class="comment">// 按照性别分类</span></span><br><span class="line">                                collectingAndThen( <span class="comment">// collectingAndThen-Start</span></span><br><span class="line">                                    <span class="comment">// 按照分类收集并二次归约</span></span><br><span class="line">                                        maxBy(comparingInt(Person::getAge)), Optional::get) <span class="comment">// collectingAndThen-End</span></span><br><span class="line">                                   <span class="comment">// 找到年纪最大的，并通过Optional.get进行转换(maxBy的返回值是Optional)</span></span><br><span class="line">                        ) <span class="comment">// groupingBy-End</span></span><br><span class="line">                ); <span class="comment">// collect-End</span></span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">/** 输出 &#123;MALE=Person(name=Mike, gender=MALE, age=2), FEMALE=Person(name=Mia, gender=FEMALE, age=2)&#125; **/</span></span><br><span class="line"><span class="comment">// 分组并重组</span></span><br><span class="line">Map&lt;Gender, Set&lt;Person&gt;&gt; collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE)&#125;)</span><br><span class="line">                .collect(</span><br><span class="line">                        groupingBy(Person::getGender, mapping(item -&gt; item, toSet())) <span class="comment">// 根据性别分组，并按照分组重新装配Set</span></span><br><span class="line">                );</span><br><span class="line">System.out.println(collect); </span><br><span class="line"><span class="comment">/** 输出 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">FEMALE=[</span></span><br><span class="line"><span class="comment">Person(name=Mia, gender=FEMALE, age=0), </span></span><br><span class="line"><span class="comment">Person(name=Anna, gender=FEMALE, age=0)], </span></span><br><span class="line"><span class="comment">MALE=[</span></span><br><span class="line"><span class="comment">Person(name=Mike, gender=MALE, age=0), </span></span><br><span class="line"><span class="comment">Person(name=Jack, gender=MALE, age=0)]</span></span><br><span class="line"><span class="comment">&#125; **/</span></span><br></pre></td></tr></table></figure>
<a name="KFBTP"></a><h4 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h4>  分区其实是分组的一个特殊情况，是key值为布尔值的分组。它在进行分组的时候更加明确。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 为了简洁引入的依赖</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.stream.Collectors.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.util.Comparator.*;</span><br><span class="line"></span><br><span class="line">Map&lt;Boolean, Person&gt; collect = Arrays.stream(<span class="keyword">new</span> Person[]&#123;<span class="keyword">new</span> Person(<span class="string">&quot;Anna&quot;</span>, Gender.FEMALE, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Mike&quot;</span>, Gender.MALE, <span class="number">2</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Jack&quot;</span>, Gender.MALE, <span class="number">1</span>), <span class="keyword">new</span> Person(<span class="string">&quot;Mia&quot;</span>, Gender.FEMALE, <span class="number">2</span>)&#125;)</span><br><span class="line">                .collect( <span class="comment">// collect-Start</span></span><br><span class="line">                        partitioningBy(item -&gt; item.getGender().equals(Gender.MALE), <span class="comment">// partitioningBy-Start</span></span><br><span class="line">                                collectingAndThen( <span class="comment">// collectingAndThen-Start</span></span><br><span class="line">                                        maxBy(comparingInt(Person::getAge)), Optional::get) <span class="comment">// collectingAndThen-End</span></span><br><span class="line">                        ) <span class="comment">// groupingBy-End</span></span><br><span class="line">                ); <span class="comment">// collect-End</span></span><br><span class="line">System.out.println(collect);</span><br><span class="line"><span class="comment">/** 输出 </span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">false=Person(name=Mia, gender=FEMALE, age=2), </span></span><br><span class="line"><span class="comment">true=Person(name=Mike, gender=MALE, age=2)</span></span><br><span class="line"><span class="comment">&#125; </span></span><br><span class="line"><span class="comment">**/</span></span><br></pre></td></tr></table></figure>
<a name="VJZ2B"></a><h3 id="Collectors静态工厂类"><a href="#Collectors静态工厂类" class="headerlink" title="Collectors静态工厂类"></a>Collectors静态工厂类</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">方法							返回值										作用										示例					</span><br><span class="line">toList()			 	  List&lt;T&gt;								 收集流中元素到List				Stream.empty().collect(Collectors.toList())</span><br><span class="line">toSet()				 	  Set&lt;T&gt;									 收集流中元素到Set，去重		Stream.empty().collect(Collectors.toSet())</span><br><span class="line">toCollection() 	  Collection&lt;T&gt;					 收集流中元素到Collection	collect(Collectors.toCollection(ArrayList::new))</span><br><span class="line">counting()		 	  Long										 计算流中元素个数						collect(Collectors.counting())</span><br><span class="line">summingInt		 	  Integer								 计算流中项目中某个整形属性和 </span><br><span class="line">averageInt		 	  Integer								 计算流中项目中某个整形属性均值 </span><br><span class="line">summarizingInt 	  IntSummaryStatistics		 收集关于流中项目Integer属性的统计值，例如最大、最小、 总和与平均值</span><br><span class="line">joining				 	  String									 链接项目中的字符串</span><br><span class="line">maxBy					 	  Optional&lt;T&gt;						 按照给定比较器选出的最大元素的Optional，或如果流为空则为Optional.empty()</span><br><span class="line">minBy					 	  Optional&lt;T&gt;						 按照给定比较器选出的最小元素的Optional，或如果流为空则为Optional.empty()</span><br><span class="line">reducing			 	  对应归约操作的类型				 从初始值开始，按照操作归约成一个值</span><br><span class="line">collectingAndThen 函数对应的返回类型				 包裹一个收集器，对其结果应用转换函数</span><br><span class="line">groupingBy				Map&lt;K, List&lt;T&gt;&gt;				 根据项目中一个属性值对流中元素进行分组，并将属性值作为Map的Key</span><br><span class="line">partitioningBy		Map&lt;Boolean,List&lt;T&gt;&gt;	 根据流中项目的谓词结果来对项目进行分区</span><br></pre></td></tr></table></figure>
<a name="SomdO"></a><h2 id="小测试"><a href="#小测试" class="headerlink" title="小测试"></a>小测试</h2>题目：使用原始流求出100以内所有勾股数组合。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路一</span></span><br><span class="line">Stream&lt;<span class="keyword">int</span>[]&gt; stream = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed() <span class="comment">// 从1开始，到100结束</span></span><br><span class="line">                .flatMap(a -&gt; <span class="comment">// 将满足条件的值转为数组流</span></span><br><span class="line">                        IntStream.rangeClosed(a, <span class="number">100</span>) <span class="comment">// 从a开始，到100结束</span></span><br><span class="line">                         .filter(b -&gt; Math.sqrt(a * a + b * b) % <span class="number">1</span> == <span class="number">0</span>) <span class="comment">// 过滤勾股数</span></span><br><span class="line">                         .mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a, b, (<span class="keyword">int</span>) Math.sqrt(a * a + b * b)&#125;) <span class="comment">// 构造数组</span></span><br><span class="line">                );</span><br><span class="line"><span class="comment">// 思路二</span></span><br><span class="line"><span class="comment">// 与上者的区别是，上者先过滤再生成数组，下着先生成数组再过滤</span></span><br><span class="line">Stream&lt;<span class="keyword">double</span>[]&gt; stream1 = IntStream.rangeClosed(<span class="number">1</span>, <span class="number">100</span>).boxed().flatMap(</span><br><span class="line">                a -&gt;</span><br><span class="line">                        IntStream.rangeClosed(a, <span class="number">100</span>)</span><br><span class="line">    					.mapToObj(b -&gt; <span class="keyword">new</span> <span class="keyword">double</span>[]&#123;a, b, Math.sqrt(a * a + b * b)&#125;)</span><br><span class="line">    					.filter(arr -&gt; arr[<span class="number">2</span>] % <span class="number">1</span> == <span class="number">0</span>)</span><br><span class="line">        );</span><br></pre></td></tr></table></figure>
题目：生成斐波那契元组序列<br />注：假设斐波那契数列是一组数组，每个数组又两个整数组成，数字的组成规则是 - 每个数字都是前两个数字的和<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 思路1</span></span><br><span class="line">Stream.iterate(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, a -&gt; <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;a[<span class="number">1</span>], a[<span class="number">0</span>]+a[<span class="number">1</span>]&#125;) <span class="comment">// 此处a代表上一个数组，以此形成迭代关系</span></span><br><span class="line">                .limit(<span class="number">20</span>)</span><br><span class="line">                .forEach(t -&gt; System.out.println(<span class="string">&quot;(&quot;</span> + t[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + t[<span class="number">1</span>] +<span class="string">&quot;)&quot;</span>));</span><br><span class="line"><span class="comment">// 思路2</span></span><br><span class="line">IntSupplier fib = <span class="keyword">new</span> IntSupplier()&#123;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> previous = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> current = <span class="number">1</span>;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAsInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">                <span class="keyword">int</span> oldPrevious = <span class="keyword">this</span>.previous;</span><br><span class="line">                <span class="keyword">int</span> nextValue = <span class="keyword">this</span>.previous + <span class="keyword">this</span>.current;</span><br><span class="line">                <span class="keyword">this</span>.previous = <span class="keyword">this</span>.current;</span><br><span class="line">                <span class="keyword">this</span>.current = nextValue;</span><br><span class="line">                <span class="keyword">return</span> oldPrevious;</span><br><span class="line">            &#125; &#125;;</span><br><span class="line">IntStream.generate(fib).limit(<span class="number">10</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>
<a name="uQ3hu"></a><h1 id="接口默认方法"><a href="#接口默认方法" class="headerlink" title="接口默认方法"></a>接口默认方法</h1>给接口设计者提供了一个扩充接口的方式，且并不会破坏现有的接口层次，例如，维护接口是新增一个通用功能，但又不希望改变其他实现类。<br />​<br /><br><a name="TWsmx"></a><h1 id=""><a href="#" class="headerlink" title=""></a></h1></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java8/" rel="tag">Java8</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第八章-Solr分面查询"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AB%E7%AB%A0-Solr%E5%88%86%E9%9D%A2%E6%9F%A5%E8%AF%A2/"
    >Solr手册-第八章 Solr分面查询</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AB%E7%AB%A0-Solr%E5%88%86%E9%9D%A2%E6%9F%A5%E8%AF%A2/" class="article-date">
  <time datetime="2021-10-31T02:17:49.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AB%E7%AB%A0-Solr%E5%88%86%E9%9D%A2%E6%9F%A5%E8%AF%A2/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第七章-Solr查询与搜索结果"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%83%E7%AB%A0-Solr%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/"
    >Solr手册-第七章 Solr查询与搜索结果</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%83%E7%AB%A0-Solr%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/" class="article-date">
  <time datetime="2021-10-31T02:17:31.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br />[<br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%83%E7%AB%A0-Solr%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第六章-Solr文本分析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AD%E7%AB%A0-Solr%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/"
    >Solr手册-第六章 Solr文本分析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AD%E7%AB%A0-Solr%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" class="article-date">
  <time datetime="2021-10-31T02:17:14.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AD%E7%AB%A0-Solr%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第五章-Solr索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/"
    >Solr手册-第五章 Solr索引</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2021-10-31T02:17:02.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第四章-Solr简单配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"
    >Solr手册-第四章 Solr简单配置</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2021-10-31T02:16:49.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第三章-Solr基础理论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"
    >Solr手册-第三章 Solr基础理论</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="article-date">
  <time datetime="2021-10-31T02:16:31.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第二章-Solr上手"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Solr%E4%B8%8A%E6%89%8B/"
    >Solr手册-第二章 Solr上手</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Solr%E4%B8%8A%E6%89%8B/" class="article-date">
  <time datetime="2021-10-31T02:16:16.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Solr%E4%B8%8A%E6%89%8B/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr手册-第一章-Solr入门"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-Solr%E5%85%A5%E9%97%A8/"
    >Solr手册-第一章 Solr入门</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-Solr%E5%85%A5%E9%97%A8/" class="article-date">
  <time datetime="2021-10-31T02:14:54.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%80%E7%AB%A0-Solr%E5%85%A5%E9%97%A8/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
    <article
  id="post-Solr权重因子解析"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2021/10/31/Solr%E6%9D%83%E9%87%8D%E5%9B%A0%E5%AD%90%E8%A7%A3%E6%9E%90/"
    >Solr权重因子解析</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%9D%83%E9%87%8D%E5%9B%A0%E5%AD%90%E8%A7%A3%E6%9E%90/" class="article-date">
  <time datetime="2021-10-31T01:39:39.000Z" itemprop="datePublished">2021-10-31</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>
<a name="PUNpl"></a>
# 写在前面
本手册仅说明基于Lucene的搜索引擎的权重问题，是一篇非常硬核的文档。如果对该问题不太清楚实际上也并不会影响你使用Solr。<br /> 
      <a class="article-more-link" href="/2021/10/31/Solr%E6%9D%83%E9%87%8D%E5%9B%A0%E5%AD%90%E8%A7%A3%E6%9E%90/"
        >阅读更多...</a
      >
       
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E8%BF%9B%E9%98%B6/" rel="tag">Solr进阶</a></li></ul>

    </footer>
  </div>

   
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="J`Han&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HomePage</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Document</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Solr/">Solr</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>如果觉得对您有帮助，来个打赏吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>