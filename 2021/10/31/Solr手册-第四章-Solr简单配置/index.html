<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Solr手册-第四章 Solr简单配置 |  J`Han&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Solr手册-第四章-Solr简单配置"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Solr手册-第四章 Solr简单配置
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/" class="article-date">
  <time datetime="2021-10-31T02:16:49.000Z" itemprop="datePublished">2021-10-31</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">13.7k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">48 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。<span id="more"></span><br><a name="N3pon"></a></p>
<h1 id="Chapter-Four-配置Solr"><a href="#Chapter-Four-配置Solr" class="headerlink" title="Chapter Four 配置Solr"></a>Chapter Four 配置Solr</h1><ul>
<li>solr.xml——定义管理、日志、分片和SolrCloud的有关属性</li>
<li>solrconfig.xml——定义Solr内核的主要配置</li>
<li>schema.xml(managed-schema)——定义索引结构，包括字段及其数据类型</li>
</ul>
<p>因为Solr的大部分配置文件都是XML格式的，所以本章节包含大量solrconfig.xml文件中的XML代码片段。本章的重点并不是介绍具体的XML语法，而是这些配置代码背后的原理，况且这些XML语法都是自解释型的。<br />首先，从配置的角度来了解Solr服务器启动的过程，Solr作为一个Java Web应用运行在Jetty中，<strong>使用全局Java(solr.solr.home)来定位配置文件的根目录</strong>。接下来，<strong>Solr在主目录下扫描包含core.properties文件的子文件夹，该文件定义了Solr中自动发现内核的基本属性</strong>。例如，在示例服务器中，example/solr/collection1目录下有core.properties文件，该文件中仅有一行代码name=collection1，定义了内核的名称，Solr通过这行代码就能自动发现名为collection1的solr内核。图4.1描述了core.properties文件和solrconfig.xml文件在Solr的初始化过程中是如何创建和设置collection1内核的。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622559939165-31552ca4-56fa-42c8-8400-42f6554deccb.png#height=738&id=UTqtw&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1476&originWidth=2144&originalType=binary&ratio=1&size=1036172&status=done&style=none&width=1072" alt="image.png"><br />在Solr的早期版本中，开发者需要在solr.xml文件中定义内核，这样做的缺点是需要先为内核创建专门的文件夹，再在solr.xml文件中添加该内核的定义。而新版本中利用core.properties文件省略了上述步骤，更重要的是，这种方式使得每个内核都是独立包含的，不再需要一份中心配置文件来定义所有的内核。<br />示例服务器中collection1的配置文件core.properties仅仅定义了必要的内核名称。除此以外，还可以设置一系列可选参数对内核的定义做适当的调整。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622559956986-e0847f2b-7780-4945-9d9f-fe5b227948f1.png#height=498&id=O38gq&margin=%5Bobject%20Object%5D&name=image.png&originHeight=996&originWidth=2162&originalType=binary&ratio=1&size=911489&status=done&style=none&width=1081" alt="image.png"><br />需要重点理解的是，<strong>Solr可以在启动期间利用core.properties文件自动发现内核</strong>。<strong>一旦内核被发现，Solr就能定位到位于$SOLR_HOME/$instanceDir/conf/solrconfig.xml文件夹下的solrconfig.xml文件</strong>，其中core.properties文件位于$instanceDir/文件夹中。<strong>Solr利用solrconfig.xml文件来初始化内核</strong>。<br><a name="GBLTV"></a></p>
<h2 id="solrconfig-xml文件概览"><a href="#solrconfig-xml文件概览" class="headerlink" title="solrconfig.xml文件概览"></a>solrconfig.xml文件概览</h2><p>启动命令行启动示例服务器。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $SOLR_INSTALL/example</span><br><span class="line">java -jar start.jar</span><br></pre></td></tr></table></figure>
<p>一旦成功地启动了服务器，就可以在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8983/solr%EF%BC%8C%E8%BF%9B%E5%85%A5Solr%E7%9A%84%E7%AE%A1%E7%90%86%E6%8E%A7%E5%88%B6%E5%8F%B0%EF%BC%8C%E7%82%B9%E5%87%BB%E9%A1%B5%E9%9D%A2%E5%B7%A6%E8%BE%B9%E7%9A%84collection1%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%86%8D%E7%82%B9%E5%87%BBFiles%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%B0%86%E4%BC%9A%E7%9C%8B%E5%88%B0collection1%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E3%80%82%E7%82%B9%E5%87%BBsolrconfig.xml%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5%EF%BC%8C%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84collection1%E4%B8%AD%E5%B7%B2%E5%90%AF%E7%94%A8%E7%9A%84%E9%85%8D%E7%BD%AE%E3%80%82%E4%BB%A5%E4%B8%8B%E5%B1%95%E7%A4%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E7%BC%A9%E7%95%A5%E7%89%88%E7%9A%84solrconfig.xml%E6%96%87%E4%BB%B6%EF%BC%8C%E4%BB%A5%E4%BE%BF%E4%BA%8E%E4%BD%A0%E4%BA%86%E8%A7%A3%E8%AF%A5%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E3%80%82">http://localhost:8983/solr，进入Solr的管理控制台，点击页面左边的collection1链接，再点击Files链接，将会看到collection1的所有配置文件的目录结构。点击solrconfig.xml文件链接，可以看到正在运行的collection1中已启用的配置。以下展示了一个缩略版的solrconfig.xml文件，以便于你了解该配置文件的主要内容。</a><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622559971858-c573c19f-a4a2-40c6-88f6-dc9175bff5a5.png#height=663&id=HmyqL&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1326&originWidth=2266&originalType=binary&ratio=1&size=1326923&status=done&style=none&width=1133" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622561050271-91aeaae2-0ff4-42e5-90ca-350e490446b6.png#height=628&id=E6s1X&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1256&originWidth=2112&originalType=binary&ratio=1&size=1193336&status=done&style=none&width=1056" alt="image.png"><br />从以上代码清单中可以看出，solrconfig.xml文件由大量复杂的XML代码块组成。当然，并不需要现在就掌握该配置文件的所有内容，在碰到实际需求时再做具体了解即可。从这里可以看出Solr的配置有很大的灵活性。<br />本章节将<strong>根据Solr配置之间的依赖关系来安排Solr配置的介绍顺序，而不是根据配置元素在XML文档中的排列顺序依次介绍</strong>。例如，尽管在solrconfig.xml文件中，缓存的配置元素在请求处理的配置元素之前，但本章仍在缓存之前介绍Solr的请求处理框架，在利用缓存优化具体客户端请求之前，你需要理解这些请求在Solr中的处理方式。简单的说，<strong>在学习本章的时候，你不得不来回翻阅配置文件</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622561534290-9e900fdb-a6b9-4666-9337-c001d4cf69a5.png#height=329&id=ULNKq&margin=%5Bobject%20Object%5D&name=image.png&originHeight=658&originWidth=1920&originalType=binary&ratio=1&size=1490515&status=done&style=none&width=960" alt="image.png"><br><a name="7PSH2"></a></p>
<h3 id="常见的XML数据结构和数据类型元素"><a href="#常见的XML数据结构和数据类型元素" class="headerlink" title="常见的XML数据结构和数据类型元素"></a>常见的XML数据结构和数据类型元素</h3><p>如果你浏览一遍solrconfig.xml文件，就会看到各种用于表示数据结构和数据类型的XML元素。表4.2列举了solrconfig.xml主要的数据类型元素，以及它们的简要说明和距离。这些元素还将出现在XML格式的搜索结果中，所以需要花一点时间熟悉这种Solr特有的语法。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622561725016-2274cde0-e904-4f9e-bcef-93853f823b31.png#height=660&id=HoBIm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1320&originWidth=2032&originalType=binary&ratio=1&size=814538&status=done&style=none&width=1016" alt="image.png"><br /><strong><arr>和<lst>之间最大不同是<lst>中的每个子元素都有一个name熟悉，而<arr>的子元素没有</strong>。<br><a name="zKids"></a></p>
<h3 id="配置文件更新的应用"><a href="#配置文件更新的应用" class="headerlink" title="配置文件更新的应用"></a>配置文件更新的应用</h3><p>Solr并不会自动识别配置文件的更改，必须要重新加载内核之后新的配置才会生效。最简单的操作方式就是，点击管理控制台中内核管理(Core Admin)页面的Reload按钮，如下图所述。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622562723795-d5504c1d-b041-47f2-be2a-94a451c49612.png#height=637&id=nmFa7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1274&originWidth=1988&originalType=binary&ratio=1&size=707787&status=done&style=none&width=994" alt="image.png"><br />在本章的最后，还会介绍另外一种重载内核的方法，即利用内核管理API编写程序来重载内核。<br><a name="UTAhA"></a></p>
<h2 id="Solr的其他配置"><a href="#Solr的其他配置" class="headerlink" title="Solr的其他配置"></a>Solr的其他配置</h2><p>以上介绍了Solr配置的一些背景知识，接下来将从Solr服务器的各种配置开始学习solrconfig.xml配置文件。代码清单4.3囊括了本小结要介绍的所有配置内容。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622709243414-bd31b63f-ac2a-4469-b93b-275b62a5a282.png#height=298&id=EuJPV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=596&originWidth=2026&originalType=binary&ratio=1&size=476538&status=done&style=none&width=1013" alt="image.png"><br><a name="7ALBv"></a></p>
<h3 id="Lucene版本"><a href="#Lucene版本" class="headerlink" title="Lucene版本"></a>Lucene版本<lucencenMatchVersion></h3><p>Lucene和Solr具有良好的向后兼容能力。<luceneMatchVersion>元素定义了Solr索引使用的Lucene版本。如果你是刚开始启用Solr，直接使用示例服务器中定义的版本即可。<br />如果Solr已经运行了数月，索引了百万级别的文档，此时你决定将它们更新到一个较新版本。在更新完成后重启Solr服务器时，它会利用<luceneMatchVersion>来了解索引使用的Lucene版本，并决定是否要禁用一些版本不兼容的功能。<br />上述方式使得新版本的Solr可以运行在旧版本的索引上。但在某些时候可能需要提升<luceneMatchVersion>的数值来采用一些Lucene的新特新和对bug进行修复。在这种情况下，可以重新索引所有文档，或者使用Lucene的内置的索引升级工具(Class IndexUpgrader，org.apache.lucene.index.IndexUpgrader)。如有需要，可以参阅Lucene的JavaDoc来获得升级工具的使用说明。<br><a name="YShsz"></a></p>
<h3 id="加载依赖的Jar包"><a href="#加载依赖的Jar包" class="headerlink" title="加载依赖的Jar包"></a>加载依赖的Jar包</h3><p><lib>元素允许向Solr的classpath中添加Jar包，以便Solr能够定位需要调用的插件类。下面来看solrconfig.xml文件中<lib>元素的工作原理。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">&quot;../../../contrib/langid/lib/&quot;</span> <span class="attr">regex</span>=<span class="string">&quot;.*\.jar&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">dir</span>=<span class="string">&quot;../../../dist/&quot;</span> <span class="attr">regex</span>=<span class="string">&quot;solr-langid-\d.*\.jar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>每一个<lib>都指定了一个路径名和一个用于匹配Jar包的正则表达式。注意<strong>dir属性值是以内核的根目录为起点的相对路径</strong>，该根目录也常被称为内核的instanceDir(实例目录)。对于示例服务器中的collection1而言，instanceDir为 <code>$SOLR_INSTALL/example/collection1/</code> ;需要注意， <code>$SOLR_INSTALL/</code> 是一个变量，它的值是Solr分发包解压缩时所处的绝对路径。因此，上述示例中的两个<lib>将下列Jar包添加到了Solr的classpath中：</p>
<ul>
<li>jsonic-1.2.7.jar(位于contrib/langid/lib/)</li>
<li>langdetect-1.1-20120112.jar(位于contrib/langid/lib/)</li>
<li>apache-solr-langid-4.7.0.jar(位于dist)</li>
</ul>
<p>需要注意的是apache-solr-langid.jar文件的版本号会随着Solr4具体版本的不同而改变。另外，也可以使用path属性引用单个Jar包，如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">lib</span> <span class="attr">path</span>=<span class="string">&quot;../../../dist/solr-langid-4.7.0.jar&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>还可以将依赖的Jar包都放在 <code>$SOLR_HOME/lib/</code> 目录中。如 <code>$SOLR_INSTALL/example/solr/lib/</code> 。<br><a name="Gxumj"></a></p>
<h3 id="启用JMX"><a href="#启用JMX" class="headerlink" title="启用JMX"></a>启用JMX</h3><p><strong><jmx>用于激活Solr的MBeans，允许系统管理员使用一些类似Nagios的常用系统监控工具监控和管理核心Solr组件</strong>。简而言之，<strong>MBean是一个Java对象，他可以调用Java管理拓展JMX的API获得Solr的配置参数和统计信息</strong>。MBeans可以被Solr自动发现并被JMX兼容工具监控。这样可以将对Solr监控集成到已有的系统监控机制中。<br />实际上，并不一定需要一个兼容JMX的外部监控工具来查看Solr的MBeans的运行实况。Solr自带的管理控制台就支持对Solr中所有MBeans的访问。图4.3是利用管理控制台访问collection1的MBean的截图。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622733630123-ed3401d7-c16f-432f-9e05-d4dc1023a5a1.png#height=603&id=wiZra&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1206&originWidth=1524&originalType=binary&ratio=1&size=592240&status=done&style=none&width=762" alt="image.png"><br><a name="RcYmx"></a></p>
<h2 id="查询请求处理"><a href="#查询请求处理" class="headerlink" title="查询请求处理"></a>查询请求处理</h2><p>Solr的主要功能是搜索，所以搜索请求的处理是Solr最重要的处理之一。本节介绍Solr搜索请求处理框架，以及如何让自定义请求处理器更适合特殊搜索请求的操作方法。<br><a name="Rw2Zt"></a></p>
<h3 id="请求处理简介"><a href="#请求处理简介" class="headerlink" title="请求处理简介"></a>请求处理简介</h3><p>对Solr发起请求需要通过Http。如果是查询请求，则为Http Get方法；如果是索引请求，则是Http Post方法。代码请求4.4展示了一个利用Http Get方法对示例Solr服务器发起查询的示例。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622735424905-2b04f1d6-1c9f-4468-aadb-2cbc3ab0f319.png#height=439&id=Ed9ph&margin=%5Bobject%20Object%5D&name=image.png&originHeight=878&originWidth=2148&originalType=binary&ratio=1&size=833877&status=done&style=none&width=1074" alt="image.png"><br />示例代码的http工具提供了很多可选项，例如，允许修改Solr服务器的地址，或将返回数据格式从XML改为其他格式，如JSON。要查看所有可选项，请在命令行中输入  <code>java-jar solr-in-action.jar listing -h</code> 。<br />图4.4展示了Solr中处理客户端请求的时间队列和主要组件。从图4.4的左上角开始依次为：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622735988275-6dd323e6-f411-4a52-b3b1-0698acbe462f.png#height=486&id=vc2qm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=972&originWidth=1798&originalType=binary&ratio=1&size=884064&status=done&style=none&width=899" alt="image.png"></p>
<ol>
<li>客户端应用将Http Get<strong>请求发送至<a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/select?q=%C2%B7%C2%B7%C2%B7">http://localhost:8983/solr/collection1/select?q=···</a></strong>，<strong>查询参数通过</strong>该Get请求中的<strong>查询字符串进行传递</strong>。</li>
<li>Jetty接收客户端请求，并<strong>根据请求路径中/solr后的内容将该请求交给Solr中统一的请求分配器</strong>。从技术角度来说，统一请求分配器就是一个Java Servlet过滤器，可以为Solr Web应用过滤出符合/*的Url，<strong>详见org.apache.solr.servlet.SolrDispatchFilter类</strong>。</li>
<li>Solr的<strong>请求分配器根据客户端请求路径中的collection1确定所查询的内核名称</strong>。接下来，<strong>请求分配器会定位到solrconfig.xml文件中定义的/select请求处理器</strong>。</li>
<li>/select请求处理器利用一系列搜索组件处理客户端请求。</li>
<li>在处理完客户端请求之后，查询结果<strong>经由相应读写器组件进行格式化之后返回给客户端应用</strong>；默认情况下，/select请求处理器返回的结果数据为XML格式。</li>
</ol>
<p>请求分配器的主要职能是根据用户请求语句定位到处理该请求的内核，如collection1，然后将用户请求交给该内核中已注册的对应请求处理器，在上例中为/select。实际应用中，请求分配器的默认配置对于大多数应用来说已经足够了。<br />另外，开发者也可以自定义请求处理器或在/select等已有处理器的基础上做个性化的修改，这些都是很常见的处理方式。<br><a name="KdnOA"></a></p>
<h3 id="搜索处理器"><a href="#搜索处理器" class="headerlink" title="搜索处理器"></a>搜索处理器</h3><p>代码清单4.5展示了solrconfig.xml文件中对/select请求处理器的定义。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622776706907-19417da3-c4df-44c1-acc7-b83b620d3a4f.png#height=372&id=m6iXh&margin=%5Bobject%20Object%5D&name=image.png&originHeight=372&originWidth=1292&originalType=binary&ratio=1&size=419015&status=done&style=none&width=1292" alt="image.png"><br />从代码清单4.5中可以看出，所有的请求处理器都实现了一个Java类：本例实现了solr.SearchHandler。在运行时，solr.SearchHandler被解析为内置的Solr类org.apache.solr.handler.component.SearchHandler。一般来说，只要在solrconfig.xml文件中看到一个前缀为 <code>solr.</code> 的类，都应该想到是下列Solr的核心Java包之一： <code>analysis.</code> 、 <code>schema.</code> 、 <code>handler.</code> 、 <code>search.</code> 、 <code>update.</code> 、 <code>core.</code> 、 <code>request.</code> 、 <code>update.processor.</code> 、 <code>util.</code> 、 <code>spelling.</code> 、 <code>handler.component.</code> 或 <code>handler.dataimport.</code> 。在配置文件中利用 <code>solr.</code> 前缀简写Solr类的名称，运行时在解析至相应的内置Solr类，这种方式让配置文件看起来更加简洁有序。<br />Solr中有两类主要的请求处理器：<strong>处理查询请求的搜索处理器</strong>和<strong>处理索引请求的更新处理器</strong>。本章将重点介绍搜索处理器处理查询请求的过程，参见图4.5.<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622793039706-0a713204-bd20-4b83-90ec-4e2094ab8a4f.png#height=786&id=KkKmS&margin=%5Bobject%20Object%5D&name=image.png&originHeight=786&originWidth=1214&originalType=binary&ratio=1&size=626981&status=done&style=none&width=1214" alt="image.png"><br />图4.5展示了搜索处理器的结构，这种设计方式使得应用程序很容易根<strong>据实际情况调整Solr的查询处理过程</strong>。例如，可以自定义请求处理器，或者更加<strong>常见的做法</strong>，<strong>在/select等已有请求处理器的基础上增加自定义搜索组件</strong>。通常情况下，一个搜索处理器由以下组件组成，其中<strong>每个组件都定义在solrconfig.xml文件中</strong>。</p>
<ol>
<li><strong>请求参数修饰组件</strong>，包括：<ol>
<li><strong>默认值修饰</strong>(defaults)—— 为客户端未指定值的参数添加默认值。</li>
<li><strong>常量修饰</strong>(invariants)—— 将客户端的参数值覆写为固定值。</li>
<li><strong>后缀修饰</strong>(append)—— 在客户端请求的末尾添加额外参数。</li>
</ol>
</li>
<li><strong>预处理组件</strong>(first-components)—— 一组有限执行的可选搜索组件，执行预处理任务。</li>
<li><strong>主搜索组件</strong>(components)—— 一组链式组合的搜索组件，至少包含查询组件。</li>
<li><strong>后处理组件</strong>(last components)—— 一组可选的链式组合的搜索组件，执行后处理任务。</li>
</ol>
<p>一般而言，一个请求处理器并不需要定义上述所有组件，比如代码清单4.5中，/select请求处理器仅仅定义了默认值修饰组件。这意味着所有其他组件均默认为solr.SearchHandler的实现。如果<strong>请求处理器中的主组件未定义，则会使用一组默认的搜索组件</strong>。在实际应用中，通常使用自定义的请求处理器来简化客户端应用程序。<br><a name="YFZZd"></a></p>
<h3 id="Solritas的browse请求处理器示例"><a href="#Solritas的browse请求处理器示例" class="headerlink" title="Solritas的browse请求处理器示例"></a>Solritas的browse请求处理器示例</h3><p>降低客户端代码的复杂度是Web服务和面向对象设计的核心。Solr采用了这种成熟的设计模式，允许开发者自定义搜索请求处理器，从而降低solr客户端代码的复杂度。例如，可以自定义一个默认启用拼写纠正功能的请求处理器，而不用每次都要求客户端请求中含有启用拼写纠正的参数。<br />Solr示例服务器预先配置了使用上述设计模式的Solritas应用示例。代码清单4.6展示了solrconfig.xml文件中/browse请求处理器的简要定义。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622898161603-106bcf8d-9762-4dee-a9ed-24ece9f2c527.png#height=1354&id=pzrg8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1354&originWidth=2188&originalType=binary&ratio=1&size=1188496&status=done&style=none&width=2188" alt="image.png"><br />建议读者将solrconfig.xml文件中所有关于/browse请求处理器的配置详细阅读一遍。从中，为了展示Solr中很多强大的特性，/browse的这个实例在配置上花了很多精力。一开始使用Solr时，不需要做出像/browse那样复杂的配置，不过积累了一些Solr开发经验之后，可以尝试自定义一些Solr的请求处理器。<br />下面我们在Solritas实例中查看/browse请求处理器的运行情况。启动Solr示例服务器以后，在浏览器中访问 <code>http://localhost:8983/solr/collection1/browse</code> 。如图4.6所示，在搜索框中输入iPod。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622898427380-1a87e6e7-4651-49a8-903b-1f51ef2014e5.png#height=859&id=bSJot&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1718&originWidth=1984&originalType=binary&ratio=1&size=1721333&status=done&style=none&width=992" alt="image.png"><br />浏览图4.6中的信息，你会发现这条简单的查询语句激活了Solr中的许多搜索特性。在界面背后，Solritas的搜索框向/browse请求处理器提交了一个查询。在日志文件中，可以看到如下信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO：[collection1]webapp=/solr path=browse params=&#123;iPod&#125; hits=3 status=0 QTime=22</span><br></pre></td></tr></table></figure>
<p>请注意，我们仅仅通过搜索框提交了一个参数q=iPod，<strong>返回结果却包含了分面、更多类似结果、拼写检查、分页和高亮显示等功能</strong>。<br />这个简单的q=iPod查询充分体现了Solr所具有的丰富功能，这些功能在/browse请求处理器中是默认参数启用的。<br />从代码清单4.6中可以看出， <code>defaults&lt;lst&gt;</code> 元素是由许多个名称/取值对组成的有序列表，<strong>如果客户端程序没有明确指定查询参数，这个有序列表就为查询参数提供默认值</strong>。例如，默认的相应数据格式参数wt是velocity(<str name="wt">velocity</str>)，其中Velocity是一个利用Java语言开发的开源模板引擎(<a target="_blank" rel="noopener" href="http://velocity.apache.org/engine/index.html)%E3%80%82">http://velocity.apache.org/engine/index.html)。</a><br />根据上面的日志信息，搜索框提交的参数仅是q，所有其他的参数都设置为defaults。下面通过一个小实验来查看请求处理器接收到的真实查询语句。<strong>将响应读写器 <strong><code>wt</code> <strong>参数设为xml，而不是默认的velocity，这样能够看到没有Html修饰的原始返回数据</strong>。同时，</strong>为了查看所有的请求参数，需要将echoParams的值设为all</strong>。这是修改客户端传递参数默认值的一个很好示例。代码清单4.7将展示查询Url和返回结果中的<params>部分内容，请注意观察提交到/browse请求处理器的参数数量。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622899214106-e4ee214a-a16b-482c-b5d8-d55f09d02f09.png#height=843&id=vXjDv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1686&originWidth=1976&originalType=binary&ratio=1&size=1275268&status=done&style=none&width=988" alt="image.png"><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622899229802-0e133357-45e4-429f-b367-dd12bff4bcb9.png#height=822&id=At2SH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1644&originWidth=1890&originalType=binary&ratio=1&size=1083023&status=done&style=none&width=945" alt="image.png"><br />从代码清单4.7中可以看出，<strong>针对搜索请求处理器的请求参数修饰是Solr的一个大功能亮点</strong>，特别是默认参数列表的设计，为应用程序带来两大好处：</p>
<ul>
<li><strong>在应用程序的某个配置文件中设置合理的默认参数值，可以帮助简化客户端的代码</strong>。例如，将响应读写器参数 <code>wt</code> 的值设为velocity，这样客户端应用就不需要再请求语句中指定返回数据的格式了。更重要的是，如果需要将Velocity改为其他的模板引擎，客户端代码不需要对此做任何改动。</li>
<li><strong>通过预先设置复杂的组件，如分面，可以确保所有查询行为的一致性，同时保证客户端代码的整洁</strong>。从代码清单4.7中可以看出，实例请求包含了Solritas中搜索组件的一些复杂参数配置。在Solritas中配置分面会涉及20多个参数。</li>
</ul>
<p><strong>/browse请求处理器是展示Solr在查询处理方面的功能特性的很好载体</strong>，但是<strong>一般情况下，开发者的应用程序无法直接使用它，因为它的参数配置和Solritas的底层数据模型紧密联系在一起的</strong>。例如，Solritas中的区间分面字段是price、popularity，manufacture_dt等，这是针对Solritas的数据模型设计的，可能并不适用于开发者的应用程序。因此，读者在为自己的应用程序设计请求处理器时候，<strong>应该仅仅将/browse请求处理器看做一个样板</strong>，而不是一个可以<strong>100%复用的解决方案</strong>。<br><a name="XE5ZT"></a></p>
<h2 id="利用搜索组件扩展查询处理"><a href="#利用搜索组件扩展查询处理" class="headerlink" title="利用搜索组件扩展查询处理"></a>利用搜索组件扩展查询处理</h2><p>除了一组默认值以外，/browse请求处理器还定义了一个数组<arr>，其中包含有<last-components>定义的一组后处理组件。注意到在代码清单4.6中/browse请求处理器定义了以下功能。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">arr</span> <span class="attr">name</span>=<span class="string">&quot;last-components&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">str</span>&gt;</span>spellcheck<span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">arr</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这样的配置意味着，执行完默认搜索组件之后，再执行拼写检查组件。这是搜索请求处理器的一种常见设计模式。图4.7展示了在查询处理的<components>阶段使用到的6个内置搜索组件。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622900323388-89e4380e-b0dc-4b6e-95a3-fc8bc0e949e1.png#height=138&id=HsHsB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=276&originWidth=1372&originalType=binary&ratio=1&size=231627&status=done&style=none&width=686" alt="image.png"><br><a name="u0WxT"></a></p>
<h3 id="查询组件"><a href="#查询组件" class="headerlink" title="查询组件"></a>查询组件</h3><p><strong>查询组件是Solr查询处理过程的核心</strong>。从较高层次看，<strong>查询组件利用处于活跃状态的搜索器对查询语句进行解析和执行</strong>。<strong>查询语句的解析策略由 <strong><code>**defType**</code></strong> 参数指定</strong>。例如，/browse请求处理器指定 <code>eDisMax</code> 作为查询语句的解析器(<str name="defType">edismax</str>)， <code>eDisMax</code> 相关内容将在第七章中详细介绍。<br /><strong>查询组件在索引中找出所有符合条件的文档，形成结果文档集</strong>。<strong>结果文档集可以随后供查询处理链中的其他组件(如分面组件)使用</strong>。查询组件<strong>默认处于启用状态</strong>，而所有的其他组件则需要在查询请求中指定相应的参数来启用。<br><a name="GZter"></a></p>
<h3 id="分面组件"><a href="#分面组件" class="headerlink" title="分面组件"></a>分面组件</h3><p>当给定一组由查询组件得出的结果文档集时，如果分面组件被启用了，<strong>它将根据字段分面进行结果统计与过滤</strong>。分面已经内置在每个搜索请求中，但需要在查询请求中指定对应参数才能被启用。在/browse请求处理器中，分面是通过配置文件中的默认参数配置来启用的： <code>&lt;str name=&quot;facet&quot;&gt;true&lt;/str&gt;</code> 。<br><a name="UEDev"></a></p>
<h3 id="更多类似结果组件"><a href="#更多类似结果组件" class="headerlink" title="更多类似结果组件"></a>更多类似结果组件</h3><p>当给定一组由查询组件生成的结果文档集时，如果更多类似结果组件被启用了，它将识别出与搜索结果集中的文档相似的其他文档。下面是一个更多类似结果组件的实例，在Solritas示例应用中搜索hard drive，点击搜索结果 <code>&quot;Samsung SpinPoint P120 SP2514N - hard drive - 250GB - ATA-133&quot;</code> 的 <code>More Like This</code> 链接，可以看到一个相关文档的列表，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622907308290-1f0a30aa-10cd-46a7-a46f-f66635827e2d.png#height=565&id=OiKfW&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1130&originWidth=1866&originalType=binary&ratio=1&size=1723216&status=done&style=none&width=933" alt="image.png"><br />更多类似结果组件的内容详见第16章。<br><a name="5zp6J"></a></p>
<h3 id="高亮组件"><a href="#高亮组件" class="headerlink" title="高亮组件"></a>高亮组件</h3><p>如果高亮组件被启用了，它将对<strong>结果文档中与查询语句高度相关的文档内容进行高亮表示</strong>。详见第9章。<br><a name="VBgPv"></a></p>
<h3 id="统计组件"><a href="#统计组件" class="headerlink" title="统计组件"></a>统计组件</h3><p>统计组件可以为结果文档中的数值字段计算最小值、最大值、总和、平均值和标准差等简单的统计指标。执行代码清单4.8中的Get请求可以得到统计组件的一个运行示例。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622907448084-f005fb9e-d852-4fe9-bd66-277ec5c10e70.png#height=625&id=Uzejg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1250&originWidth=2020&originalType=binary&ratio=1&size=837582&status=done&style=none&width=1010" alt="image.png"><br><a name="OIxe6"></a></p>
<h3 id="调试组件"><a href="#调试组件" class="headerlink" title="调试组件"></a>调试组件</h3><p><strong>调试组件会返回执行过的查询语句解析后的结果，以及结果文档集中每个文档相关度分数计算的详细信息</strong>。解析后的查询本身会被返回，以帮助开发者追踪查询表达式中存在的问题。调试器对于追踪并调试烦琐的搜索结果排名问题有很大帮助。在浏览器中访问 <code>http://lcalhost:8983/solr/collection1/browse?q=iPod&amp;wt=xml&amp;debugQuery=true</code> 可以查看一个调试组件的运行示例。<br />需要注意的是，这个Url请求所执行的查询与上文在Solritas示例中通过表单提交的查询时一样的，只是在这里将响应读写器参数wt设为xml(而不是Velocity)，并且在Url中指定 <code>debug=true</code> ，即启用调试组件。代码清单4.9展示了调试组件返回的xml数据片段。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622907689918-e52fefb1-1669-4bab-84da-0e9145df3c78.png#height=233&id=ASdn5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=466&originWidth=1956&originalType=binary&ratio=1&size=329566&status=done&style=none&width=978" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622907704550-69febda2-3571-4c76-93f3-be7efb5adf01.png#height=576&id=tM4j3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1152&originWidth=1902&originalType=binary&ratio=1&size=716746&status=done&style=none&width=951" alt="image.png"><br />需要注意的是，<strong>单个词项iPod的查询结果结果了许多其他默认字段</strong>，从而组成了一条相当复杂的查询语句。eDisMax查询语句解析器可以将简单查询语句转化成复杂查询语句，它通过defaults元素下面的defType参数设置启用。eDisMax查询语句解析器将在第7章详细介绍。<br><a name="Vdwnw"></a></p>
<h3 id="添加拼写检查作为后处理组件"><a href="#添加拼写检查作为后处理组件" class="headerlink" title="添加拼写检查作为后处理组件"></a>添加拼写检查作为后处理组件</h3><p>在<strong>6个内置的搜索组件处理完搜索请求之后</strong>，**/browse搜索处理器将调用拼写检查组件<strong>，该组件被定义在 <code>&lt;last-component&gt;</code> 中。代码清单4.10展示了solrconfig.xml中对拼写检查组件的定义。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622907927357-6c2f80fb-4469-46d9-b48a-b1f6e0667863.png#height=320&id=oYXrY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=640&originWidth=2178&originalType=binary&ratio=1&size=641243&status=done&style=none&width=1089" alt="image.png"><br />请注意，</strong>拼写检查组件的名称与/browse请求处理器中的 <strong><code>**&lt;last-components&gt;**</code></strong> 组件的名称要保持一致**。因为要想完全理解代码清单4.10中的内容，需要具备一些Solr中检查处理的背景知识，所以配置元素在第10章中会继续讨论。<br />学习到这里，你应该对Solr如何处理查询请求有了深入了解。在进入下一个配置主题之前，你应该了解，在Solr管理控制台的 <code>Plugins/Stats</code> 页面的 <code>QUERYHANDLER</code> 选项中可以查看所有处于活跃状态的Solr搜索处理器。图4.9展示了/browse搜索处理器的属性和相关统计数据，其实这也是一个MBean。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622908146624-2c11404e-a1c8-4871-8f69-b2b64e718100.png#height=728&id=WfJLM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1456&originWidth=1994&originalType=binary&ratio=1&size=913981&status=done&style=none&width=997" alt="image.png"><br><a name="f2Q0i"></a></p>
<h2 id="管理搜索器"><a href="#管理搜索器" class="headerlink" title="管理搜索器"></a>管理搜索器</h2><p><strong><query>中包含一些查询性能优化的配置，这些配置主要利用缓存、字段延迟加载和新搜索器预热等技术</strong>。从<strong>一开始就考虑查询性能优化设计问题，这对搜索应用的成功而言非常重要</strong>。本节介绍搜索器的管理技术，这是查询优化中最重要的技术之一。<br><a name="MVfam"></a></p>
<h3 id="新建搜索器"><a href="#新建搜索器" class="headerlink" title="新建搜索器"></a>新建搜索器</h3><p>Solr的所<strong>有查询语句都由一个叫搜索器的组件处理</strong>。在Solr中，<strong>任何时候只能存在一个”处于活跃状态的”搜索器</strong>。所有搜索请求处理器中的查询组件都向这个处于活跃状态的搜索器发起查询请求。<br /><strong>处于活跃状态的搜索器拥有底层Lucene索引快照的只读视图</strong>。这意味着，<strong>如果现在将一份文档添加到Solr中，它在当前搜索器的搜索结果中是不可见的</strong>。这就引出一个问题：新添加的文档如何才能出现在搜索结果中？答案是关闭当前的搜索器，打开一个新的搜索器，这个搜索器添加了索引更新以后的只读视图。Solr中的提交操作比这里描述的要复杂得多，相关的内容将在下一章进一步讨论。现阶段，将提交操作看成一个黑箱操作即可，该操作可以开启一个新的搜索器，向Solr中添加新文档，更新已有索引，让添加的内容在搜索结果中可见。<br />图4.10展示了示例服务器中collection1的处于活跃状态的搜索器MBean，点击Plugins/Stats页中的Core一栏进行查看。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622984117808-8f279469-0f1d-4fb6-8441-3a8d281ddef7.png#height=686&id=wLuYH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1372&originWidth=1936&originalType=binary&ratio=1&size=1052682&status=done&style=none&width=968" alt="image.png"><br />从Core页，注意searcherName属性的值(在图中为Search@25082661main)。通过向服务器重新发送所有示例文档来创建一个新的搜索器，命令如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd $SOLR_INSTALL/example/exampledocs</span><br><span class="line">java -jar post.jar *.xml</span><br></pre></td></tr></table></figure>
<p>现在，刷新Core页，注意观察searcherName属性值，它已经变成了另一个搜索器实例。此处一个新的搜索器被创建出来，是因为<strong>post.jar命令在添加文档之后提交了一个commit提交请求</strong>。<br /><strong>提交操作会创建新的搜索器，以确保更新后的文档和索引可以被搜索器检索到</strong>。首先，旧的搜索器必须被销毁，但旧的搜索器上可能存在大量查询请求，所以，Solr要等到所有正在进行的请求都被旧搜索器处理完之后才会执行销毁操作。<br />同时，所有基于当前搜索器中的索引视图的缓存对象都将失效。因为该缓存中的部分文档可能已经被删除，同时可能添加了新的文档，所以很明显该结果集的缓存不再适用于新搜索器。<br />因为之前计算的数据(如上文中的缓存查询结果集)必定是无效的，需要重新计算，所以基于索引开启一个新搜索器实际上是一个非常耗费资源的操作，这可能对用户体验造成影响。想象一下，一个用户正在分页浏览搜索结果，一个新搜索器在他点击第二页之后、第三页之前开启了。当用户请求下一页的时候，所有之前计算的过滤条件和缓存文档都失效了，需要重新计算。这时如果处理不当，用户会感到明显的延迟，特别是他们的查询请求比较复杂的情况下。<br />所幸的是，Solr有许多工具可以帮助处理这个问题。最重要的是，Solr支持预热理念，即在后台预热新搜索器，同时保证当前搜索器的活跃状态，直到新搜索器预热完毕。<br><a name="LqjpL"></a></p>
<h3 id="新搜索器预热"><a href="#新搜索器预热" class="headerlink" title="新搜索器预热"></a>新搜索器预热</h3><p>Solr秉承一种理念，即允许应用在短时间内提供过期数据，但不允许应用的查询性能有大幅下降。也就是说，在<strong>新的搜索器预热完成，并准备好处理查询请求前，Solr不会关闭当前活跃的搜索器</strong>。<br />新搜索器的预热过程好比田径比赛中短跑选手们的热身过程。在选手们开跑之前，他们需要进行热身准备，以确保在指令枪响起后可以保持良好的全速状态。同样地，Solr也需要对新搜索器进行预热。<br />一般而言，Solr有两种预热机制：一种是<strong>利用旧缓存自动预热新缓存</strong>，另一种是执行<strong>缓存预热查询</strong>。<br /><strong>缓存预热查询</strong>就是<strong>向搜索器提交一段预先在solrconfig.xml文件中配置好的查询语句，目的是让搜索器将需要缓存的查询结果载入它的缓存中</strong>。代码清单4.11展示了示例服务器中缓存预热查询的配置。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622985239397-7310ce94-de50-410c-aae8-3e0e4b2508bc.png#height=305&id=eWiJH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=610&originWidth=2324&originalType=binary&ratio=1&size=698093&status=done&style=none&width=1162" alt="image.png"><br />代码清单4.11在配置文件中定义了一个查询语句列表(<arr name="queries">)，<strong>一旦Solr中有commit等newSearcher事件发生时，这些查询语句就会被执行</strong>。同时，注意代码清单4.11中注释掉的部分，这是有意注释的，已提醒开发者<strong>执行预热查询会消耗一定的系统资源，开发者需要根据应用程序来配置自己的预热查询语句</strong>。正因为配置与具体应用程序有关，所以代码清单4.11仅是举例，开发者需要根据需求自行配置预热查询。<br><a name="7xjlf"></a></p>
<h4 id="选择预热查询语句"><a href="#选择预热查询语句" class="headerlink" title="选择预热查询语句"></a>选择预热查询语句</h4><p>只是识别出能够提交查询性能的查询语句时，搜索器的预热才能真正的发挥作用。一般而言，预热查询语句应当包含应用程序中最频繁的查询请求参数(q、fq、sort等)。由于本章没有介绍Solr的查询语法，所以预热查询内容将在第7章中继续讲解，包括如何构造预热查询语句。现阶段，在脑海中留下简单印象即可，对Solr查询构造有了更深的理解之后再回到当前主题。<br />应当指出的是，应用程序并不一定都需要有预热查询语句。如果<strong>在提交操作之后查询性能出现明显下降，才有必要考虑使用预热查询语句</strong>。<br><a name="34aFo"></a></p>
<h4 id="太多预热查询会降低性能"><a href="#太多预热查询会降低性能" class="headerlink" title="太多预热查询会降低性能"></a>太多预热查询会降低性能</h4><p>俗话说”less is more”，对于预热查询来说也是如此。<strong>每一条查询语句的执行都要花费一定的时间，所以配置过多的预热查询将在开启新搜索器时导致较长的延迟。所以最佳做法是将预热查询数量尽可能降到最少，只包含应用程序中最重要的查询语句</strong>。<br />你可能会有这样的疑问，新搜索器花费较长的时间预热会带来怎样的问题？实际上，**应用程序中如果并发预热太多的搜索器会严重的消耗系统资源(CPU和内存)**，严重影响搜索体验。<br><a name="hSfPV"></a></p>
<h4 id="第一个搜索器"><a href="#第一个搜索器" class="headerlink" title="第一个搜索器"></a>第一个搜索器</h4><p>在Solr初始化过程中或重新加载完一个内核之后，预热第一个搜索器。是否为第一个搜索器配置预热查询语句，这完全由开发者自己决定。大多数的Solr开发者使用完全相同的查询语句来预热搜索器和第一个搜索器。在介绍Solr的缓存管理之前，我们简单介绍两个在solrconfig.xml文件中与搜索器相关的配置元素： <code>&lt;useColdSearcher&gt;</code> 和 <code>&lt;maxWarmingSearchers&gt;</code> 。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622986034743-a9225910-5021-4b19-a897-7e97bb75eef8.png#height=267&id=Dp2Uv&margin=%5Bobject%20Object%5D&name=image.png&originHeight=534&originWidth=1926&originalType=binary&ratio=1&size=1103463&status=done&style=none&width=963" alt="image.png"><br><a name="9E1AC"></a></p>
<h4 id="useColdSearcher"><a href="#useColdSearcher" class="headerlink" title="useColdSearcher"></a>useColdSearcher</h4><p><userColdSearcher>适用于一个搜索请求已经被提交，而目前Solr中没有定义搜索器的情形。如果**<userColdSearcher>的值为false，那么Solr将会一直处于阻塞状态，直到正在预热的搜索器执行完所有的预热查询<strong>。示例Solr服务器中的默认配置为<userColdSearcher>false</userColdSearcher>。<br />如果</strong><userColdSearcher>设为true，则Solr会立即使一个正在预热的搜索器进入活跃状态，而不管搜索的预热程度如何<strong>。还用之前的田径赛场为例：</strong>false意味着指令官等到运动员充分热身之后才发出开始指令，不论需要等待多久；true则意味着比赛马上就要开始了，不论运动员是否已经充分热身**。<br><a name="EuaAL"></a></p>
<h4 id="maxWarmingSearchers"><a href="#maxWarmingSearchers" class="headerlink" title="maxWarmingSearchers"></a>maxWarmingSearchers</h4><p>可以想象，如果在一个新搜索器预热完成之前又接到了新的提交请求，这就意味着在当前的新搜索器预热完成之前，另一个搜索器的预热又开始了。如果搜索器的预热时间很长，那么上述情形就会频繁发生。**<maxWarmingSearchers>元素允许开发者控制后台并发预热的搜索器的最大数目。一旦达到阈值，新的提交请求将会失败<strong>。这是一种很好的保障机制，因为后台并发预热的搜索器过多时会跨苏耗尽服务器的内存和CPU资源。</strong>Solr中该元素默认值为2**。<br />当然，如果发现服务器经常达到阈值，那就需要重新思考预热机制的设计逻辑，看看新搜索器的预热时间是否过长。<br />读到这里，你应该对搜索器是什么，以及如何配置Solr来正确管理应用中的搜索求有一定的理解了。下面将介绍利用缓存对查询性能进行优化的方法。<br><a name="iORqX"></a></p>
<h2 id="缓存管理"><a href="#缓存管理" class="headerlink" title="缓存管理"></a>缓存管理</h2><p>Solr提供了一系列的内置缓存来优化查询性能。在介绍某种缓存的具体细节之前，这里先介绍一下Solr的缓存原理。<br><a name="DB4Vq"></a></p>
<h3 id="缓存原理"><a href="#缓存原理" class="headerlink" title="缓存原理"></a>缓存原理</h3><p>Solr的缓存原理主要涉及一下4个方面：</p>
<ul>
<li>缓存大小及缓存置换法</li>
<li>缓存命中率与缓存回收</li>
<li>缓存对象失效</li>
<li>自动预热新缓存</li>
</ul>
<p>一般来说，合理的缓存管理方式不是设置完以后便将其抛至一旁，而是要时时关注缓存的使用状况，基于实际使用情况来进行调整。记住，要善于利用Solr的管理控制台来调试缓存、搜索器等重要组件。<br><a name="fAL0e"></a></p>
<h4 id="缓存大小"><a href="#缓存大小" class="headerlink" title="缓存大小"></a>缓存大小</h4><p>从缓存大小的角度来看，不能将缓存设置得太大，否则它会消耗JVM中的所有内存。Solr能够将所有缓存的对象都保存在内存中，不会溢出到硬盘上，而这种情况在其他缓存管理框架中有可能会发生。<strong>为了控制缓存大小，Solr要求为每一个缓存都设置一个缓存对象的数量上限</strong>。当达到上限时，Solr将采用<strong>最久未使用(Least Recently Used，LRU)<strong>置换法或者</strong>最近最少使用(Least Frequently Used, LFU)<strong>置换法回收一部分缓存空间。<br /><strong>最久未使用置换法LRU</strong>在缓存大小达到阈值上限时，</strong>根据缓存对象最后一次被请求的时间决定缓存对象被回收的次序</strong>。当缓存区已达上限，需要添加新的对象时，LRU置换法将置换缓存中最’老’的对象，即最久未被请求过的对象。<strong>LRU置换法是Solr的默认缓存置换算法</strong>。<br /><strong>最近最少使用置换法LFU</strong>，<strong>根据缓存对象被请求频率的高低决定缓存对象被回收的次序</strong>。<strong>这种置换法给予缓存中被调用频率高的对象更高的优先级。而不是最近被请求的对象</strong>。Solr的过滤器缓存是使用LFU置换法的一个好例子，因为过滤查询的创建和存储是很耗费资源的，所以需要尽量降低过滤器缓存的存储大小，并且给予应用中频繁被调用的过滤器更高的优先级。<br />关于缓存大小的一个常见的误区是，如果有比较大的内存空间，就应该将缓存空间也设置的比较大才行。这样做存在的问题是，一旦某个缓存在一次提交操作之后失效了，JVM就需要做大量的垃圾回收工作。记住，<strong>关闭一个搜索器会使得该搜索器缓存的所有对象都失效</strong>。<strong>如果没有根据垃圾回收的实际情况对缓存大小进行合适的调整，就可能导致服务器因垃圾回收而长时间暂停服务</strong>。<br><a name="vUCLa"></a></p>
<h4 id="缓存命中率与缓存回收"><a href="#缓存命中率与缓存回收" class="headerlink" title="缓存命中率与缓存回收"></a>缓存命中率与缓存回收</h4><p><strong>缓存命中率是指应用程序的缓存命中的用户请求数量占所有用户请求数量的比例</strong>。<strong>缓存命中率表明了缓存对应用程序的性能优化所起到的作用</strong>。理想状态下，开发者都希望应用的缓存命中率尽量接近1(100%)。低缓存命中率表明缓存对Solr的性能优化没有起到作用。<br /><strong>缓存回收数表明有多少缓存对象根据上文介绍的缓存置换法被回收了</strong>。<strong>如果缓存回收量很大，则表明应用程序的缓存对象数量的最大值可能设置的太小</strong>。缓存回收数和缓存命中率是紧密相关的，高的缓存回收数往往导致一个较好的缓存命中率。<br><a name="dI4XN"></a></p>
<h4 id="缓存对象失效"><a href="#缓存对象失效" class="headerlink" title="缓存对象失效"></a>缓存对象失效</h4><p>在大多数的缓存管理场景中，开发者需要考虑如何使一个缓存对象失效，这样应用程序才不会返回过时的数据。在Solr中不再需要为这点担心，<strong>因为所有缓存中的对象都会链接到对应的搜索器实例，并且在搜索器关闭后立即失效</strong>。上文已经介绍过，搜索器只是Lucene索引快照的一个只读视图，因此，所有的缓存对象在搜索器关闭之前都是有效的。<br><a name="9Bjkp"></a></p>
<h4 id="自动预热新的缓存"><a href="#自动预热新的缓存" class="headerlink" title="自动预热新的缓存"></a>自动预热新的缓存</h4><p>我们之前讨论过，Solr在每次提交请求之后都会创建一个新搜索器，并且直到新搜索器完成预热，才会关闭旧搜索器。<strong>Solr利用即将被关闭的旧搜索器中的部分缓存内容构建新搜索器的缓存，这个过程称之为自动预热</strong>。请注意，<strong>自动预热新的缓存和使用预热查询预热新的缓存是两个不同的概念</strong>。<br />每一个Solr的缓存都支持 <code>**autowarmCount**</code> 属性，这个属性<strong>表示自动预热的旧缓存对象的最大数目或百分比</strong>。<strong>缓存对象自动预热策略取决于缓存的具体类型</strong>。本章接下来介绍不同类型缓存的自动预热策略。现阶段的重点是学会Solr缓存的配置，当开启一个新搜索器时刷新部分缓存对象。<br />学到这里，你应该对Solr中缓存管理的概念有了基本的理解。本章接下来将会介绍Solr中实现查询性能优化的一些具体的缓存类型，先从最重要的一种缓存开始。<br><a name="4YJmF"></a></p>
<h3 id="过滤器缓存"><a href="#过滤器缓存" class="headerlink" title="过滤器缓存"></a>过滤器缓存</h3><p>在Solr中，过滤器将搜索结果限制在符合过滤条件的文档集中，但是它并不影响文档的评分。我们之前讨论过的一个查询示例使用了过滤器查询，利用 <code>fq=manu:Belkin</code> 过滤出制造商(manu)字段值为Belkin的文档，如代码清单4.12所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623154545055-30f17f4a-52b2-4839-b8db-90ca8b107ac3.png#height=289&id=Y6dCG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=578&originWidth=2008&originalType=binary&ratio=1&size=430721&status=done&style=none&width=1004" alt="image.png"><br />当Solr执行代码清单4.12中的查询语句时，它会计算并缓存一个合适的数据结构，找到索引中符合过滤条件的文档。在示例服务器中，有两篇文档符合该过滤条件。<br />假设有一个过滤条件相同(fq=manu:Belkin)但查询内容不同的查询请求，例如q=USB，如果应用程序在处理该查询请求时可以利用胆码清单4.12中的查询结果，那么查询效率会得到大幅提高，这正是Solr过滤器缓存设计的初衷。下面举例说明Solr的过滤器缓存。在浏览器打开collection1的Query页面，提交查询请求。<br />接下来，打开collection1的Plugin/Stats页面，点击CACHE链接，图4.12展示了过滤器缓存的MBean的属性和统计信息。多次重复执行相同查询，会看到过滤器缓存的统计信息在变化。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623204074007-5fe2f9a4-bb6d-4571-9bfd-36d34048adce.png#height=605&id=r5TvG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1210&originWidth=850&originalType=binary&ratio=1&size=616951&status=done&style=none&width=425" alt="image.png"><br />通过一个很小的索引很难体会到过滤器缓存的价值，但是假如你有一份百万数量级别文档的索引，这时就能体会到过滤器缓存带来的查询性能优化。实际上，<strong>使用过滤器进行查询优化是Solr的一大亮点，主要是因为过滤器在不同查询语句之间可以被复用</strong>。第7章将进一步介绍Solr的过滤器查询，而本章主要介绍solrconfig.xml文件中过滤器缓存的配置。代码清单4.13展示了过滤器缓存的默认配置。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623204224142-531bf5a7-3a3c-4eba-ac0a-71fdb11ddb3f.png#height=597&id=lfjW9&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1194&originWidth=1232&originalType=binary&ratio=1&size=1131435&status=done&style=none&width=616" alt="image.png"><br><a name="r5WDR"></a></p>
<h4 id="自动预热过滤器缓存"><a href="#自动预热过滤器缓存" class="headerlink" title="自动预热过滤器缓存"></a>自动预热过滤器缓存</h4><p>过滤器查询是优化查询语句的强大工具，但是如果开发者对过滤器缓存管理不当，则会陷入麻烦之中。<strong>如果索引中索引了大量的文档或者过滤条件非常复杂，那么创建和存储过滤器将耗费大量的系统资源</strong>。<strong>如果一个简单的过滤查询能够被复用于多条查询语句，那么这个过滤查询的缓存便是有意义的</strong>。除此之外，你可能还会想到在开启新搜索器时预热一些过滤缓存。<br />下面让我们深入到过滤器缓存的内部来看一看缓存对象的自动预热过程。读到这里，你应该理解了缓存对象并不能轻易地从旧缓存转移到新缓存中，<strong>因为底层的索引发生了改变，这会使得过滤器之类的缓存对象失效</strong>。<strong>缓存中的每一个对象都有一个键</strong>，<strong>对于过滤器缓存来说，这个键就是过滤查询语句</strong>，例如 <code>manu:Belkin</code> 。<strong>预热新的缓存时，一部分键从旧的缓存中抽取出来，向新搜索器提交查询，形成新的过滤器</strong>。<strong>要利用新搜索器自动预热过滤器缓存，就需要Solr重新执行过滤查询</strong>。<strong>因此</strong>，<strong>自动预热过滤器缓存可能导致Solr在性能和资源利用方面出现问题</strong>。<br />假设应用程序的 <code>autowarmCount</code> 值设为100，设置了数百个过滤缓存。当预热新搜索器时，Solr必须执行100条过滤器查询语句。假设执行100条过滤查询语句耗时65秒，同时应用程序每分钟都在提交更改。在这种情况下，应用程序很快就会出现问题，因为后台并发预热的搜索器太多了。<br /><strong>建议开发者为过滤器缓存启用自动预热功能，但是给 <strong><code>**autowarmCount**</code></strong> 设一个较小值作为初始值</strong>。除此之外，<strong>LFU置换法更适合过滤器缓存，因为它能保证被请求频率高的过滤器被赋予较高优先级，同时降低过滤器缓存的大小</strong>。下面是推荐的过滤器缓存配置：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623205025833-a1d37243-328b-4430-aa42-089910f613c7.png#height=123&id=sYx1a&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=1090&originalType=binary&ratio=1&size=194263&status=done&style=none&width=545" alt="image.png"><br />开发者需要在此配置基础上，根据应用程序实际使用的过滤器数量对索引提交更新的频率进行试验，已得到最佳配置。<br /><strong>从每个过滤器缓存的内存使用情况来看，根据匹配文档集合的大小，Solr有不同的过滤表示方法。至于最大阈值，可以设定为每个过滤匹配文档集合中的MaxDoc(最大文档数目)值</strong>。例如，如果索引文件索引了1000万份文档，那么一个过滤器最高可能占用一千万比特的内存，即1.2MB左右。<br><a name="nAJqB"></a></p>
<h3 id="查询结果缓存"><a href="#查询结果缓存" class="headerlink" title="查询结果缓存"></a>查询结果缓存</h3><p><strong>查询结果缓存会将查询请求的结果集保存在缓存中</strong>。如果多次执行代码清单4.12中的查询语句，实际上后面几次的查询结果都是第一次查询结果的缓存，而不是重新对Lucene索引执行查询。<strong>对于需要消耗大量计算资源的查询来说，这是一种非常高效的解决方案</strong>。查询结果缓存的定义如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">queryResultCache</span> <span class="attr">class</span>=<span class="string">&quot;solr.LRUCache&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">size</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">initialSize</span>=<span class="string">&quot;512&quot;</span></span></span><br><span class="line"><span class="tag">                  <span class="attr">autowarmCount</span>=<span class="string">&quot;0&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>该方案背后的原理是将查询语句作为键，内部Lucene文档ID作为值，存储在查询结果缓存中</strong>。<strong>内部Lucene文档ID会随着搜索器的改变而改变</strong>，<strong>所以在预热查询结果缓存时</strong>，<strong>缓存的内部Lucene文档ID需要重新计算</strong>。<br /><strong>为了预热查询结果缓存，Solr需要重新执行查询语句，这可能消耗大量的资源</strong>。同过滤器缓存一样，<strong>我们建议将 <strong><code>**autowarmCount**</code></strong> 的值设为一个较小值</strong>。也就是说，建议将 <code>autowarmCount</code> 的值设为默认值0以外的某个较小值，这样可以通过自动预热最近的查询语句提高应用程序的性能。<br />除缓存大小之外，Solr还提供各种其他配置选项以调整查询结果缓存的使用。<br><a name="2Oj5U"></a></p>
<h4 id="查询结果窗口大小"><a href="#查询结果窗口大小" class="headerlink" title="查询结果窗口大小"></a>查询结果窗口大小</h4><p>显而易见，分页对于提高Solr的查询性能是非常重要的。 <code>**&lt;queryResultWindowSize&gt;**</code>** 允许在执行查询请求时定义单词返回查询结果的页数<strong>。<br />假设应用程序每页展示10份文档，并且在大多数情况下，用户都只浏览第一页和第二页。那么可以将<queryResultWindowSize>的值设为20，这样可以避免用户查看第二页时再次执行查询请求。一</strong>般情况下，我们会将会这个元素的值设为每页查询结果数量的两到三倍。如果将这个值设置的过大，那么每一次查询都要加载多于用户请求数量的文档，这样就产生了额外的代价**。如果用户很少查看第一页以外的内容，那么最好将该元素的值设为单页查询结果的数量。开发者可以通过查看Solr日志文件中start参数的值是否大于0来决定该元素的值。<br><a name="ieJbU"></a></p>
<h4 id="查询结果缓存的最大文档数"><a href="#查询结果缓存的最大文档数" class="headerlink" title="查询结果缓存的最大文档数"></a>查询结果缓存的最大文档数</h4><p>我们之前讨论过，必须为Solr的缓存大小设置最大值，但是这并不影响每个缓存对象在缓存中的大小。可以预见，一个包含一组百万级别文档集的缓存对象肯定会影响Solr的可用内容。 <code>**&lt;queryResultMaxDocsCached&gt;**</code>** 元素允许对查询结果缓存中每个缓存对象包含的文档数目做出限制<strong>。在大多数搜索应用中，</strong>用户一般仅查看前几页的搜索结果，所以可以将这个值设为每页结果文档数目的两倍或三倍大小**。<br><a name="pEQBD"></a></p>
<h4 id="启用字段延迟加载"><a href="#启用字段延迟加载" class="headerlink" title="启用字段延迟加载"></a>启用字段延迟加载</h4><p>Solr中一种常见的设计模式是只返回用户查询请求中要求的字段，而不是返回文档的所有字段，例如，代码清单4.12的示例查询语句请求了name、price、features和score字段，但是索引中的文档还有很多其他字段，如category、popularity、manufacturedate等。如果应用程序要采用这种设计模式，需要<strong>将<enableLazyFieldLoading>元素等值设为true，这样可以避免加载用户不需要的字段</strong>。在实际应用中，只返回用户需要的字段是一种高效的设计模式。<br><a name="ecGLm"></a></p>
<h4 id="文档缓存"><a href="#文档缓存" class="headerlink" title="文档缓存"></a>文档缓存</h4><p>因为<strong>查询结果缓存仅仅缓存了一组符合查询条件的文档的内部ID</strong>，所以即使查询结果被缓存了，<strong>Solr仍然需要从硬盘中加载文档内容</strong>。<strong>文档缓存以文档的内部ID为键，将硬盘中的文档内容加载到缓存中</strong>。这样，查询缓存结果可以从文档缓存中调用需要的文档内容。<br />这就出现一个问题，即预热文档缓存是否有必要。一个很好的反面理由是，无法确定被预热的文档与来自查询结果和过滤器缓存的自动预热查询和过滤器存在什么关系。如果更新索引的频率很高，每个查询返回的结果的文档也经常变化，则配置文档缓存就可能把资源耗费在了对应用程序性能无益的地方。但另一方面，如果索引更新频率很低，那么文档缓存可能有助于提高应用程序的性能。<br><a name="ZaMMZ"></a></p>
<h4 id="字段值缓存"><a href="#字段值缓存" class="headerlink" title="字段值缓存"></a>字段值缓存</h4><p>字段值缓存主要受Lucene控制，而不是由Solr来管理。<strong>字段值缓存提供了通过内部文档ID快速访问存储的字段值的途径，主要在排序和从匹配文档中生成响应内容时使用</strong>。详细可参阅Lucene JavaDoc(org.apache.lucene.search.FieldCache)来获取更多信息。<br />学到这里，你应该了解了Solr处理客户端查询请求的过程，并且了解了如何利用预热新搜索器和缓存来提高应用程序的查询性能。<br><a name="NLxJG"></a></p>
<h3 id="其他配置选项"><a href="#其他配置选项" class="headerlink" title="其他配置选项"></a>其他配置选项</h3><p>截止目前，本章已经介绍了solrconfig.xml文件中最常见的配置，但是Solr还有很多其他特性。Solr拥有许多专家级的配置，这些配置内容并不在本书的介绍范围之内。Solr的示例配置文件solrconfig.xml对开发者来说很友好，因为文件中详细介绍了每项配置所控制的内容和配置方法。<strong>建议开发者多花一些时间好好研究该文件，学习更多的提高Solr性能优化方法和更多未启用的新特性</strong>。<br />因为solrconfig.xml是启用新特性必不可少的文件，所以本书后面还会讲到它。在本书的余下部分，你会看到如何在solrconfig.xml文件中启用Solr的新特性，如何设置相应数据的格式，如何定义新搜索器，如何自定义搜索组件，如何配置Solr的生产环境，以及其他与性能优化相关的内容。总之，Solr的配置还远远没有介绍完，但我们需要知道在初次配置和运行Solr时，哪些配置选项是可用的，以及哪些选项是重要的。<br><a name="ohUvq"></a></p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>通过学习本章，你应该对Solr的配置有了深刻的理解，尤其是Solr应用程序的查询处理优化。具体来说，你应该了解了<strong>Solr的查询处理管道</strong>，<strong>该管道由一个统一请求分配器和一个可灵活配置的请求处理器组成</strong>。<strong>搜索处理器分为四个组件</strong>，每个组件都可以由开发者自定义。Solritas应用程序中的/browse请求处理器是一个使用默认配置参数和自定义组件(如spellcheck)的典型示例，该示例在为用户提供丰富搜索体验的同时，还保证了客户端代码的简洁。<br />另外，本章还介绍了Solritas应用程序利用搜索器处理查询请求的原理，其中，<strong>搜索器基于Lucene索引视图</strong>。任一时刻，Solr中都只能存在一个处于活跃状态的搜索器，并且对Lucene索引的任何更新都需要在开启新的搜索器之后才能得到应用。但无论是关闭当前搜索器，还是开启新的搜索器都需要消耗大量的系统资源，影响到Solr应用程序的查询性能。为了使开启新的搜索器对查询性能的影响降到最低，Solr允许配置静态的查询语句，利用这些查询语句在后台预热新的搜索器。对新搜索器的预热过程进行合理管理是Solr应用程序中最重要的配置任务之一。Solr的其他生产环境中的配置将在第12章中介绍。<br />另外，Solr提供了一系列重要的缓存，这些缓存需要根据应用程序的实际需求做适当的配置。本章重点介绍了过滤缓存、查询结果缓存、文档缓存和字段值缓存。对于没一种缓存，都需要根据应用程序的实际运行状况设定缓存大小的阈值，以及缓存对象的置换法。通过Solr内置的管理控制台，可以查看一些应用程序的关键统计信息，如缓存命中率等，这些统计信息可以帮助开发者设置合理的缓存大小。<br />当创建新搜索器时，为了优化应用程序的查询性能，可以预热缓存。例如，可以对被请求频率最高的过滤查询使用Solr中过滤器花奴才能的自动预热功能。尽管缓存的自动预热功能很强大，但是也会导致新搜索器预热的延迟。建议将autowarmCountsh的初始值设为较小值，并且密切监视搜索器的预热时间。第12章将进一步介绍Solr中缓存的调整。<br />尽管本章中介绍的Solr配置选项基本覆盖了一般情况下的需求，但是本章并没有将Solr配置的所所有内容都覆盖到。本章的目的只是想让读者熟悉Solr的配置，以及这些配置背后的原理，至于大量额外的配置选项及性能优化方案，将在本书的余下章节结合Solr的相应特性再做介绍。<br />正如本章一开始时所声明的那样，solrconfig.xml文件中索引相关的配置将在读者理解了Solr的索引原理后再做介绍，详见下一章。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Solr手册-第五章 Solr索引
          
        </div>
      </a>
    
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Solr手册-第三章 Solr基础理论</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="J`Han&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HomePage</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Document</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Solr/">Solr</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>如果觉得对您有帮助，来个打赏吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>