<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Solr手册-第三章 Solr基础理论 |  J`Han&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Solr手册-第三章-Solr基础理论"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Solr手册-第三章 Solr基础理论
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" class="article-date">
  <time datetime="2021-10-31T02:16:31.000Z" itemprop="datePublished">2021-10-31</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">12k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">42 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。<span id="more"></span><br><a name="N3pon"></a></p>
<h1 id="Chapter-Three-Solr基础理论"><a href="#Chapter-Three-Solr基础理论" class="headerlink" title="Chapter Three Solr基础理论"></a>Chapter Three Solr基础理论</h1><p>本章内容对于大多数搜索引擎均适用但我们主要关注信息检索理论在Solr中的时间。本章将告诉你：</p>
<ul>
<li>Solr索引原理；</li>
<li>复杂布尔查询与模糊查询的执行；</li>
<li>默认相关度的评分模型；</li>
<li>如何让Solr在多服务器上处理数十亿文档的同时，仍能保持查询速度的架构特征。</li>
</ul>
<p>首先，讨论Solr搜索背后的核心概念，包括搜索引擎是怎么样工作的，搜素哦引擎如何对查询与文档进行匹配，Solr如何通过强大的查询能力去找寻内容。<br><a name="od21P"></a></p>
<h2 id="搜索、匹配与查询内容"><a href="#搜索、匹配与查询内容" class="headerlink" title="搜索、匹配与查询内容"></a>搜索、匹配与查询内容</h2><p>现有的许多不同类型的技术系统，如关系型数据库、键值存储、操作磁盘文件的map-reduce(映射-规约)引擎、图数据库等，都是为了帮助用户解决颇具挑战性的数据存储与检索问题而出现的。而所搜引擎，尤其是Solr，致力于解决一类特定的问题：<strong>搜索大量非结构化文本，并返回最相关的搜索结果</strong>。<br />本节介绍现代搜索引擎的核心功能，解释什么是搜索的文档，概述倒排搜索(Solr快速全文搜索能力的核心)以及如何支持各种复杂词项查询、短语查询和部分匹配查询。<br><a name="PQqVA"></a></p>
<h3 id="什么是文档"><a href="#什么是文档" class="headerlink" title="什么是文档"></a>什么是文档</h3><p>Solr是一个文档存储与检索引擎。提交给Solr处理的每一分数据都是一个文档。文档可以是一篇新闻报道、一份简历、社交用户信息，甚至是一整本书。<br />每个文档包含一个或多个字段，每个字段被赋予具体的字段类型：字符串、标记化文本、布尔值、日期/时间、经纬度等。潜在的字段类型数量是无限的，因为一个字段类型是由若干分析步骤组成的，这些步骤会决定数据如何在字段中被处理，以及如何映射到Solr索引中。每个字段在Solr的schema中被定义为特定的字段类型，被告知Solr接收到此类内容的处理方法。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621758894125-1e5fcca1-fdcf-4a2b-97fc-60e22d70832c.png#height=228&id=ew5J4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=456&originWidth=1762&originalType=binary&ratio=1&size=369537&status=done&style=none&width=881" alt="image.png"><br />要在Solr上执行一个查询，我们可以在文档上搜索一个或多个字段，即时字段未包含在该文档中。Solr将返回那些包含了与<strong>查询匹配的字段内容的文档</strong>。<br />值得注意的是，虽然Solr为每个文档提供了一个灵活的schema，但灵活不代表无模式(schema-less)。在Solr的schema.xml中，<strong>所有的字段类型必须被定义</strong>，所有的字段名称(包括动态字段命名模式)必须被指定。<strong>这并不意味着，每个文档必须包含所有字段</strong>，仅当所有可能的字段出现在同一个文档中需要处理时，才会被全部映射到特定字段类型中。当首次接收到包含新字段的文档时，Solr会自动猜测位置的新字段类型。通过检查字段中的数据类型，自动将字段增加到Solr的schema中。如果输入的数据难以理解，Solr可能会对新字段类型识别失败，因此，更好的做法是<strong>预先定义好字段</strong>。<br />一个文档通过定义schema，映射为特定字段类型的字段集合，文档的每个字段根据其字段类型进行内容分析，分析的结果保存在索引中，这样在发起查询的时就能检索到相关结果。Solr查询返回的主要搜索结果是由一个或多个字段组成的文档集。<br><a name="L5CgM"></a></p>
<h3 id="基本搜索问题"><a href="#基本搜索问题" class="headerlink" title="基本搜索问题"></a>基本搜索问题</h3><p>假如，有一项任务是为读者开发图书搜索功能。假设读者想购置新房，输入 <code>buying a house</code> 查询相关图书，找到的可能相关的书名列表如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621759674667-924deef8-c90d-4d6c-a2d9-28246537e665.png#height=301&id=qFDrV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=602&originWidth=870&originalType=binary&ratio=1&size=207989&status=done&style=none&width=435" alt="image.png"><br />其他一些图书对于有购房打算的客户而言并不相关。书名列表如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621759727707-3a0e2095-e925-4d0b-9f40-9aa04ce6188f.png#height=191&id=qdbZE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=382&originWidth=928&originalType=binary&ratio=1&size=131544&status=done&style=none&width=464" alt="image.png"><br />传统的Sql数据库实现该查询的Sql语句方式如下，即匹配精确的文本：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> books <span class="keyword">where</span> name <span class="operator">=</span> <span class="string">&#x27;buying a new home&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>这种方式的问题在于，Sql查询会对用户输入进行精确匹配，如果找不到任何精确匹配的结果，则在图书目录显示找不到相关的书名。只有查询能够精确匹配到完整书名，用户才能看到相应结果。<br />另一种更为模糊的处理方式是搜索用户查询中的单个词。同时包含这三个词的书名就会被返回，Sql如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> form books </span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%buying%&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> </span><br><span class="line"><span class="keyword">and</span> name <span class="keyword">like</span> <span class="string">&#x27;%home%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>以上Sql查询没有利用现有的数据库索引，在传统数据库中的处理花销较高，但至少得到了一个包含所有查询词汇的匹配结果，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621760018178-f54efc97-d086-4db4-9dcf-6734ed09b308.png#height=373&id=EUdSE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=746&originWidth=1662&originalType=binary&ratio=1&size=369928&status=done&style=none&width=831" alt="image.png"><br />当然，你可能会觉得在查询中匹配用户输入的所有词这个要求仍然过于严格。让搜索体验变得更加灵活的一种简单方法是，只要一个词出现在书名即认为匹配成功，Sql查询语句如下：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> form books </span><br><span class="line"><span class="keyword">where</span> name <span class="keyword">like</span> <span class="string">&#x27;%buying%&#x27;</span> </span><br><span class="line"><span class="keyword">or</span> name <span class="keyword">like</span> <span class="string">&#x27;%a%&#x27;</span> </span><br><span class="line"><span class="keyword">or</span> name <span class="keyword">like</span> <span class="string">&#x27;%home%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>改查询结果如下图。与前一个查询相比，该查询匹配到更多的书名。这是因为查询仅仅要求匹配到一个关键词即可。另外，由于该查询对每个关键词仅做部分字符串匹配，任何包含字母a的书名也被返回了。先前的示例也匹配了字母a，但因为要求其他几个关键词同时存在，所有并没有出现返回大量结果的问题。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621760322123-d0b0f93a-6970-4867-9fec-27823d90941a.png#height=359&id=BTBdc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=718&originWidth=1614&originalType=binary&ratio=1&size=394681&status=done&style=none&width=807" alt="image.png"><br />第一个查询要求所有词都匹配到，这导致一些相关的图书未被找到；第二个查询要求匹配到一个词即可，这导致过多的图书被找到，同时也出现了许多不相关的图书。<br />以上示例说明了查询执行中存在的一些困难：</p>
<ul>
<li>仅执行子字符串匹配，不能区分出词；</li>
<li>不能理解语言变体，例如’buying’ 与 ‘buy’；</li>
<li>不能理解同义词，例如’buying’与’purchasing’、’home’与’house’；</li>
<li>类似于’a’这样不重要的词汇会影响到预期的搜索结果(相关结果被排除在外或不相关结果的出现，取决于这些词是要’全部’还是’任意’匹配)；</li>
<li>结果的相关度排序是无意义的，仅匹配到一个查询词的图书比匹配到多个查询词的图书排名更靠前。</li>
</ul>
<p>当书目数量越来越大且用户查询量不断增长时，这些查询执行起来会变得越来越慢。这是由于查询必须扫描所有的书名(例如：mysql的全模糊查询需要全文扫描)，以便找到部分匹配，而不是使用索引来查找词汇。<br />以Solr为代表的的搜索引擎在解决此类问题方面可以大展身手。Solr会对内容和查询进行文本分析，<strong>确定文本相似的词，理解并匹配同义词，移除’a’、’the’、’of’这类不重要的词</strong>，每个搜索结果的得分是基于它与查询词的匹配程度来计算的，以确保最佳结果排在前面，用户无须为找寻期望的内容而翻阅大量不想管的页面结果。Solr之所以能完成以上工作，是因为使用了索引将内容映射至文档的方式。这与传统数据库模型——文档映射至内容的方式不同。倒排索引是搜索引擎运作的核心。<br><a name="2WQ0O"></a></p>
<h3 id="倒排索引"><a href="#倒排索引" class="headerlink" title="倒排索引"></a>倒排索引</h3><p>Solr使用Lucene倒排索引来驱动快速搜索功能，并且在查询时提供了许多其他附加功能。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621768258560-eaee58ca-ba7c-49f0-94a0-d2591f8701da.png#height=571&id=vnoEV&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1142&originWidth=1782&originalType=binary&ratio=1&size=672221&status=done&style=none&width=891" alt="image.png"><br />在传统数据库中，多个文档的表征是一个文档ID对应一个或者多个内容字段，这些字段包含文档中出现的单词/词项。倒排索引将这个模型颠倒过来了，将语料库中的<strong>每个单词/词项与他们出现的文档对应起来</strong>。在表3.5中，在插入倒排索引之前，原始输入的文本会根据空格来进行拆分，每个词项会被转换成小写，其他部分保持不变。值得注意的是，实际中可能还需要很多其他的文本转换，不仅仅有这里提到的简单处理。在内容分析处理中词项可以被修改、添加或移除。<br />最后，应注意倒排索引的两个重要细节：</p>
<ul>
<li><p>倒排索引中的所有词项对应一个或多个文档；</p>
</li>
<li><p>倒排索引中的词项根据字典顺序升序排序。<br><a name="Ki1jn"></a></p>
<h3 id="词项、短语和布尔逻辑"><a href="#词项、短语和布尔逻辑" class="headerlink" title="词项、短语和布尔逻辑"></a>词项、短语和布尔逻辑</h3><p>上一小节提到，插入倒排索引时，内容字段的所有文本内容会被分解成单个的词项。现在有一个传入的查询，需要通过一些选项来查询该索引：</p>
</li>
<li><p>搜索两个不同的词项，<code>new</code>和<code>house</code>，要求两者都被匹配；</p>
</li>
<li><p>搜索两个不同的词项，<code>new</code>和<code>house</code>，要求匹配其一即可；</p>
</li>
<li><p>搜索短语<code>new house</code>,要求精确匹配。</p>
</li>
</ul>
<p>根据用例的实际情况，这几种选项都可能成为有效的方案。受益于Solr的强大查询功能和基于Lucene的索引构建，布尔逻辑查询很容易实现。<br><a name="ASY1y"></a></p>
<h4 id="必备词项"><a href="#必备词项" class="headerlink" title="必备词项"></a>必备词项</h4><p>先来看第一种选择，将查询分解成为多个词项，要求匹配所有词项。使用Solr的默认查询解析器编写该查询，有如下两种相似的方法：</p>
<ul>
<li>+new +house</li>
<li>new AND house</li>
</ul>
<p>这两种方法在逻辑上是相同的。事实上，第二个示例解析后可以约简到第一个示例形式。符号 <code>+</code> 是一元运算符，要求<strong>其后的查询部分必须出现在匹配到的文档中</strong>；关键词 <code>AND</code> 是二元操作符，要求<strong>其左右两端的查询词必须同时出现</strong>。<br><a name="DJCYT"></a></p>
<h4 id="可选词项"><a href="#可选词项" class="headerlink" title="可选词项"></a>可选词项</h4><p>与 <code>AND</code> 操作符相对，Solr还支持 <code>OR</code> 二元运算符，它要求<strong>左右两端的查询词至少有一个出现在匹配到的文档中</strong>。Solr默认配置查询词之间是OR运算，无需制定可选参数。以下两个查询是等价的：</p>
<ul>
<li><p>new house</p>
</li>
<li><p>new OR house<br><a name="tLCG1"></a></p>
<h4 id="排除词项"><a href="#排除词项" class="headerlink" title="排除词项"></a>排除词项</h4><p>除了查询词可选或必备以外，还有一种情况是要求词项不出现在匹配到的文档中。以下两个查询是等价的：</p>
</li>
<li><p>new house -rental</p>
</li>
<li><p>new house NOT rental</p>
</li>
</ul>
<p>这两条查询的意图是，在匹配new或house的查询文档中删除包含rental的文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Solr的默认运算符</span><br><span class="line">	Solr的默认配置是将词项或短语视为可选的，在单查询上可进行陪住，使用Url里面的q.op参数配置多种查询句柄。</span><br><span class="line">  /select/?q=new house&amp;q.op=OR &lt;=&gt; /select/?q=new house&amp;q.op=AND</span><br><span class="line">  	请注意，如果把默认运算符OR修改为AND，那么无须指定布尔运算就会要求匹配所有的词项。</span><br></pre></td></tr></table></figure>
<p><a name="SNl1X"></a></p>
<h3 id="短语"><a href="#短语" class="headerlink" title="短语"></a>短语</h3><p>Solr不仅支持单个词项搜索，还支持短语搜索，确保多个词项按特定的顺序出现：</p>
<ul>
<li><p>‘new home’ OR ‘new house’</p>
</li>
<li><p>‘3 bedrooms’ AND ‘walk in closet’ AND ‘granite countertops’<br><a name="0Kik6"></a></p>
<h3 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a>组合表达式</h3><p>之前介绍的都是查询表达式，最后一种是使用布尔逻辑对词项、短语和其他查询表达式进行组合构造。Solr查询语法使用括号组合词项的方式来构造任意复杂的查询表达式，具体如下：</p>
</li>
<li><p>New AND (house OR (home NOT improvement NOT depot NOT grown))</p>
</li>
<li><p>(+(buying purchasing -renting) +(home house residence -(+property -bedroom)))</p>
</li>
</ul>
<p>必备词项、可选词项、排除词项与组合表达式提供了强大且灵活的查询功能集，可以对索引进行各种复杂的查询操作。<br><a name="uFtOk"></a></p>
<h3 id="找到文档集"><a href="#找到文档集" class="headerlink" title="找到文档集"></a>找到文档集</h3><p>对词项、短语和布尔查询有了基本人手之后，我们现在来研究Solr如何使用Lucene内部倒排索引来查找匹配的文档。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621769911964-63567d15-1eee-4de8-8e9c-5f42ab97c48b.png#height=501&id=wiiiY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1002&originWidth=1688&originalType=binary&ratio=1&size=432675&status=done&style=none&width=844" alt="image.png"><br />一旦形成每个词项的匹配文档列表之后，Lucene就会执行集合操作，得到与该查询匹配的适合的结果集。假设默认的运算符是OR，那么查询的结果就是两个查询词结果的并集。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621770086741-2273a89f-565c-4b2b-9aa5-0d81352d9884.png#height=264&id=tDs9n&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=872&originalType=binary&ratio=1&size=312447&status=done&style=none&width=436" alt="image.png"><br />同样的，如果查询为new AND home 或默认的运算符设为AND，则查询结果为两个词项查询的交集。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621770130699-b383435a-0b87-4311-a925-67211599fb0e.png#height=266&id=BPLsJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=532&originWidth=970&originalType=binary&ratio=1&size=219698&status=done&style=none&width=485" alt="image.png"><br /><br><br />除了交集与并集查询，排除特定词项也很常见，如下图所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621770190081-bd1a9041-ebb8-474a-98b5-6c2bf75e85f9.png#height=735&id=S0PcK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1470&originWidth=1412&originalType=binary&ratio=1&size=763508&status=done&style=none&width=706" alt="image.png">综上所述，必备词项、可选词项、排除词项和组合表达式的搜索功能为单关键词的查询提供了强有力的支持。<br><a name="dAkT7"></a></p>
<h3 id="短语查询与术语位置"><a href="#短语查询与术语位置" class="headerlink" title="短语查询与术语位置"></a>短语查询与术语位置</h3><p>当查询的是短语而不是单个词项的时候，Solr是如何搜索的呢？<br />简单的答案是，<strong>短语中的每个词项依然在Lucene索引中分别索引</strong>，就好像提交的查询时两个查询词的组合 new home，而不是短语 new home。一旦发现重叠的文档集，有一项之前未讨论过的<strong>倒排索引的特征将会发挥作用</strong>，这项特征就是<strong>词项位置，它会记录词项在文档中的相对位置</strong>，它是一个可选项<strong>。</strong><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621770556132-b3f65a63-9f08-4b16-b094-3a2a017f8d5c.png#height=703&id=fIhAj&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1406&originWidth=1684&originalType=binary&ratio=1&size=636095&status=done&style=none&width=842" alt="image.png"><br />从表3.7的倒排索引可以看出，查询 new AND home的搜索结果是文档5和文档8。词项位置更进一步指出文档中每个词项出现的位置。<br />从这个示例中，查询词new出现在被匹配文档的位置3，查询词home出现在被匹配文档的位置4。这是因为被匹配文档的书名为《buying a new home》和《becoming a new home owner》。确保被匹配的查询词出现在每个文档中的一个位置上，<strong>Solr保证查询词构成的短语出现在原始文档中</strong>。这就是词项位置的强大之处，<strong>允许在各自的文档中重新构造索引词项的初始位置，使其在查询阶段可以搜索特定的短语</strong>。<br><a name="b7bqj"></a></p>
<h3 id="模糊匹配"><a href="#模糊匹配" class="headerlink" title="模糊匹配"></a>模糊匹配</h3><p>既定查询在Solr索引中能找到怎样的搜索结果，这并不总能提前准确知晓，所以Solr提供了几种模糊匹配查询功能。模糊匹配可以对索引中的词项进行不那么精确的匹配。例如，有人想搜索**特定前缀开头的查询(称之为通配符搜索)<strong>，有人想搜索</strong>一个或两个字符的拼写变化(称为模糊搜索或编辑距离搜索)<strong>，有人想根据</strong>特定距离来匹配两个查询词(称为邻近搜索)**。查询词与短语的多种变化存在于被搜索的文档中，这种情况正式模糊匹配的用户之地。<br />本节探讨Solr的多种模糊匹配查询功能，包括通配符搜索、区间搜索、编辑距离搜索、邻近搜索。<br><a name="BY7F0"></a></p>
<h4 id="通配符搜索"><a href="#通配符搜索" class="headerlink" title="通配符搜索"></a>通配符搜索</h4><p>Solr最常见的模糊匹配形式之一是通配符。假设你想要找到以office开头的文档，一种方法是创建一个查询，列举所有可能的词汇形式。</p>
<ul>
<li>查询：office OR officer OR offical······</li>
</ul>
<p>在查询中罗列所需的词汇，显然这对用户来说是不合理的。<br />由于能匹配到的词汇变化已经存在于Solr的索引中，所以我们可以使用通配符 <code>*</code> 实现相同的查询功能，如下所示：</p>
<ul>
<li>查询：offi* 匹配office、officer、officiator等</li>
</ul>
<p>通配符<code>*</code> 匹配查询词中0个或者n个字符。若只匹配单个字符，可以使用问号 <code>?</code> 来实现。</p>
<ul>
<li><p>查询：off?r 匹配offer，但不匹配officer</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">首位通配符</span><br><span class="line">	虽然Solr的通配符功能相当强大，但特定的通配符查询执行可能花销巨大。当通配符搜索执行时，倒排索引中的所有词项与第一个通配符之前的查询词部分进行匹配。接下来，检查每个候选词项是否与查询中的通配符模式相匹配。正因为如此，在通配符之前指定越多的字符，查询执行速度越快。</span><br><span class="line">  执行首位通配符查询是一项花销甚大的操作。例如你需要匹配以ing结尾的所有词项，那可能会导致严重的性能问题。</span><br><span class="line">  查询：*ing</span><br><span class="line">  如果需要在搜索中使用首位通配符，其实还有一种更快的解决方案，但是需要做一些额外的配置。具体方法是在字段类型的分析链中增加ReversedWildcardFilterFactory类。</span><br><span class="line">  ReversedWildcardFilterFactory在Solr索引中两次插入被索引的内容，一次是每个词项的文本，另一次是每个词项的反向文本。</span><br><span class="line">  带有*ing首位通配符的查询提交后，Solr会搜索反向版本，将首位通配符搜索转为成标准通配符搜索，这会在反向内容中导致性能问题。</span><br><span class="line">  请注意，在Solr索引中开启对所有词项的双索引，会增加索引的大小且会拖慢整体搜索效率。除非必要，不然不建议开启这个功能。</span><br></pre></td></tr></table></figure>
<p>使用通配符搜索还需要注意一点，即通配符只适合单个查询词，不适用于短语搜索，示例如下：</p>
</li>
<li><p>适用：softwar* eng?neering</p>
</li>
<li><p>不适用：’softwar* eng?neering’</p>
</li>
</ul>
<p>如要在短语中执行通配符搜索，那就需要在索引中将整个短语存为单个词项。<br><a name="2N57G"></a></p>
<h3 id="区间搜索"><a href="#区间搜索" class="headerlink" title="区间搜索"></a>区间搜索</h3><p>Solr还提供了在已知区间值中进行搜索的功能，适用于在一个区间内搜索特定文档子集。例如，若要匹配2012年2月2日到2012年8月2日期间创建的文档，则可以执行以下搜索：</p>
<ul>
<li><p>查询：created:[2012-02-01T00:00.0z TO 2012-08-02T00:00.0z]该区间查询格式也适用其他字段类型；</p>
</li>
<li><p>查询：yearsOld:[18 TO 21]=&gt;匹配[18,21]；</p>
</li>
<li><p>查询：price：[12.99 TO 14.99]=&gt;匹配[12.99,14.99]</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">区间查询适用方括号，这是&quot;包含边界值&quot;的语法。另外，Solr还支持适用大括号实现不包含区间边界值的搜索。</span><br></pre></td></tr></table></figure></li>
<li><p>查询：yearsOld：{18 TO 21}=&gt;匹配(18,21)；</p>
</li>
</ul>
<p>虽然区间搜索的执行比单个词项搜索要慢，但他为Solr索引上动态匹配一组取值的特定区间提供了强大的灵活性。请注意，区间查询的词项排序就是Solr索引中被找到的顺序，即字典排序。Solr索引的排序取决于当时索引创建时候的字段数据的处理方式。<br><a name="F82EI"></a></p>
<h3 id="模糊-编辑距离搜索"><a href="#模糊-编辑距离搜索" class="headerlink" title="模糊/编辑距离搜索"></a>模糊/编辑距离搜索</h3><p>对于多数搜索应用而言，精确匹配用户输入的文本，灵活处理拼写错误，甚至对正确拼写做出细微修正都是非常重要的。Solr基于Damerau-Levenshtein距离的编辑距离度量方法提供了字符变体的处理手段，可以有效解决80%以上的人为拼写错误。<br />Solr使用 <code>~</code> 符号表示模糊编辑距离搜索，如下所示：</p>
<ul>
<li>查询：administrator~ 匹配administrator、administrater、administratior等。</li>
</ul>
<p>这个查询匹配到原始词项(administrator)及与之相距两个编辑距离的其他词项。<strong>编辑距离</strong>被定义为字符的一次插入、删除、替换或位置互换(transposition)。<br />另外，可以修改编辑距离的尺度，让搜索可以匹配任意编辑距离的词项。</p>
<ul>
<li>查询：administrator~1=&gt;匹配1个以内的编辑距离；</li>
<li>查询：administrator~2=&gt;匹配2个以内的编辑距离(默认值2);</li>
<li>查询：administrator~N=&gt;匹配N个以内的编辑距离。</li>
</ul>
<p>请注意，两个以上的编辑距离会使得搜索速度大幅下降，也可能匹配出以外的词项。一到两个编辑距离的术语搜索使用有效的Levenshtein自动机方法执行，但超过两个编辑距离的查询会退回到更慢的编辑距离实现方法。<br><a name="qangL"></a></p>
<h3 id="邻近搜索"><a href="#邻近搜索" class="headerlink" title="邻近搜索"></a>邻近搜索</h3><p>邻近搜索是在搜索词项A与词项B紧邻的文档，例如：</p>
<ul>
<li>查询：’chief officer’~1<ul>
<li>含义：chief与officer之间最多可以间隔1个词</li>
<li>示例：<code>chief executive officer</code>、’chief financial officer’</li>
</ul>
</li>
<li>查询：’chief officer’~2<ul>
<li>含义：chief与officer之间最多可以间隔2个词</li>
<li>示例：<code>chief executive officer</code>、’chief financial officer’、’chief business development officer’</li>
</ul>
</li>
<li>查询：’chief officer’~N<ul>
<li>含义：chief与officer之间最多可以间隔N个词</li>
</ul>
</li>
</ul>
<p>之前的邻近查询可视为传统短语搜索的’马虎’版本。事实上，’chief development officer’可以被很容易的冲写成’chief development officer’<del>0。由于编辑距离为0等价于精确短语搜索，所以二者的搜索结果相同。这<strong>两种机制均运用到了存储在Solr索引中的词项位置</strong>。值得注意的是，Solr邻近查询并未真正的使用编辑距离，因为它要求全部特定词项出现，而真正的编辑距离允许替换和删除(对单一词项进行模糊查询)。<br />编辑距离的一般原则仍然适用于词项邻近查询中的词项插入和换位。沿着这条思路，你可能也注意到，为了能够匹配到’office chief’，需要特定短语间距值(slop)为2，即’chief office’</del>2。这是因为，第一个编辑操作把chief和office两个词移动到相同的位置，第二个编辑操作把chief向office左侧移动一个位置。这里再次强调了一个事实，邻近搜索并不适用与真实的编辑距离，换位可能只算做一次编辑操作。那么会有这样的问题出现：’如果要在邻近查询中准确无误的指定短语，那得需要搜集多少个位置信息，把它们添加到文档的文本呢？’<br><a name="sKgso"></a></p>
<h2 id="相关度"><a href="#相关度" class="headerlink" title="相关度"></a>相关度</h2><p>我们将深入探讨Solr默认的相关度计算原理和相关度得分的计算公式，并提供直观的示例，帮助你在读完本节之后打下扎实的基础。对于大多数人而言，这部分是Solr中最难理解的内容。我们从Similarity类开始讨论，他负责查询相关度得分计算的主要方面。<br><a name="AHj69"></a></p>
<h3 id="默认相似度"><a href="#默认相似度" class="headerlink" title="默认相似度"></a>默认相似度</h3><p>Solr的相关度得分是基于Similarity类的。在Solr的schema.xml中，这个类被定义为一个预设字段。Similarity是一个Java类，它根据给定查询定义了搜索结果相关度得分的计算方法。你可以选择多个Similarity类，甚至编写自己的Similarity类，但在此之前，你需要理解Solr默认的Similarity实现及其理论基础。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621778753814-4600609c-dc4e-4feb-b3a9-d2484898c8a6.png#height=357&id=ZXio3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=714&originWidth=1618&originalType=binary&ratio=1&size=409711&status=done&style=none&width=809" alt="image.png"><br />默认情况下，Solr使用Lucene相应的DefaultSimilarity类。这个类使用两段式检索模型来计算相似度。首先，使用<strong>布尔模型过滤出不符合用户查询的所有文档</strong>。然后，使用<strong>向量空间模型</strong>通过<strong>计算和绘制</strong>将<strong>查询和文档转换为向量</strong>，在此基础上计算相似度得分。<strong>每个文档的相似度得分基于查询向量与文档向量的夹角余弦值</strong>。<br />在向量空间评分模型中，每个文档的<strong>词项向量</strong>经过计算后会与<strong>给定查询对应的词项向量进行比较</strong>。两者的<strong>相似度通过夹角的余弦值</strong>来表示，余弦值为1表示完美匹配；余弦值为0表示无相似性。更直观的说，两个向量越接近，则表示他们相似性越高；<strong>两向量之间的夹角越小，则余弦值越大，则表示匹配度越高</strong>。<br />当然，如果针对查询和文档的重要特征构造合理的向量来表征他们，继而进行比较，这是整个过程中最具挑战性的任务。我们来看一下DefaultSimilarity类的相关度计算公式，依次对公式中的每一部分的作用进行直观解释。<br />给定查询(q)和文档(d)，查询对应的文档相似度的得分如下：<br />$$Score(q,d)=\sum_{i\ in\ q}(tf(t\ in\ d)\ *\ t.getBoost()\ *\ norm(t,d))\ *\ coord(q,d)\ *\ queryNorm(q) $$其中：<br />$$t=词项；d=文档；q=查询；f=字段；$$<br /><strong>词频</strong>(term frequency, tf)：$$tf(t\ in\ d)=numTermOccurrencesInDocument^{1/2}$$<br /><br><br /><strong>逆文档频率</strong>(inverse document frequency, idf)：$$idf(t)=1\ +\ log(numDocs/(docFreq\ +\ 1))$$<br /><br><br /><strong>协调因子</strong>：$$coord(q,d)=numTermsInDocumentFromQuery/numTermsInQuery$$<br /><br><br /><strong>查询归一化</strong>：$$queryNorm(q)=1/(sumOfSquaredWeights^{1/2})$$<br /><br><br />$$sumOfSquaredWeights=q.getBoost()^2*\sum_{t\ in\ d}(idf(t)*t.getBoost()^2)<br>$$<br /><br><br /><strong>字段归一化</strong>：$$norm(t,d)=d.getBoost()*lengthNorm(f)*f.getBoost()$$<br /><strong>​</strong></p>
<p><strong>词元权重</strong>(term boost, t.getBoost)<br /><strong>​</strong></p>
<p><strong>​</strong><br /><br><a name="8p2s8"></a></p>
<h4 id="词频"><a href="#词频" class="headerlink" title="词频"></a>词频</h4><p>词频是指特定词项在待匹配文档中出现的次数，表示了文档与该词项的匹配程度。<br />从表3.9明显可以看出，第二篇文章比第一篇文章更相关。在第二篇文章中，President与United States多次出现，这表明它的内容与此查询更接近。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1621780818413-41dab827-fa15-4536-86b3-3c1bdd05c2f4.png#height=355&id=AHnFz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=710&originWidth=1700&originalType=binary&ratio=1&size=688804&status=done&style=none&width=850" alt="image.png"><br />一般情况下，若主题在文档中出现多次，则认为该文档与与特定主题(查询词项)更相关。<br />这是Solr默认相关度公式中tf的基本前提。查询词项在某一文档中出现次数越多，则该文档被视为越相关。但是，某一词项在文档中出现的次数为10，并不意味着该文档的相关度就提升10倍，因此我们会对该文档中查询词项出现的次数开方来计算tf，以此减少查询此项多次出现对相关度得分的额外加成。<br><a name="R6xgz"></a></p>
<h4 id="逆文档频率"><a href="#逆文档频率" class="headerlink" title="逆文档频率"></a>逆文档频率</h4><p>查询词项并非都是’生来平等’的。假设有人在图书馆目录中搜索苏西博士的’The Cat in the Hat’，那么位于搜索结果前列的文档是包含了the和in这些高频词(而不是cat和hat)的文档。然而，在查询匹配中较少见的词比常见词具有更高的区分度。<br />逆文档频率是描述查询词项罕见程度的度量，根据文档频率(docFreq，含有该查询词项的总文档数)计算它的逆文档频率。<br />因为在idf中词项同时出现在查询和文档中，因此在相关度公式中计算中需要求平方。idf值越大，则表示词项越罕见。<br />词频和逆文档频率在相关度计算中起到了相互平衡作用。词频奖励了在一个文档中出现多次的词项，而逆文档频率惩罚了在多个文档中普遍出现的词项。因此，常见词最终会拉低相关度得分。<br><a name="4YLY7"></a></p>
<h4 id="词元权重"><a href="#词元权重" class="headerlink" title="词元权重"></a>词元权重</h4><p>如果你拥有专业领域知识，对内容本身的特定字段或词项的相对重要性能做出判断的话，那么久可以在索引阶段或查询阶段相应调整这些字段或词项的权重。<br />查询阶段权重设置，具有最灵活和简单的权重设置理解形式，使用如下语法：</p>
<ul>
<li>查询：title:(solr in action)^2.5 description:(solr in action)</li>
</ul>
<p>该示例将title字段的查询短语权重设置为2.5，description字段保留以默认权重1.0。</p>
<ul>
<li>查询：title:(solr^2 in^.01 action^1.5)^3 OR “solr in action”</li>
</ul>
<p>需要注意，<strong>权重小于1仍然表示正向权重</strong>。这并不是在惩罚包含哪些词项的文档，只是让该词项的重要性比那些默认权重的词项弱一些。<br />查询阶段的权重设置可应用在查询表达式的任何部分。</p>
<ul>
<li>查询：title:(solr^2 in^.01 action^1.5)^3 OR “solr in action”^2.5</li>
</ul>
<p>特定查询解析器甚至可以默认对整个字段设置权重。<br />除了可以在查询阶段权重设置之外，在索引阶段也可以为文档字段设置权重。<br><a name="EIde3"></a></p>
<h4 id="规范化因子"><a href="#规范化因子" class="headerlink" title="规范化因子"></a>规范化因子</h4><p>Solr默认的相关度公式计算了三种规范化因子：字段归一化、查询归一化和协调因子。<br><a name="3TFPZ"></a></p>
<h5 id="字段归一化"><a href="#字段归一化" class="headerlink" title="字段归一化"></a>字段归一化</h5><p>字段归一化是以<strong>每个文档为基础的特定字段重要性</strong>的因子组合。字段归一化在<strong>索引创建时进行计算</strong>，其表示为Solr索引中每个字段的<strong>一个附加字节</strong>。<br />该字节包含许多信息：文档被索引时的权重集、字段被索引时的权重集、惩罚长文档的同时提升短文档的长度归一化因子(前提是给定关键词在长文档出现的可能性更大，因此相关性较低)。<br />计算公式如下：<br />$$norm(t,d)=d.getBoost()*lengthNorm(f)*f.getBoost()$$<br /><strong>d.getBoost()<strong>分量表示发送至Solr的</strong>文档权重</strong>，<strong>f.getBoost()<strong>分量表示</strong>字段权重</strong>。值得一提的是，Solr允许同一字段被多次添加到文档(执行的背后逻辑是将字段的每个单独条目映射到同一个底层Lucene字段)。由于重复的字段最终被映射到同一个底层字段，因此如果该字段存在多个副本，f.getBoost()会成为多个相同名称字段的每个权重相乘的积。<br />除了索引阶段的权重设置以外，长度归一化因子也会被纳入到字段规范中。<strong>长度归一化因子取值等于字段中词项数量的平方根</strong>。<br />值得一提的是，文档权重在内部执行时会被赋给该文档的每个字段最为权重。换句话说，设置文档权重与为该文档中每个字段赋予文档相同的权重值，这两种操作并没有差异。所有文档的权重最终存储在各自文档的每个字段规范中。<br /><strong>长度归一化的目的是调整不同长度的文档的相关度得分</strong>。通常，特定词项在长文档中出现次数可能较多，通过归一化可以消除较长文档的这一优势。(可以理解成为了实现均长文档给定词的出现频率)<br />总体的字段归一化通过文档权重、字段权重和长度归一化的乘积计算而来，被编码为单字节存储在Solr索引中。由于乘积编码的信息总量超过了单字节的容积，因此编码过程中会损失一些精度。现实中，这种保真度的损失对总体相关度的影响可以忽略不计，只有在其他相关度因素都不一致的情况下才会体现出较大差异。<br><a name="5ipWH"></a></p>
<h4 id="查询归一化"><a href="#查询归一化" class="headerlink" title="查询归一化"></a>查询归一化</h4><p>查询归一化是Solr默认相关度计算中较少被关注的因子之一。由于同一个queryNorm应用与所有文档，因此<strong>它不影响总体的相关度排序</strong>，它仅用于查询之间进行比较时得分计算时规范化因子。该因子是每个查询词项的权重平方和，再将它与相关度得分的其他部分进行相乘，从而实现规范化。查询归一化不应影响与给定查询相匹配的每个文档的相对权重。<br><a name="zLpoY"></a></p>
<h4 id="协调因子"><a href="#协调因子" class="headerlink" title="协调因子"></a>协调因子</h4><p>协调因子是Solr默认相关度计算的最后一个规范化因子。他的作用是衡量每个文档匹配的查询数量，举例说明：</p>
<ul>
<li>查询：Accountant AND (“San Francisco” OR “New York” OR “Paris”)</li>
</ul>
<p>在查询的时候，你可能更倾向于查找到每个城市的会计师及其所在办公室，而不是一遍遍提及’New York’的一位会计师。<br />若4个词项全部匹配到，则协调因子是4/4；若匹配到三个词项，则协调因子是3/4。<br />协调因子的理念是，所有事物都是平等的，<strong>包含很多查询词项的文档应该比只包含几个查询词项的其他文档得分更高</strong>。<br><a name="yMeR7"></a></p>
<h2 id="查准率与查全率"><a href="#查准率与查全率" class="headerlink" title="查准率与查全率"></a>查准率与查全率</h2><p><a name="6mMnJ"></a></p>
<h3 id="查准率"><a href="#查准率" class="headerlink" title="查准率"></a>查准率</h3><p>搜索结果集(与查询相匹配的文档集)的查准率表示<strong>所搜索到的文档是否是你所想查找的文档</strong>。<br />查准率的具体定义(rate:[0,1])：$$rate=正确匹配的文档数量/返回的文档数量$$；如果返回了三个文档，三个文档都是相关的文档，那么查准率就是1；如果返回了六个文档，其中三个文档相关，三个不相关，那么查准率就是0.5。但是，如果返回了一个文档，并且是相关的，那么查准率依旧是1.0。因此，<strong>查准率是衡量结果与查询是否相关的一个指标，但是它并不关注全面性</strong>，即使在一百万个文档中只返回了一个，查准率依然会视为最佳匹配。<br><a name="V4kA3"></a></p>
<h3 id="查全率"><a href="#查全率" class="headerlink" title="查全率"></a>查全率</h3><p>查全率是衡量的搜索结果的全面性，查全率表示<strong>返回了多少的正确的文档</strong>。<br />查全率的具体定义(rate:[0,1])：$$rate=正确匹配的文档数量/(正确匹配的文档数量+错误匹配的文档数)$$<br />查准率和查全率的重要区别是：如果返回的结果是正确的，则查准率高；如果正确的结果都被返回来了，则查全率高。<strong>查全率不关心返回的结果是否都是正确的，而查准率不关心正确的结果是否都返回来了</strong>。<br><a name="ZQQGJ"></a></p>
<h3 id="两者的平衡"><a href="#两者的平衡" class="headerlink" title="两者的平衡"></a>两者的平衡</h3><p>虽然查准率和查全率自检存在明显的互逆关系，但他们之间并不是互相排斥的。<br />最大限度提升查准率和查全率是绝大多数搜索相关度优化的最终目标。人为或手动调整结果集看似简单，但事实上，这是一个具有挑战性的难题。<br />Solr采用的许多技术能够提高查准率和查全率，其中大多数技术更倾向于提高查全率。Solr中平衡查准率和查全率的一种常见方式是：<strong>在整个结果集上计算查全率，仅在搜索结果的第一页(或少数页)上计算查准率</strong>。根据这一模型，调节Solr的相关度评分的计算方式，让更好的 匹配结果被提升到搜索结果的顶部，而许多不良的匹配粗线在搜索结果的底部。<br />以上是一种问题解决方式。<strong>一般来说，访问者仅会访问前几页的内容，因此我们在前几页显示更精确的结果，在后续页面显示准确度略低的匹配结果</strong>。这将得到高查全率，因为在整个结果集上”宽松地”对待能够匹配初始查询的那些关键词。与此同时，查询结果的列表顶端最佳匹配进行了提升，导致列表前端的查准率也很高。<br /><strong>如何在查全率和查准率取得平衡，是需要取决于现实情况的</strong>。例如在律法方面的搜索中，查全率则尤为重要，因为如果遗漏了文档，就可能会导致一定的法律后果。对于其他的现实需求而言，可能仅仅找到一些最佳匹配就可以了，若没有找到精确匹配查询词项的结果，不返回结果即可。<br />大多数搜索应用处在这两个极端之间。由于大多数情况没并没有所谓的正确答案，所以查准率和查全率之间的适度平衡成为了一项长期的挑战。不论如何，理解查准率与查全率以及如何在两者之间做出调整——使得杠杆向某一边倾斜，这是有效改进搜索结果质量的关键。<br><a name="zv7nn"></a></p>
<h2 id="搜索的规模化"><a href="#搜索的规模化" class="headerlink" title="搜索的规模化"></a>搜索的规模化</h2><p>除了速度、相关度与强大的文本搜索功能以外，Solr最吸引人的方面之一是它的规模化。通过添加服务器，Solr可以扩展到处理数十亿文档与无限查询请求数量。本节主要探讨以下内容：Solr文档的非规范化本质、跨服务器线性扩展的理由、分布式搜索原理、从概念上理解服务器到服务器集群的转变，以及Solr扩展的一些局限。<br><a name="9j2h0"></a></p>
<h3 id="非规范化文档"><a href="#非规范化文档" class="headerlink" title="非规范化文档"></a>非规范化文档</h3><p>Solr的核心概念是<strong>所有文档去除规范化</strong>。<strong>非规范化文档</strong>(denormalized document)指文档中的<strong>所有字段是自包含的</strong>，允许这些字段的值在多个文档中重复出现。对许多NoSql技术来说，非规范化数据的概念很常见。非规范化的一个很好的示例是用户个人资料，包含city(城市)、state(省份)和postalCode(邮编)。大多数情况下，对于每个特定的邮编取值而言，所有文档中的城市和省份字段取值应该是相同的。这与规范化文档形成对比，<strong>文档各部分之间的关系可以拆分成多个更小的文档，在查询阶段各部分再连接起来</strong>。规范化文档只包含一个邮编字段，每个特定的邮编对应一个单独的位置文档，这样的话，城市和省份字段就不需要再每个用户个人资料中重复出现了。图3.11展示了传统规范化数据库表的建模，大大的’×’说明它在Solr的数据建模中明显不使用。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622383310239-c65d8505-ac01-4bfc-ba6d-48546d3fe1bd.png#height=503&id=DJKY0&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1006&originWidth=1874&originalType=binary&ratio=1&size=1050723&status=done&style=none&width=937" alt="image.png"><br />请注意，图3.11中信息代表了在同一家公司任职的两个用户。如图所示，数据被规范化后分别放入单独的表中，包括雇员个人信息、位置与公司三个字段。这不是Solr文档的表示方式，以下为Solr文档的表示方式。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622383410968-cb6bd703-9b1a-493a-b079-6a4edc01537f.png#height=440&id=X7LxU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=880&originWidth=1854&originalType=binary&ratio=1&size=740053&status=done&style=none&width=927" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622383421923-6aef5f93-33fa-473b-9bcb-ba627859df13.png#height=310&id=n0Tj5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=620&originWidth=2030&originalType=binary&ratio=1&size=512120&status=done&style=none&width=1015" alt="image.png">    请注意，所有的公司信息在第一个用户文档和第二个用户文档中重复出现，这似乎有悖于规范化数据库设计中减少数据冗余与最小数据依赖的原则。在传统关系型数据库中，可以通过连接多个表的数据来实现查询。虽然Solr支持基本的连接查询功能，但是建议仅在不能进行内容去规范化的情况下使用该功能。Solr能够识别出映射到文档的词项，但并不能识别文档之间的关系。也就是说，如果你想要搜索Decatur.GA公司的员工，那么所有的用户个人资料需要包含companycity和companystate字段才能成功实现检索。<br />虽然非规范化文档数据模型看似存在一些局限，但他提供了极具可扩展性的规模化优势。在每个文档都是自包含的前提下，可以服务器对文档进行分区，而无需保持单一服务器上的相关文档(因为文档之间是相互独立的)。<strong>文档独立性的基本假设允许在多个文档分区的多台服务器之间并发查询，从而改进查询性能，最终能够实现并发处理数十亿文档的查询</strong>。Solr跨分区与服务器的扩展能力称之为分布式搜索。<br><a name="CJ98Y"></a></p>
<h3 id="分布式搜索"><a href="#分布式搜索" class="headerlink" title="分布式搜索"></a>分布式搜索</h3><p>在实际业务中，同时发出过多的查询请求，或者需要在单台服务器上处理太多的搜索数据，这些都会导致搜索服务器超载。这种情况下，有必要将<strong>内容拆分到两个单独的Solr索引中，每个索引包含单独的一部分数据</strong>。<strong>每次搜索运行的时候，查询会被同时发送到两太服务器上，分别进行处理后汇总在一起再返回给搜索引擎</strong>。<br />Solr的分布式搜索功能开箱即用。从理论上讲，每个Solr索引(单体下称之为内核’core’，SolrCloud模式下称之为集合’collection’)使用它的唯一Url来调用，并使用以下语法实现多个Solr内核的聚合搜索：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://box1:8983/solr/core1/select?q=*:*&amp;shards=box1:8983/solr/core1,box2:8983/solr/core2,box2:8983/solr/core3</span><br></pre></td></tr></table></figure>
<p>上述例子具有如下4个特点：</p>
<ul>
<li>该分片参数用于指定一个或多个Solr内核的地址。分片是索引的一个分区，Url的分片参数告诉Solr，对不同Solr内核上发现的多分区数据进行结果聚合。</li>
<li>在box1和core1上搜索的Solr内核也包含在分片列表中。除非发起明确的请求，否则内核不会自动搜索。</li>
<li>分布式搜索会对多个服务器进行搜索。</li>
<li>不要求将独立的Solr内核放在单独的及其上。他们可以在同一台机器上。</li>
</ul>
<p>根据Solr扩展属性开展搜索很重要。因为<strong>多个Solr内核的分布式搜索运行在每个索引分区上</strong>，所以Sol<strong>r理论上应该可以进行线性扩展</strong>。<strong>如果将一个Solr索引拆分为文档数量相同的两个索引，那么减去结果聚合开销的话，跨两个索引的分布式搜索能够提速接近50%<strong>。<br />理论上讲，服务器可以增加到任意数量(现实中服务器数量总有上限)。增加一个索引分区(假设文档总数相同)时，总查询速度的理论公式如下：<br />$$(N+1个索引的查询速度)=结果聚合的开销+(N个索引的查询速度)/(N+1)<br>$$<br />这个公式可用于对数据平均分割的分区数量增加所带来的好处进行估算。由于Solr是近线性扩展的，若不考虑服务器资源负载过重的限制，</strong>可以通过添加Solr内核(分区)数量来减少查询时间</strong>。<br><a name="kyGei"></a></p>
<h3 id="集群-VS-服务器"><a href="#集群-VS-服务器" class="headerlink" title="集群 VS. 服务器"></a>集群 VS. 服务器</h3><p>除了分布式搜索以外，通过向系统中添加多个同样的服务器也可以平衡高查询量的负载。<br />这两种策略取决于服务器与集群的观念转变。<strong>服务器集群的定义为协同工作以执行同一功能的多台服务器</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://box1:8983/solr/core1/select?q=*:*&amp;shards=box1:8983/solr/core1,box2:8983/solr/core2</span><br></pre></td></tr></table></figure>
<p>以上示例在两个Solr内核(box1上的core1和box2上的core2)上执行分布式搜索。如果在执行过程中box2发生故障了，在box1上执行查询会发生什么情况？<br />代码清单3.3显示了这种情况下Solr的响应，包括了box2连接失败的错误消息。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1622385740336-ccc0a8d8-897d-473d-a6c0-9c15fda5f44b.png#height=560&id=hiqOE&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1120&originWidth=1958&originalType=binary&ratio=1&size=661169&status=done&style=none&width=979" alt="image.png"><br />请注意，<strong>这种情况下的服务器是相互依存的。如果其中一台无法被搜索，他们就都不能被搜索，导致整体出错</strong>。因此，构建Solr解决方案时候要考虑扩展性这一重要方面，不要把所有鸡蛋放在一个篮子里，要<strong>采用服务器集群取代单一服务器，由这些服务器组成一个计算资源来提供服务</strong>。Solr内置的Apache Zookeeper能够提供优秀的集群管理功能。<br><a name="Rzzoq"></a></p>
<h3 id="Solr的局限"><a href="#Solr的局限" class="headerlink" title="Solr的局限"></a>Solr的局限</h3><p>Solr是强大的基于文档的NoSql数据存储方案，支持全文搜索与数据分析。前面讨论了Solr的倒排索引与基于关键词的复杂布尔查询功能所带来的有力优势，还讲解了相关度的重要性，我们还看到Solr能够提供跨多态服务器，进行或多或少的限行扩展，从而对额外的内容和查询量进行处理。那么Solr对于哪些情况而言不是一个好的解决方案呢？Solr的局限有哪些？<br />1、<strong>Solr在文档处理上不以任何方式构成关系型</strong>。它<strong>不适用于在不同文档的不同字段上连接大量数据，也无法在多台服务器上执行join操作</strong>。与关系型数据库相比，这是Solr的基本局限。由于克服了关系型数据库的扩展局限性，<strong>文档独立性假设</strong>是许多NoSql技术常用的折衷方式。<br />2、Solr文档是非规范性文档，它的数据是冗余的，每个文档中相同字段的数据会重复出现。<strong>当多个文档共享的某个字段的数据发生变化时候，这会带来很麻烦的问题</strong>。<br />举个例子，假设要构建一个社交网络用户个人资料的搜索引擎。其中一个用户John Doe与另一个用户Coco成为朋友。这不仅需要更新John和Coco的用户信息，还需要更新John和Coco所有朋友的’二级连接’字段。对’两个用户成为朋友’这一操作就需要更新上百个文档。<br />3、<strong>Solr目前主要作文档存储方案</strong>，也就是说，你<strong>可以插入、删除与更新文档</strong>，但<strong>不能对字段轻松的做这些操作</strong>。当前， Solr对单个字段仅能做一些简单的处理，而且前提是字段的原始值存储在索引中，但这样做又比较浪费。即便如此，<strong>Solr还是基于内部存储字段，通过重做索引来更新整个文档</strong>。这就意味着，<strong>每当新的字段添加到Solr或者已有字段内容发生变化时，Solr索引的每个文档必须在搜索文档的新字段填充数据之前全部重新处理</strong>。许多其他的NoSql系统也存在同样的问题，但值得注意的是，目前在语料库中添加或修改所有文档中的字段时候，需要非常少量的文档更新协调，确保Solr能够及时完成更新。<br />4、Solr也适用于一种特殊情况：处理少量搜索词的查询，快速检索每个搜索词匹配的文档，计算相关度得分，对其进行排序并显示少量的返回结果。Solr不适用于处理非常长的查询(包含上千个搜索词的查询)或给用户返回大量的搜索结果集。<br />5、Solr的最后一个值得一提的局限是他的可扩展性(自动添加和删除服务器，以及处理负载而重新分发内容的能力)不够灵活。虽然Solr可以很好的跨服务器进行扩展，但是在前自动扩展下，它本身的灵活性还不够。SolrCloud最新版本中使用Apache Zookeeper来管理集群，使得这一问题得到了一定程度的处理。<br /></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%89%E7%AB%A0-Solr%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Solr手册-第四章 Solr简单配置
          
        </div>
      </a>
    
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%8C%E7%AB%A0-Solr%E4%B8%8A%E6%89%8B/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Solr手册-第二章 Solr上手</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021-2023
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="J`Han&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HomePage</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Document</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Solr/">Solr</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>如果觉得对您有帮助，来个打赏吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>