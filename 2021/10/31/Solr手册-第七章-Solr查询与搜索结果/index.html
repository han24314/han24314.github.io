<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Solr手册-第七章 Solr查询与搜索结果 |  J`Han&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Solr手册-第七章-Solr查询与搜索结果"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Solr手册-第七章 Solr查询与搜索结果
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%83%E7%AB%A0-Solr%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/" class="article-date">
  <time datetime="2021-10-31T02:17:31.000Z" itemprop="datePublished">2021-10-31</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">28.3k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">102 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><a target="_blank" rel="noopener" href="https://livebook.manning.com/book/solr-in-action/about-this-book/">《Solr in action》英文书籍链接(Original Book Link)</a><br /><a target="_blank" rel="noopener" href="https://www.manning.com/">《Solr in action》英文书籍版权归Manning出版社</a><br /><a target="_blank" rel="noopener" href="https://www.phei.com.cn/">《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。<br><a name="N3pon"></a></p>
<h1 id="第二部分-Solr的核心功能"><a href="#第二部分-Solr的核心功能" class="headerlink" title="第二部分 Solr的核心功能"></a>第二部分 Solr的核心功能</h1><p>接下来的6章将介绍Solr的核心功能，帮助你实现面向用户的强大搜索和发现体验。<br />搜索最重要的特征是为查询提供相关的搜索结果。在第七章中，<strong>你将学习如何构造复杂的查询，如何对搜索结果排序和浏览结果，以及如何以各种格式返回搜索结果</strong>。<br />关键词搜索是Solr的主要功能，除此之外，大多数搜素应用还需要其他功能来改善整体的用户体验。在第八章至第十一章中，我们将讨论Solr最常见的一些附加功能。<br />具体来说，我们将讨论：<strong>分面</strong>-用于搜索结果优化；<strong>搜索结果高亮</strong>-提供文本片段，显示匹配到的关键词的上下文信息；<strong>拼写检查和自动建议</strong>-帮助那些打字太快或拼写出错的用户修正查询；<strong>字段折叠和结果分组</strong>-去除多个类似结果，以体现结果文档的多样性。<br />如果第八章至第十一章的某些内容不适用于你的当前需要，在阅读时可以跳过它们。例如，搜索结果分组是许多搜索引擎的一个常见功能，加入你的数据不需要这个功能，就可以跳过第十一章，<br />最后，第十二章将深入介绍在生产环境中启用与扩容Solr时需要考虑的重要因素，提供了一份多年Solr实践的第一手经验总结。可扩展的搜索是Solr的DNA中不可或缺的一部分，这一张对Solr核心功能进行了充分总结。<br /></p>
<p><a name="L81Y5"></a></p>
<h1 id="Chapter-Seven-执行查询和处理搜索结果"><a href="#Chapter-Seven-执行查询和处理搜索结果" class="headerlink" title="Chapter Seven 执行查询和处理搜索结果"></a>Chapter Seven 执行查询和处理搜索结果</h1><p>本章要点</p>
<ul>
<li><strong>介绍Solr搜索功能的各种请求处理器</strong></li>
<li><strong>通过Solr可插拔式搜索组件扩展搜索结果</strong></li>
<li><strong>通过查询解析器组合实现强大的查询功能</strong></li>
<li><strong>返回的查询结果包括静态值和动态值</strong></li>
<li><strong>根据值、函数和相关度进行排序</strong></li>
<li><strong>调试搜索结果</strong></li>
</ul>
<p>第五章和第六章主要介绍了Solr的索引与文本分析功能。正如你所见，文本分析发生在索引创建和执行查询两个阶段。接下来两张主要关注的是，根据文本内容分析生成倒排索引，以及后续的搜索使用。本章切换到查询端，探索Solr的搜索功能。<br />本章会回顾请求处理器的概念（详见第四章），以及SearchHandler的环境配置，它是Solr最重要的请求处理器。SearchHandler运行一个或多个SearchComponent，包括QueryComponent，它用于响应搜索请求，执行主查询。在讨论QueryComponent时，我们还会介绍Solr的许多查询解析器，展示Solr的强大查询语法与搜索功能。<br />当熟悉了完整的查询语法之后，我们会介绍如何处理返回的搜索结果。本章会介绍如何对搜索结果进行排序、分页、返回特定字段和动态生成值、定义搜索结果格式及调试搜索请求等。本章涵盖了Solr的核心搜索功能，介绍了构建Solr驱动的复杂搜索应用需要的所有基础只是。为了深入学习Solr的核心搜索功能，让我们先回顾一下Solr对传入的请求如何进行处理。<br><a name="EFX9U"></a></p>
<h2 id="Solr的请求详解"><a href="#Solr的请求详解" class="headerlink" title="Solr的请求详解"></a>Solr的请求详解</h2><p>Solr最常见的请求类型是在Solr索引中查找相关文档的查询（query）。除此之外，Solr还可以处理许多不同类型的请求。第四章曾介绍过，所有的请求（例如，文档更新和查询）基本上都是通过请求处理器提交给Solr。搜索处理器（searchHandler）是查询处理的默认请求处理器，通过调用一个或多个搜索组件，每个组件处理搜索请求的一部分，从而满足查询各个阶段的要求。例如，通过搜索组件执行主查询，其中<strong>分面（详见第八章）</strong>、<strong>搜索结果高亮（详见第九章</strong>）和<strong>拼写检查（详见第十章）</strong>都有各自的搜索组件。要让查询请求能够使用主搜索组件，需要通过一个或多个查询解析器对查询文本进行解析，起作用是理解查询语法，将其映射为适当的查询对象集，以便在Solr索引中找到相关文档集。本节在第四章介绍的请求处理器和搜索组件基础上，进一步剖析Solr的请求，讨论请求处理器、搜索组件与查询解析器之间的交互。我们首先从请求处理器入手。<br><a name="nDSUP"></a></p>
<h3 id="请求处理器"><a href="#请求处理器" class="headerlink" title="请求处理器"></a>请求处理器</h3><p>请求处理器（Request Handler）基本上是Solr所有请求的入口。它的作用是接受请求，执行某些功能，向客户端返回结果。Solr拥有许多请求处理器来完成各项任务，例如，搜索执行（SearchHandler）、从一台服务器向另一台服务器复制索引（ReplicationHandler），以及添加新文档以更新Solr索引等（UpdateRequestHandler）。你还可以通过LukeRequestHadnler获取更多有关Solr索引的丰富信息，通过SystemInfoRequestHandler获取内存使用情况和Solr设置等服务器信息等。为简单起见，大多数请求处理器继承自RequestHandlerBase这个类，但这种做法并不是强制性的。SolrRequestHandler接口实现的任何类都可以作为一个请求处理器。虽然我们可以编写自己的请求处理器作为Solr的插件，实现SolrRequestHandler接口，但是大多数Solr用户还是会使用Solr内置的请求处理器。图7.1显示了大多数Solr内置处理器的继承关系。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627217831799-271a4cdf-6935-492b-84a9-e477bb447dc4.png#height=1818&id=WKWYx&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1818&originWidth=1916&originalType=binary&ratio=1&size=2247141&status=done&style=none&width=1916" alt="image.png"><br />从图7.1中可以看出，Solr可以处理许多不同类型的请求。SearchHandler作为Solr最常用的请求处理器，它是搜索处理的默认请求处理器。图中有一些Solr内置处理器会在后续章节中详细介绍，其他处理器则留给你们自行探索。表7.1对每个请求处理器的常见做法做了简要介绍。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627217976580-a2e5ca56-5bf0-4279-ad00-29fa10efa078.png#height=472&id=PCn5f&margin=%5Bobject%20Object%5D&name=image.png&originHeight=472&originWidth=1908&originalType=binary&ratio=1&size=536328&status=done&style=none&width=1908" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627218030311-5ac931f4-bb6e-465b-951c-da77e8f18c34.png#height=2630&id=xaVOu&name=image.png&originHeight=2630&originWidth=1926&originalType=binary&ratio=1&size=2488057&status=done&style=none&width=1926" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627222310791-b9c28524-ea98-4ee0-be75-44e14080b0a5.png#height=1434&id=M3zYY&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1434&originWidth=1900&originalType=binary&ratio=1&size=1350769&status=done&style=none&width=1900" alt="image.png"><br />虽然表7.1中的许多请求处理不会被大多数Solr用户使用到，但了解一下这些请求处理器，可能会在未来有所帮助。每个请求处理器使用之前都要在solrconfig.xml（详见第四章）中进行定义和配置。代码清单7.1是一个配置示例，启用了更新文档的UpdateRequestHandler、从一台服务器向另一台服务器复制文件的ReplicationHandler，以及几个用于搜索的SearchHandler实例。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627222468472-1605a6ee-4580-4ae5-aaea-2c7e874d3612.png#height=722&id=rHsfT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=722&originWidth=1886&originalType=binary&ratio=1&size=573999&status=done&style=none&width=1886" alt="image.png"><br /><strong>定义一个请求处理器时，需要指定两个属性：name和class</strong>。Solr维护了一个请求处理器查找列表，根据每个请求的指定要求，派发对应的请求处理器。class属性对应特定的Java类（SolrRequestHandler接口实现），使用指定名称的请求处理器处理查询请求。<br />如果请求处理器的名称以反斜杠/开头（这是标准做法），name就使用该请求处理器的性对URL。举例来说，使用代码清单7.1的配置启用Solr示例程序（如果不知道怎么操作，请回顾第二章），你会得到以下URL：</p>
<ul>
<li><strong><a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/select/">http://localhost:8983/solr/collection1/select/</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/update/">http://localhost:8983/solr/collection1/update/</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/replication/">http://localhost:8983/solr/collection1/replication/</a></strong></li>
<li><strong><a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/private/search/">http://localhost:8983/solr/collection1/private/search/</a></strong></li>
</ul>
<p>这样做的话，其中一些请求处理器会报错，这是因为它们需要根据请求指定默认参数，不过你仍然可以通过添加它们的name到Solr URL来调用这些请求处理器。<br />对于代码清单7.1，还需要补充两点。首先，请注意，请求处理器/select和/private/search定义的类相同。其次，请注意，在/replication的请求处理器上有一项<strong>startup=”lazy”<strong>属性。一般来说，某个请求处理器不会用在所有的Solr服务器上。</strong>设置启动选项为lazy，这表示，直到第一次调用该请求处理器时，Solr才会加载它。这样做会节省资源，但会导致该请求处理器的初次查询变慢。</strong><br />回顾一下之前的章节，你会发现已经使用到了多个请求处理器。在第四章中，你已经见过UpdateHandler和SearchHandler的使用，例如，向Solr添加文档并对这些文档进行搜索。后续章节会继续讨论其他请求处理器，在这里你应该已经很好地了解了请求处理器是什么以及如何定义它们。了解请求处理器有注意掌握搜索组件，由于偶尔存在功能上的重合，所以有时容易将搜索组件与搜索处理器相混淆。<br><a name="ikVDg"></a></p>
<h3 id="搜索组件"><a href="#搜索组件" class="headerlink" title="搜索组件"></a>搜索组件</h3><p>上一节介绍了许多不同类型的Solr请求处理器，SearchHandler是执行搜索的默认相应处理器，搜索默认会返回什么呢？是否只包括搜索结果？有没有匹配到的最相关类目，或是对匹配到的文档的部分文本进行高亮呢？如果只匹配到很少结果或没有结果，可供选择的拼写建议是否可以作为默认请求的一部分返回呢？<br />从上一节可知，许多搜索功能可以通过发送单独的、可用的请求来调用多个请求处理器来实现。理想情况下，向Solr发送一个请求，就能得到所有预期的信息。这正是搜索组件存在的原因。<br /><strong>搜索组件是在搜索处理器生命周期内发生的可配置的处理步骤</strong>。搜索组件让搜索处理器将实现单个搜索请求的可重用的功能组合链接在一起。<br />搜索组件在solrconfig.xml中进行配置，具体做法参见第四章。为帮助你回顾之前内容，代码清单7.2演示了如何创建搜索处理器及一系列默认搜索组件。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627656557862-206f8969-8fb4-4962-a7c1-80c5d3c66fe0.png#height=948&id=M81kA&margin=%5Bobject%20Object%5D&name=image.png&originHeight=948&originWidth=2084&originalType=binary&ratio=1&size=870757&status=done&style=none&width=2084" alt="image.png"><br />代码清单7.2的内容都是Solr的默认配置，也就是说，它可以出现在任何地方，甚至可以脱离solrconfig.xml的上下文来看。对于理解如何配置搜索组件，启用新的搜索组件，以及理解搜索处理器的默认工作原理，这些都是有益的。<br /><strong>在第一个<searchComponent />标签中定义了两个属性：一个是name，另一个是class</strong>。name的值是query，class的值是solr.QueryComponent。该搜索组件只需定义一次，之后它可以被任意数量的请求处理器调用。在/select请求处理器中，你会看到一个arr元素，其属性name为components。该元素包含了搜索处理器定义的搜索组件列表。components部分的每一行对应一个搜索组件名称，既可以是默认的搜索组件，也可以是solrconfig.xml中定义的其他搜索组件。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627734296827-a4addec0-708e-41e1-a63c-199c915d5f6b.png#height=432&id=BXOMa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=432&originWidth=1840&originalType=binary&ratio=1&size=911247&status=done&style=none&width=1840" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627734343434-aafcea6a-9685-4d0f-ba80-62baac5d192b.png#height=730&id=H4qQM&margin=%5Bobject%20Object%5D&name=image.png&originHeight=730&originWidth=1840&originalType=binary&ratio=1&size=1773363&status=done&style=none&width=1840" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627734377237-f6641c85-7f92-4e1b-a6f7-d286dfcccd1c.png#height=666&id=UYWFT&margin=%5Bobject%20Object%5D&name=image.png&originHeight=666&originWidth=1842&originalType=binary&ratio=1&size=469020&status=done&style=none&width=1842" alt="image.png"><br />大多数搜索组件支持在他们的XML配置中设置响应的属性。如果希望对默认搜索组件执行此操作，请将搜索组件的名称默认设置为默认名称中的一种<strong>（”query”、”facet”、”mlt”、”highlight”、”stats”或”debug”）</strong>，另外，你还可以更改搜索组件的默认配置。<br />即使默认搜索组件没有在solrconfig.xml中明确定，它们也是默认存在的。在先前的代码清单就替换了默认配置。还可以通过添加first-components和last-components部分来插入搜索组件，这两部分表示分别在搜索处理器执行的组件列表的开始或结尾处插入附加组件，请参见第四章的4.2节来回顾如何在搜索处理器中添加搜索组件。<br />在搜索处理器的所有搜索组件中，查询组件是最重要的。因为它负责查询的初始化执行和搜索结果的特定格式响应，而且随后的其他搜索组件需要在它的基础上执行。查询组件使用查询解析器对搜索处理器请求的传入查询进行解析。Solr支持多种查询解析器，下一节会具体介绍。<br><a name="kzaPe"></a></p>
<h3 id="查询解析器"><a href="#查询解析器" class="headerlink" title="查询解析器"></a>查询解析器</h3><p>查询解析器将Lucene查询解释成搜索语法，以便查找所需的文档集。Solr支持多种查询解析器，还支持用户编写自己的查询解析器。正如搜索组件专门用于单个请求处理器（SearchHandler），查询解析器也是专门用于单个搜索组件（QueryComponent）的。图7.2展示了这种关系：SearchHandler执行一个QueryComponent，QueryComponent使用QueryParsers。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627736770380-412253f7-b40b-4282-b351-f5a5d8621f9a.png#height=1526&id=sGLPo&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1526&originWidth=1812&originalType=binary&ratio=1&size=1681808&status=done&style=none&width=1812" alt="image.png"><br />从图7.25可以看出，Solr提供了许多查询解析器，每个查询解析器实现为一个QParserPlugin类。如果已有的查询解析器无法实现你需要的查询解析功能，可以编写自己的QParserPlugin。Solr最常用的查询解析器是Lucene查询解析器（LuceneQParserPlugin）和eDisMax查询解析器（ExtendedDismaxQParserPlugin），详细参见7.4节和7.5节。图7.2的其他查询解析器将在7.6节介绍。在深入了解查询解析器的工作原理之前，先来了解一下各种查询解析器的使用方法，这有助于后续的学习。<br><a name="Z8ppQ"></a></p>
<h2 id="查询解析器的使用"><a href="#查询解析器的使用" class="headerlink" title="查询解析器的使用"></a>查询解析器的使用</h2><p>执行搜索时，<strong>QueryComponent根据查询解析器传递的值处理初始的用户查询（q参数）</strong>。上一节提到，<strong>LuceneQParserPlugin是Solr默认查询解析器</strong>。该默认查询解析器可以和内容以进行替换，也可以在同一个查询里与多个查询解析器组合使用。每个查询解析器执行各自的查询类型，支持对应的查询语法，对应不同的使用场景，具体参见7.4节至7.6节。本节介绍查询解析器的使用方法，包括如何更改默认查询解析器、如何组合查询解析器，以及如何配置查询解析器。<br><a name="fzhMH"></a></p>
<h3 id="指定查询解析器"><a href="#指定查询解析器" class="headerlink" title="指定查询解析器"></a>指定查询解析器</h3><p><strong>QueryComponent的默认查询解析器类型可以使用搜索请求中的defType参数进行修改</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?defType=edismax&amp;q=...</span><br><span class="line">/select?defType=term&amp;q=...</span><br></pre></td></tr></table></figure>
<p>修改默认查询解析器类型会对处理q参数的查询解析器进行更改，从而导致查询结果的变化。处理修改默认查询解析器类型之外，还可以使用Solr的特殊语法修改查询中使用的查询解析器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax&#125;hello world</span><br><span class="line">/select?q=&#123;!term&#125;hello</span><br><span class="line">/select?q=&#123;!edismax&#125;hello world OR &#123;!lucene&#125;title:&quot;my title&quot;</span><br></pre></td></tr></table></figure>
<p><strong>在第三个例子中，一个查询调用了两个不同的查询解析器（edismax和lucene）。与使用defType参数相比，这是在查询中指定查询解析器的优势所在。</strong>Solr包含了许多这样有用的查询解析器，本章会对它们做具体介绍。<br />{!…}语法通过行内定义查询解析器来调用Solr的某一项功能，这称之为局部参数，下一节会详细介绍。<br><a name="R3nYc"></a></p>
<h3 id="局部参数"><a href="#局部参数" class="headerlink" title="局部参数"></a>局部参数</h3><p><strong>局部参数为特定上下文提供定制化请求参数</strong>。<strong>通常的做法是在URL里向Solr提交请求参数，但有时也可以在查询内的特定部分指定一些参数</strong>。在一个查询中，局部参数可以只为特定查询解析器传递请求参数，而不是全局传递所有请求参数。上一节已经介绍过在查询内部修改查询解析器。局部参数不仅可以修改查询解析器，还可以修改任何请求参数。<br><a name="CJ4ho"></a></p>
<h4 id="局部参数语法"><a href="#局部参数语法" class="headerlink" title="局部参数语法"></a>局部参数语法</h4><p><strong>局部参数是一组用来表示请求参数的键值对集合，只限于当前上下文有效</strong>。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;!param1=value1 param2=value2 ... paramN=valueN&#125;</span><br></pre></td></tr></table></figure>
<p><strong>局部参数以 <strong><code>**&#123;!**</code></strong> 开头, 以 <strong><code>**&#125;**</code></strong> 结尾，包含以空格分隔的键值列表，其中键值由等号分隔</strong>。例如，</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=hello world&amp;defType=edismax&amp;qf=title^10 text&amp;q.op=AND</span><br></pre></td></tr></table></figure>
<p>等价于上面使用局部参数的查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!defType=edismax qf=&quot;title^10 text&quot; q.op=AND&#125;hello world</span><br></pre></td></tr></table></figure>
<p>这两个查询的本质区别在于：第一个例子中所有请求参数都是全局的，因此它们可以用于请求中的任何位置。在局部参数的例子中，defType、qf和q.op参数只在q参数范围内使用。如果需要在查询中多次使用不同配置的一个查询解析器，使用局部参数就可以做到。<br />我们可以在局部参数中指定defType参数，也可以使用type参数改写defType参数。从字面上看，defType表示默认类型，也就是说，它为所有查询制定了默认查询解析器类型。在局部参数中使用type参数可以修改特定上下文里的默认类型：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!type=edismax qf=&quot;title^10 text&quot; q.op=AND&#125;hello world</span><br></pre></td></tr></table></figure>
<p>type参数仅在局部参数中使用，如果要在顶层定义一种类型作为默认类型，则必须使用defType参数。与之相对，defType参数既可以用于请求层次，又可以用于局部参数。<br />由于一些局部参数值可能包含特殊字符（空格、引号等），所以需要用单引号或双引号将局部参数括起来，或者需要对特殊字符进行转义。上一条查询的qf参数中包含空格，所以使用双引号将它括起来，有关Solr的特殊字符转义的更多内容，详见7.4.1节末尾。<br />你可能已经注意，7.2.1节与本节中使用局部参数语法指定查询解析器的做法有细微差异。在本节中，我们指定{!type=edismax …}，之前我们使用了更简单的{!edismax}。如果只指定一个值，则type会被视为默认参数的键，所以这两种方式是有效的。如果关键词搜索不指定字段的话，它会在默认字段上搜索，也有可能在局部参数中传递值，将它用于type默认局部参数的键。因为局部参数的语法比较短，所以查询解析器的定义一般使用{!queryParserName}语法，其他局部参数则必须使用完整的{!key1=value1 key2=value2 …}语法。<br><a name="Hscic"></a></p>
<h4 id="参数值"><a href="#参数值" class="headerlink" title="参数值"></a>参数值</h4><p><strong>局部参数声明的值就是要传递给查询解析器的值</strong>。下面的局部参数声明中，向查询解析器传递的值是hello world。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax qf=&quot;title^10 text&quot;&#125;hello world</span><br></pre></td></tr></table></figure>
<p><strong>如果不在局部参数声明之后指定值的话，而在局部参数中定义参数值有时会更容易些</strong>。局部参数的特殊键v就是专门用于处理此种情况。因此，之前的查询可以另外定义为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax qf=&quot;title^10 text&quot; v=&quot;hello world&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的一点是，<strong>在局部参数中将query值放入v参数中时，只需留意特殊字符的转义</strong>。举例来说，如果要搜索带双引号的”hello world”，则以下两个查询时等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax qf=&quot;title^10 text&quot;&#125;&quot;hello world&quot;</span><br><span class="line">/select?q=&#123;!edismax qf=&quot;title^10 text&quot; v=&quot;\&quot;hello world\&quot;&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>在局部参数中明确定义查询值会带来一些复杂性，为了提升请求语法里的参数重用性，常常会用到参数解引用（parameter derefencing）。<br><a name="wOFT1"></a></p>
<h4 id="参数解引用"><a href="#参数解引用" class="headerlink" title="参数解引用"></a>参数解引用</h4><p><strong>参数解引用提供了查询中任意变量的替换方法</strong>。这个功能类似于SQL的参数查询，可以不使用查询语法来单独定义查询输入。引用参数的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax b=$userQuery&#125;&amp;userQuery=&quot;hello world&quot;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，userQuery参数作为用户定义的查询字段串变量传递给Solr，而Solr本身不能理解该参数。通过eDisMax查询解析器的传入值指定为解引用参数$userQuery，该值可以放在请求的其他位置。初次使用可能会觉得其发挥作用有限，但由于在solrconfig.xml中为每个请求处理器和查询组件使用默认值、追加至或常量定义了默认参数（详见第四章），你可以为自己的搜索应用指定一组请求参数集替换预设配置。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627812265815-29e18851-5aee-47a5-aa24-c9c7e4a880bc.png#height=504&id=jy333&margin=%5Bobject%20Object%5D&name=image.png&originHeight=504&originWidth=1850&originalType=binary&ratio=1&size=995225&status=done&style=none&width=1850" alt="image.png"><br />现在，你应该已经掌握了如何更改查询解析器，如何通过全局参数和局部参数向查询解析器传递值。接下来，在深入了解Solr查询解析器工作原理之前，接下来了解一下查询和过滤器的工作原理。<br><a name="O89aU"></a></p>
<h2 id="查询和过滤器"><a href="#查询和过滤器" class="headerlink" title="查询和过滤器"></a>查询和过滤器</h2><p>在介绍Solr查询解析器工作原理之前，了解用户查询和过滤器的工作原理有助于进一步学习。查询和过滤器的区别是什么，它们之间如何交互，以及最终如何影响搜索请求的性能和质量。<br /><strong>Solr的搜索主要由两个操作组成：找到与请求参数向匹配的文档；对这些文档进行排序，返回最相关的匹配文档</strong>。默认情况下，文档根据相关度进行排序。这意味着，找到匹配文档集之后，需要另一个操作来计算每个匹配文档的相关度得分。第三章介绍过，在Solr的倒排索引中匹配文档的查找过程和文档相关度得分的默认算法。<br><a name="mcqH1"></a></p>
<h3 id="fq和q参数"><a href="#fq和q参数" class="headerlink" title="fq和q参数"></a>fq和q参数</h3><p>为有效的查找匹配的文档和计算文档的相关度得分，Solr会用到两个参数：fq和q。<strong>fq参数表示过滤器查询，q参数表示查询</strong>。初看这两个参数可能不太好区分，因为相同的查询语法传递到这两个参数中，会返回相同数量的文档。因此，许多搜索请求中使用单个q参数。但是理解这两个参数之间的差异，可以更高效地进行搜索。<br><a name="1LKrH"></a></p>
<h4 id="相关度影响"><a href="#相关度影响" class="headerlink" title="相关度影响"></a>相关度影响</h4><p>那么，q参数和fq参数之间的区别是什么？<br /><strong>fq只有一个功能：对匹配的文档进行查询限定。</strong><br /><strong>q参数有两个功能：1、对匹配文档进行查询限定；2、提供相关度算法以及用于相关度评分的的词项列表。</strong><br />因此，q参数可视作一个特殊的过滤器，告诉Solr在相关度计算时应考虑哪些词项。鉴于这种差异，Solr使用者倾向于将用户输入的关键词放入q参数中（例如，keywords:”apache solr”），将机器生成的过滤器放入fq参数中（例如，category:”technology”）。<br><a name="K49G9"></a></p>
<h4 id="缓存和执行速度"><a href="#缓存和执行速度" class="headerlink" title="缓存和执行速度"></a>缓存和执行速度</h4><p>从主查询中分离出过滤器查询有两种用途。首先，过滤器查询通常在不包含任意关键词的搜索之间可以重复使用。因此，可以考虑将过滤器查询的结果缓存在过滤器缓存中，参见第四章4.4.2节的相关讨论。其次，<strong>由于相关度评分操作必须对文档匹配的查询q中每个词进行计算，那么将查询的一部分拆分成过滤器查询fq，fq参数这部分就无须进行额外的相关度计算</strong>。这样处理之后，查询中可作为过滤器的查询部分为相关度评分节省了许多工作。<br><a name="jkBRF"></a></p>
<h4 id="指定多个查询和过滤器"><a href="#指定多个查询和过滤器" class="headerlink" title="指定多个查询和过滤器"></a>指定多个查询和过滤器</h4><p>最后，查询和过滤器还需注意一点：Solr请求中可以添加任意多个fq参数，但只能包含一个q参数。例如，两个Solr查询 <code>q=keywords:solr&amp;fq=category:technology&amp;fq=year:2013</code> 与 <code>q=keywords:solr&amp;fq=category:technology AND year:2013</code> 会以同样的次序返回相同的文档。除了fq参数的缓存用途（每个fq参数可以独立缓存），使用多个fq参数在功能上等价于将这些参数组合成一个fq参数。以下小结中介绍的许多查询解析器都能使用q和fq参数，我们要考虑相关度和缓存影响，根据实际情况选择使用哪一种参数。<br><a name="j9IX4"></a></p>
<h4 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h4><p>由于查询和过滤器都会查找文档集并对他们进行操作，所以出现一个常见问题：查询和过滤器的执行顺序是怎样的？一些资料说首先执行过滤器，另外一些资料说首先执行查询，还有一些资料说查询和过滤器同时执行。到底情况如何？这个问题很复杂，需要视情况而定。<br />从技术层面上看，操作顺序如下：</p>
<ol>
<li><strong>在过滤器缓存才能中对每个fq参数进行查找。若存在，缓存的DocSet（文档集）将被返回，以OpenBitSet进行封装，其中索引里的每个文档对应一个二进制位（0或1），已表示该文档是否包含在过滤器中；</strong></li>
<li><strong>若没有在过滤器缓存中找到fq参数，但缓存已启用，那么该过滤器将对索引进行过滤，得到一个新的DocSet，这样就对其进行缓存；</strong></li>
<li><strong>所有过滤器的DocSet做交集（AND操作），得到一个DocSet；</strong></li>
<li><strong>q参数与过滤器的DocSet一起传入，作为一个Lucene查询进行搜索。执行查询时，Lucene对查询与组合过滤器进行大桥处理，将查询与过滤器对象统一成一个当前的内部ID（一个整数）。若查询结果和过滤器结果对象包含相同的ID，则手机该ID，处理过程包括为匹配的文档计算相关度得分；</strong></li>
<li><strong>如果文档包含任何后置过滤器（下一节将讨论），它们将作为收集过程的一部分，在查询与过滤器做了交集处理之后执行，仅作用与同事匹配组合查询和组合过滤器的文档。</strong></li>
</ol>
<p>根据这个解释，当缓存启用时，过滤器会先于主查询执行。查询和过滤器随后在手机过程（搭桥步骤）中同时执行，后置过滤器作为一种特殊的过滤器，在查询和过滤器已经找到同时匹配的文档之后使用。图7.3是示例搜索请求的过滤和过滤器处理的5个步骤。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1627823011312-fa47378b-0b1e-442a-bfc0-c468f0b8147a.png#height=1472&id=dHd64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1472&originWidth=1640&originalType=binary&ratio=1&size=1618671&status=done&style=none&width=1640" alt="image.png"><br />图7.3的每个编号步骤解释如下。<br />①、<strong>在过滤器缓存中查找过滤器；</strong><br />②、<strong>为缺失的过滤器对索引进行操作；</strong><br />③、<strong>将每个过滤器组合起来；</strong><br />④、<strong>使用大乔将查询与已经组合的过滤器进行再组合；</strong><br />⑤、<strong>使用执行成本最高的后置过滤器。</strong><br />最后一步返回最终的DocSet。如果需要对Solr搜索结果进行排序、检索及返回最相关的文档，则根据该查询（而非过滤器）计算相关度。<br />这看起来很复杂，确实如此。Solr很好的将这种复杂性隐藏了起来。不过，理解这个过程有助于对使用代价过高的过滤器进行性能调优。Solr提供更为精细的控制，能够制定哪些过滤器需要进行缓存，以及过滤器的执行顺序，包括在主查询之前、之后或同时进行。下一节将介绍如何通过缓存的开关来控制过滤器的执行情况，制定过滤器的执行顺序，决定是否在查询或其他一致性的过滤器之后执行。<br><a name="4IOCT"></a></p>
<h3 id="处理代价过高的过滤器"><a href="#处理代价过高的过滤器" class="headerlink" title="处理代价过高的过滤器"></a>处理代价过高的过滤器</h3><p>对过滤器进行缓存和绕过查询中过滤器部分的相关度处理，这样可以大大节省处理时间。然而，并非所有的过滤器情况都一样。如果尝试对搜索结果进行指定经纬度的地理半径过滤（参见第十五章的15.2节），由于都要涉及数学计算，因此这个过滤器的计算成本可能很高。此外，如果要为数百万个位置生成不同的过滤器的话，如此之多的半径过滤器可能很难进行缓存。在某些应用中可能需要生成许多唯一过滤器，例如，对唯一ID进行过滤，造成过滤器缓存过载，导致常用的过滤器会被删除或搜索预热时间过长。对于这种情况，Solr能控制哪些过滤器应该缓存，以及确定过滤器的执行顺序。<br><a name="x4OWL"></a></p>
<h4 id="关闭过滤器缓存"><a href="#关闭过滤器缓存" class="headerlink" title="关闭过滤器缓存"></a>关闭过滤器缓存</h4><p>在某些情况下，许多过滤器不需要进行缓存。由于过滤器数量有固定上线，如果最常用的过滤器使用处于缓存状态，则Solr实例的性能最佳。为防止不重要的过滤器造成缓存过载，可以使用以下语法关闭哪些过滤器。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fq=&#123;!cache=false&#125;id:123&amp;</span><br><span class="line">fq=&#123;!frange l=90 u=100 cache=false&#125;</span><br><span class="line">		scale(query(&#123;!v=&quot;content:(solr OR lucene)&quot;&#125;),0,100)</span><br></pre></td></tr></table></figure>
<p>上面的过滤器中，第一个是专门为每个文档生成的过滤器，因此该过滤器不适合放在过滤器缓存中。第二个过滤器也是专用的，尝试找到与查询content:(solr OR lucene)相关度最高的前10%的文档。通过获取该查询的相关度得分，将所有文档的得分按比例置于1到100区间，然后过滤出90到100区间之外的文档。由于该过滤器包含一个变量输入（query函数的输入），所以它适合关闭过滤。根据需要可以添加任意多个过滤器，fq参数支持过滤器缓存的开启和关闭。为每个fq参数指定cache=true或关闭局部参数缓存，cache默认为true。<br><a name="0ND75"></a></p>
<h4 id="改变过滤器执行顺序"><a href="#改变过滤器执行顺序" class="headerlink" title="改变过滤器执行顺序"></a>改变过滤器执行顺序</h4><p><strong>如果搜索请求包含多个过滤器，它们的执行顺序会对查询速度产生显著影响</strong>。<strong>从一般逻辑上讲，让结果集减少最多的过滤器应最先执行，因为面对文档越少，过滤器执行速度越快</strong>。同样道理，<strong>执行复杂计算的过滤器（例如，地理空间过滤器在一定半径范围内进行过滤）应考虑靠后执行</strong>。它们处理的文档越少，所耗费的计算资源也就相对少一些。对于需要花费更多代价的过滤器，通过定义该过滤器相关的执行成本，Solr允许它们靠后执行。提供过滤器成本的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fq=&#123;!cost=1&#125;category:techonology&amp;</span><br><span class="line">fq=&#123;!cost=2&#125;date:[NOW/DAY-1YEAR TP *]&amp;</span><br><span class="line">fq=&#123;!geofilt pt=37.773,-122.419 sfield=location d=50 cost=3&#125;&amp;</span><br><span class="line">fq=&#123;!frange l=90 u=100 cache=false cost=100&#125;</span><br><span class="line">		scale(query(&#123;!v=&quot;content:(solr OR lucene)&quot;&#125;),0,100)</span><br></pre></td></tr></table></figure>
<p><strong>执行成本越高的过滤器，它的执行应该越靠后</strong>。举例来说，category:techonology过滤器的执行成本最低，所以最先执行。该过滤器执行速度快，能在单个文档类别中显著减少文档数量，所以说它的执行成本最低。第二个过滤器（执行成本为2）将所有结果限定在去年的某一天。第三个过滤器是geofit操作，它计算出一个半径范围，将找到的结果限定该半径的50英里以内。这是最耗费资源的一个操作。第四个过滤器执行成本是100，由于数学计算导致耗费资源高，价值关键词输入具有很大的不确定性，因此指定其cost=100和cache=false。执行成本从3以下跳到100，这看起来有些奇怪。执行成本不一定是连续的，彼此之间只是相对顺序。大于或等于100的执行成本会启用Solr的一个特殊功能——后置过滤。<br><a name="yHmMl"></a></p>
<h4 id="后置过滤"><a href="#后置过滤" class="headerlink" title="后置过滤"></a>后置过滤</h4><p>在一些情况下，过滤器的执行成本会非常高，你会希望所有其他查询和过滤器执行之后再执行它。Solr提供了一种特殊类型的过滤器，称之为后置过滤器。此过滤器在查询和过滤相交处理之后使用。<br />回顾一下7.3.1节，查询与组合过滤器一起执行（搭桥处理），找到的每个文档与查询和过滤器都要匹配。后置过滤器是一种特殊过滤器，仅用于被调用的文档，让自行成本较低的过滤器先执行，对整体结果进行限定，执行成本较高的后置过滤器最后执行，需要处理的文档数量就少了很多。为过滤器定义cost参数，这也是将一个过滤器转换成后置过滤器的方法。执行成本大于或等于100的过滤器都被视为后置过滤器，使用后置过滤器接口执行。<br />Solr的后置过滤器不一定适用于所有类型的查询和过滤，它只适用于那些使用PostFilter接口的查询和过滤。FRange查询（参见7.6.3节）是具有后置过滤器功能的一种查询类型。另外，也可以编写插件来执行后置过滤器接口，在主查询和过滤器执行之后使用自定义的过滤器。<br />理解了查询器与过滤器的明确差异，以及相关度和性能考虑，接下来介绍Solr中最常用的查询解析器的工作原理。<br><a name="Wbq0u"></a></p>
<h2 id="默认查询分析器（Lucene查询解析器）"><a href="#默认查询分析器（Lucene查询解析器）" class="headerlink" title="默认查询分析器（Lucene查询解析器）"></a>默认查询分析器（Lucene查询解析器）</h2><p>本书目前介绍的大多数查询都使用了标准的Solr语法。这种语法是Solr最常见的，由默认查询解析器负责处理。Solr的默认查询解析器是Lucene查询解析器（LuceneQParserPlugin类实现），虽然它是Solr的特定类，但还是会在名称上让人感到疑惑。Lucene查询解析器全面支持Lucene语法及Solr的一些专用扩展。<br><a name="q1f1R"></a></p>
<h3 id="Lucene查询解析器语法"><a href="#Lucene查询解析器语法" class="headerlink" title="Lucene查询解析器语法"></a>Lucene查询解析器语法</h3><p>第三章以间接方式介绍了Lucene查询解析器的大部分语法，本节将全面介绍Lucene查询解析器支持的查询操作。需要注意，语法必须严格遵守执行。如果查询与语法不完全匹配，会抛出查询异常，导致请求失败。在第三章中你已经学到了一种语法，支持许多操作，诸如字段和<strong>非字段搜索、必备词项、可选词项、短语搜索、组合表达式、词项邻近度、排除词项、区间搜索、通配符搜索及布尔表达式</strong>。本节详细介绍每一种功能如何使用Lucene查询解析器的正确方法。<br><a name="kHaeM"></a></p>
<h4 id="字段搜索"><a href="#字段搜索" class="headerlink" title="字段搜索"></a>字段搜索</h4><p>在Solr搜索中搜索一个值时，一般来说是在特定字段上进行查找。字段搜索的语法是：字段名称加该字段的搜索表达式，中间用冒号分隔，举例如下。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">title:solr</span><br><span class="line">title:&quot;apache solr&quot; content:(search engine)</span><br></pre></td></tr></table></figure>
<p>尽管关键词搜索不明确指定字段的做法很常见，但需要注意，一般在定义的默认字段上进行关键词搜索。举例来说，如果content定义为默认字段（df=content），则以下两个查询时等价的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solr</span><br><span class="line">content:solr</span><br></pre></td></tr></table></figure>
<p>如果要在同一字段中搜索多个词项，使用组合表达式，在字段搜索中指定词项的范围：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title:(apache solr)</span><br></pre></td></tr></table></figure>
<p><a name="su1uL"></a></p>
<h4 id="必备词项"><a href="#必备词项" class="headerlink" title="必备词项"></a>必备词项</h4><p>为指定一个或多个词项必须出现，使用一元运算符 <code>+</code> 来链接词项。除非文档包含指定的词项，否则不予匹配。如果匹配的文档必须包含多个词项，使用二院运算符 <code>AND</code> 或 <code>&amp;&amp;</code> ，或者对每个词项都使用一元运算符 <code>+</code> 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+solr</span><br><span class="line">apache AND solr</span><br><span class="line">apache &amp;&amp; solr</span><br><span class="line">+apache +solr</span><br><span class="line">apache solr(假设设定的默认运算符是AND)</span><br></pre></td></tr></table></figure>
<p>如果默认运算符是AND(q.op=AND)，在没有指定其他运算符的情况下，每个词项都要求必备。由于每增加一个必备词项会进一步限制文档集中的结果总数，因此通过使用多个必备词项可以加快查询速度，从而进一步优化结果数量。<br><a name="mULUD"></a></p>
<h4 id="可选词项"><a href="#可选词项" class="headerlink" title="可选词项"></a>可选词项</h4><p>相比限制必备字段的做法，扩大匹配的文档数量则适用另外一些情况。默认运算符是OR（q.op=OR），除非有其他指定，否则每个表达式都是可选的。同样地，多个表达式之间使用二元运算符 <code>OR</code> 或 <code>||</code> ，这表示匹配的文档中至少包含其中一个词项。其语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">apache OR solr</span><br><span class="line">apche || solr</span><br><span class="line">apche solr (假设默认运算符是OR)</span><br></pre></td></tr></table></figure>
<p>值得注意的是，可选词项越多会导致文档集越大，OR运算比其他布尔运算的执行成本更高。对于关键词搜索，如果内容数量有限，而且希望以牺牲查准率为代价，确保能够返回一些结果（更高的查全率），那么一般会考虑使用OR作为默认运算符。由于多个可选词项的文档匹配通常会导致较高的相关度得分，使用OR作为默认运算符并根据相关度得分，使用OR作为默认运算符并更具相关度得分排序的话，仍然有可能获得搜索结果中最相关的那部分结果。不过，与要求匹配所有关键词不同的是，扩展查询会的到更多一些奇怪的匹配结果。<br><a name="I0u2H"></a></p>
<h4 id="短语搜索"><a href="#短语搜索" class="headerlink" title="短语搜索"></a>短语搜索</h4><p>如果想要匹配彼此相邻的多个词项，使用引号把它们括起来视为一个短语，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;apache solr&quot;</span><br><span class="line">&quot;apache softwore foundation&quot;</span><br></pre></td></tr></table></figure>
<p>此查询表达式不能保证匹配出完全一样的文本，被搜索字段可能包含对短语中词项进行修改的分析器。例如，搜索<code>Raining Cats and Dogs</code>，如果被搜索字段采用激进式词干提取，将and和with视为停用词进行移除，那么久有可能匹配到<code>rain cat with dog</code>。话虽如此，使用引号把词项引起来确实可以保证在连续的词项位置上找到 它们，最合理的特定短语不应该匹配出无关的短语。短语搜索适用于内容中特定字词和多词名称的处理。<br><a name="ROvrU"></a></p>
<h4 id="组合表达式"><a href="#组合表达式" class="headerlink" title="组合表达式"></a>组合表达式</h4><p>为处理任意复杂的布尔字句，Solr使用括号将查询表达式组合在一起，例如：<code>(apache AND (solr OR luecen) AND title:(apache solr))</code><br />组合表达式可以设置表达式的上下文，例如，指明在同一个字段中搜索多个单词。组合表达式可以任意嵌套。<br><a name="mGhxU"></a></p>
<h4 id="词项邻近度"><a href="#词项邻近度" class="headerlink" title="词项邻近度"></a>词项邻近度</h4><p>之前介绍过在引号中包含多个词项来定义短语搜索。实际上，这是词项相似度搜索的简化版本。通过添加波浪线和词项位置距离数，搜索位置相近的词项，不一定是彼此相邻的，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;apache solr&quot;~3</span><br><span class="line">&quot;open source software&quot;~5</span><br></pre></td></tr></table></figure>
<pre><code>你可以将短语搜索看成隐含距离为0的邻近搜索。以下两个查询时等价的：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;apache software foundation&quot;</span><br><span class="line">&quot;apache software foundation&quot;~~0</span><br></pre></td></tr></table></figure>
<pre><code>第二个查询的意图是查找与短语&quot;apache software foundation&quot;精确匹配的所有文档。该查询中词项之间的位移为0。同样的道理，如果指定位移数值为2，则查询会匹配`&quot;apache foundation software&quot;`、`&quot;software apache foundation&quot;`、`&quot;apache [otherWord] [otherWord2] software foundation&quot;` ，以及其他短语形式。这些短语可视作对原始短语`&quot;apache software foundation&quot;` 进行不超过两个位置的词项移动。参照第三章所讨论的，两个词项交换位置相当于移动了两个位置。&lt;br /&gt;指定足够大的有效临近值，可以匹配出文档中任意位置的词项，这与AND查询效果类似。假设文档包含的词项少于十万个，以下两个查询返回的文档数量相同。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apahce AND solr</span><br><span class="line">&quot;apache solr&quot;~100000</span><br></pre></td></tr></table></figure>
<pre><code>词项邻近度查询还有一个有趣的副作用是，在文档中词项越靠近，该临近查询对应的相关度得分越高。第一个查询不关心词项的位置，第二个查询虽然关心词项位置，但会超出文档中的词项数量范围，所以这两个查询的唯一差别是相关度得分及计算成本。词项之间的距离计算与布尔查找相比，花费成本更高。这两个查询返回的文档数量相同。使用临近权重可以提升词项更靠近的文档的相似度，这种方法将在第十六章进一步讨论。
</code></pre>
<p><a name="nXWF9"></a></p>
<h4 id="字符邻近"><a href="#字符邻近" class="headerlink" title="字符邻近"></a>字符邻近</h4><p>不仅可以在词项之间进行邻近搜索，还可以对词项中的字符进行基于编辑距离的搜索，找到拼写相似的词项。字符邻近搜索的语法与词项邻近搜索类似，由于字符邻近处理的是一个词项，所以不带引号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">solr~1</span><br><span class="line">supercalifragilisticexpialidocious~5</span><br></pre></td></tr></table></figure>
<pre><code>第一个查询找出词项solr的编辑距离为1的相关词项，如sol、sor、slr、salr、olr等。第二个查询为&quot;supercalifragilisticexpialidocious&quot;这样的一个更长更复杂的词找出编辑距离最大为5的相关词项。在一些搜索应用中，有结果返回好于没有结果，那么对相同词项使用编辑距离，这样就可以看看拼写相似的词项有没有结果返回。这样做可以帮助用户纠正拼写错误，当然还有更好的方法来机组恒拼写错误，随后第十章会具体介绍。
</code></pre>
<p><a name="X9nJj"></a></p>
<h4 id="排除词项"><a href="#排除词项" class="headerlink" title="排除词项"></a>排除词项</h4><p>有时我们需要从查询中明确排除特定词项。在表达式上使用一元运算符<code>-(减号)</code>或在表达式之间使用NOT布尔运算符来排除词项：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">solr -panel</span><br><span class="line">solr NOT panel</span><br><span class="line">solr AND NOT (panel OR electricity)</span><br><span class="line">-badterm</span><br></pre></td></tr></table></figure>
<pre><code>前三个例子的目的是将拼写错误solar(solar与太阳有关，一般指太阳能)导致的无关文档分离出来。正确的拼写应该是solr，一种搜索引擎。这些例子演示了`-`和NOT运算符的使用方法，第三个查询展示了如何在多个词项中使用NOT运算符。&lt;br /&gt;最后一个例子在Solr中执行纯粹的排除查询，其等价于`*:* -badterm`。该查询找到的文档不包含指定排除的表达式。
</code></pre>
<p><a name="ioSS5"></a></p>
<h4 id="区间搜索"><a href="#区间搜索" class="headerlink" title="区间搜索"></a>区间搜索</h4><p>有时候我们不希望查询表达式只匹配出一个值，而是希望匹配出值的整个区间。区间可以是数值区间（例如，价格区间在20美元到25美元之间）、日期区间（例如，去年修改的所有文档）或字符串区间（例如，app和apple之间的相似拼写，如appetite）。区间搜索能够找到指定的一组值，其语法为字段名加冒号再加一个方括号，如下所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number:[12.5 TO 100]</span><br><span class="line">date:[2013-11-04T10:05:00Z TO NOW-1DAY]</span><br><span class="line">string:[ape TO apple]</span><br></pre></td></tr></table></figure>
<pre><code>值得注意的是，日期格式必须使用祖鲁时间（Zulu time）格式或日期运算来指定，否则会抛出异常。如果没有指定区间的最大值和最小值，则需要对开区间的上限或下限使用通配符（*），如下所示。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">number:[* TO 0]</span><br><span class="line">number:[100 TO *]</span><br><span class="line">date:[NOW-1Year TO *]</span><br></pre></td></tr></table></figure>
<pre><code>更甚至，区间的上限和下限都可以打开：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">field:[* TO *]</span><br></pre></td></tr></table></figure>
<pre><code>如果区间搜索不限定区间的上限和下限，看起来会很愚蠢，但这样可以找到字段所有的取值和相关文档，这就好像字段的值存在于某两个值之间。在Solr的新近版本中冶可以通过`field:*`来定义。在这种情况下，区间搜索可能是矫枉过正了。&lt;br /&gt;使用方括号可有时间闭区间搜索，使用花括号可以实现开区间搜索：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number:&#123;0 TO 100&#125;</span><br></pre></td></tr></table></figure>
<pre><code>在这个例子中，如果字段类型是整数型，匹配到的最小值是1，最大值是99。方括号和花括号可以混合使用。以下两个查询在整数字段上结果相同：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">number:[1 TO 100&#125;</span><br><span class="line">number:&#123;0 TO 99]</span><br></pre></td></tr></table></figure>
<pre><code>Solr的区间搜索对许多操作都有用，例如，围绕特定地点绘制边界（latitude:[min TO ma] AND longitude:[min TO max]），或根据日期区间生成各种查询限定，等等。
</code></pre>
<p><a name="ZMH8x"></a></p>
<h4 id="通配符查询"><a href="#通配符查询" class="headerlink" title="通配符查询"></a>通配符查询</h4><p>有些情况下用户需要对Solr索引中单词或短语的变体进行匹配。对于用户输入的大多数关键词而言，词干提取这类技术让通配符搜索变得没那么必要了，然而对查找以特定字符集开头的文档或替代单个字符的操作，通配符搜索还是有用武之地。通配符查询的语法包括你要查找的文本，星号（*）表示一个或多个字符，问号（?）用户替换单个字符。在短语中可以加入任意多个通配符：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hel* w?rld, t??s is awe*m?</span><br></pre></td></tr></table></figure>
<pre><code>该短语会匹配出&quot;hello world, this is awesome&quot;。需要留意的是，Solr能够以非常快的速度进行关键词搜索，在倒排索引中直接对词项进行精确查找。在通配符搜索中，Solr必须扫描索引以查找更多与通配符查询相匹配的词项，这意味着，在通配符之前包含的字符越多，Solr能够扫描和在搜索中使用的词项就越少。要了解通配符的性能影响以及如何在搜索词项中较早使用通配符的优化方法，请参见第三章的第3.1.7节。
</code></pre>
<p><a name="aDJeb"></a></p>
<h4 id="权重表达式"><a href="#权重表达式" class="headerlink" title="权重表达式"></a>权重表达式</h4><p>权重表达式会在第十六章详细介绍，这里仅介绍其用法。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(apache^10 solr^100 is^0 awesome^1.234) AND (apache lucene^2.5)^10</span><br></pre></td></tr></table></figure>
<pre><code>如果表达式后面指定了一个插入号（^），无论是词项、短语还是组合表达式，都可以调整相关度权重。如果你清楚一些表达式比另一个表达式更重要，或者想为查询的不同方面分配一定量的相关度，权重表达式这是就能排上用场。
</code></pre>
<p><a name="xKdiR"></a></p>
<h4 id="特殊字符转义"><a href="#特殊字符转义" class="headerlink" title="特殊字符转义"></a>特殊字符转义</h4><p>Solr中有些字符是保留字符，也就是说，它们被当做查询语法进行解析，而不作为搜索词项。Solr的这些字符包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+ - &amp;&amp; || ~ ( ) &#123; &#125; [ ] ^ &#x27;&#x27; ~ * ? : /</span><br></pre></td></tr></table></figure>
<pre><code>在一些查询中需要将保留字符作为搜索词项的一部分。距离来说，尝试执行查询`q=content:(I&#39;m so happy!!!:))`，Solr会返回以下结果：&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2021/png/2668706/1629601116234-4794b9ed-e2eb-4968-a80b-ea2e5e67d0ea.png#clientId=ue57a8729-240a-4&amp;from=paste&amp;id=u57f7c1e5&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=244&amp;originWidth=1790&amp;originalType=binary&amp;ratio=1&amp;size=231355&amp;status=done&amp;style=none&amp;taskId=u91cbda17-76ea-485c-a093-973e2d35e43)&lt;br /&gt;如果需要搜索保留字符，必须将保留字符用引号括起来，或者使用反斜杠对其进行转义：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q=content:&quot;I&#x27;m so happy!!! :)&quot;</span><br><span class="line">q=content:(I\&#x27;m so happy\!\!\! \: \))</span><br></pre></td></tr></table></figure>
<pre><code>在第一个例子中，查询被引号括了起来，这表示将其全部视为一个短语，而不是单独的词项。这样做改变了查询的本意，可能不适合多数情况。将每个词项用引号单独括起来，也可以达到反斜杠的效果：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=content:(&quot;I&#x27;m&quot; &quot;so&quot; &quot;happy!!!&quot; &quot;:)&quot;)</span><br></pre></td></tr></table></figure>
<pre><code>如果要预处理所有词项，这样做没问题，但是这种做法带来的工作量很大，通常是不实际的。这种做法也无法处理双引号的情况，双引号也是转义符之一。因此，关键词中处理保留字符的推荐方法是，在传入Solr之前去除没有搜索价值的保留字符（也有可能被字段分析器处理过了），或者对它们依次使用反斜杠进行转义。&lt;br /&gt;正如你所见，Lucene查询解析器语法支持任意复杂的查询。不过，对许多用户而言，查询语法需要严格执行，任何特殊字符或形式不规范的查询都会导致返回异常，得不到期望的搜索结果。虽然Lucene解析器可以很好地处理以编程方式生成的查询，但对用户输入的关键词查询也不能做到完美解析，除非你自行对这些查询进行预处理。所幸，Solr提供了一个非常棒的查询解析器来处理用户输入的查询，即eDisMax查询解析器。
</code></pre>
<p><a name="BkwcI"></a></p>
<h2 id="7-5-处理用户查询（eDisMax查询解析器）"><a href="#7-5-处理用户查询（eDisMax查询解析器）" class="headerlink" title="7.5 处理用户查询（eDisMax查询解析器）"></a>7.5 处理用户查询（eDisMax查询解析器）</h2><p>正如上一节谈到，Lucene查询解析器语法支持创建任意复杂的布尔查询，但还有一些缺陷，它不是用户查询处理的理想解决方案。这里面最大的问题在于，Lucene查询解析器的语法要求严格，一旦破坏就会抛出异常。指望用户在输入关键词时能够理解Lucene查询语法并始终能输入完美的查询表达式，这显然是不合理的。这也意味着，Lucene查询解析器在许多搜索应用中对用户不够友好。<br />Lucene查询解析器的另一个缺点是，它不能默认搜索多个字段。df参数定义了查询解析器默认搜索哪个字段，但是如果想要以不同权重对多个字段进行搜索呢？例如，默认搜索title字段和content字段，其中title字段的相关度权重高一些。要使用Lucene解析器执行此操作，必须先对用户查询进行预处理。如果需要在单个字段中对所有关键词进行匹配。则将<code>q=some keywords</code>转换为<code>q=title:(some keywords) OR content:(some keywords)</code>。如果需要在单个字段中对所有关键词进行匹配，则将<code>q=some keywords</code>转换为<code>q=(title:some OR content:some) AND (title:keywords OR content:keywords)</code>。对大多数Solr开发人员来说，这样的查询与解析工作量过大。为了将用户查询直接传入Solr并优雅地进行处理，扩展的析取最大化查询解析器eDisMax应运而生。<br><a name="e5KD5"></a></p>
<h3 id="7-5-1-eDisMax查询解析器概述"><a href="#7-5-1-eDisMax查询解析器概述" class="headerlink" title="7.5.1 eDisMax查询解析器概述"></a>7.5.1 eDisMax查询解析器概述</h3><p>eDisMax查询解析器实际上是有Lucene查询解析器和DisMax查询解析器组成。DisMax查询解析器是eDisMax查询解析器的旧版本，它只接受关键词和少数几个基本的布尔运算，允许在多个字段中搜索关键词。因为DisMax查询解析器是eDisMax查询解析器的一个子集，所以不建议使用原始的DisMax查询解析器，推荐使用较新的扩展版本。因此，我们不会单独介绍DisMax查询解析器，它的大多数功能请参考eDisMax查询解析器的介绍。<br />虽然eDisMax查询解析器不是Solr的默认查询解析器，但它具有查询语法容错性，不像Lucene查询解析器那样严格。对于那些从用户那里直接获取关键词的搜索应用而言，eDisMax是最佳选择。下一节介绍eDisMax查询解析器的常见查询参数。<br><a name="c9u6D"></a></p>
<h3 id="7-5-2-eDisMax查询参数"><a href="#7-5-2-eDisMax查询参数" class="headerlink" title="7.5.2 eDisMax查询参数"></a>7.5.2 eDisMax查询参数</h3><p>eDisMax查询解析器支持Lucene查询解析器的所有查询语法。它们之间只有一个明显差异：eDisMax对无效的输入语法不会抛出异常，而是会将无效的输入作为文本字符串进行搜索。它还在语法解析上具有一定的容错性，支持特殊关键词，例如，可以理解小写转换后的AND和OR。这种灵活性和容错性让它比Lucene查询解析器更适合处理用户输入。<br><a name="rD0VJ"></a></p>
<h3 id="7-5-3-搜索多个字段"><a href="#7-5-3-搜索多个字段" class="headerlink" title="7.5.3 搜索多个字段"></a>7.5.3 搜索多个字段</h3><p>除了安全地处理用户输入文本和自由地解析查询语法，eDisMax查询解析器最有用的一个功能是对多个字段进行搜索。eDisMax查询解析器不是强制将所有可搜索的内容复制到一个默认的content字段，而是将每块内容放在各自的字段里，例如title字段、description字段和author字段。使用Lucene查询解析器的话，就必须为Solr in Action构造出如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(((title:solr) OR (description:solr) OR (author:solr)) AND((title: in) OR (description:in) OR (author:in)) AND ((title:action) OR (description:action) OR (author:action)))</span><br></pre></td></tr></table></figure>
<pre><code>相比之下，eDisMax查询解析器通过制定查询和查询字段（qf），更为轻松地实现对多个字段进行搜索：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=solr in action &amp;qf=title description author</span><br></pre></td></tr></table></figure>
<pre><code>这个示例查询构建起来很简单，它可以将内容分别放入多个字段中。eDisMax解析器能更好地组织数据，数据不被挤在一个字段里，而且还可以帮助每个字段分别进行idf统计，改进相关度评分。保持字段分开的另一个好处是，根据需要为每个字段赋予不同的权重：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=solr in action&amp;qf=title^1.5 description author^3</span><br></pre></td></tr></table></figure>
<pre><code>根据意愿可以在每个查询基础上调整权重。图7.4介绍了字段权重调整的搜索原理。&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2021/png/2668706/1629615692967-1c996146-cff8-4771-8970-b9528458a8d3.png#clientId=ue57a8729-240a-4&amp;from=paste&amp;id=ud25be914&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=720&amp;originWidth=1830&amp;originalType=binary&amp;ratio=1&amp;size=368336&amp;status=done&amp;style=none&amp;taskId=ucc67e9de-ad3d-4420-9e85-e8922243e8f)&lt;br /&gt;在图7.4里，每个关键词都在qf参数指定的每个字段上进行搜索。字段名称的字号大小表示字段调整后的相对相关度权重。除了调整字段权重外，还可以根据词项位置的邻近程度对内容调整权重，这与Lucene查询解析器一节介绍的词项邻近权重方法类似，下一节会具体介绍。
</code></pre>
<p><a name="ZtVEr"></a></p>
<h3 id="7-5-4-查询与短语的权重调整"><a href="#7-5-4-查询与短语的权重调整" class="headerlink" title="7.5.4 查询与短语的权重调整"></a>7.5.4 查询与短语的权重调整</h3><p>eDisMax查询解析器的一个重要功能是，调整彼此邻近的词项的相关度。使用Lucene查询解析器的典型查询，不管词项是否彼此邻近，或是否视为一个短语，所有词项的相关度都是相同的。eDisMax查询解析器的另一个功能是，对独立于用户主查询的函数进行任意地相关度调整。这些影响相关度的功能将在第十六章进一步介绍。这里只是简单介绍一下每个相关度影响参数，大致了解一下它们的作用。<br />​<br /><br><a name="Q4Lsb"></a></p>
<h4 id="pf（短语字段）、pf2和pf3参数"><a href="#pf（短语字段）、pf2和pf3参数" class="headerlink" title="pf（短语字段）、pf2和pf3参数"></a>pf（短语字段）、pf2和pf3参数</h4><p>pf参数用于调整那些q参数中所有词项彼此非常靠近的文档得分。pf参数与qf参数使用相同的格式，获取字段列表及可选的相应权重。eDisMax查询解析器尝试对q参数中所有词项进行短语查询，如果能在任何短语字段中找到确切的短语，则对匹配的文档调整相应的权重。<br />除了pf参数，eDisMax查询解析器还支持pf2和pf3参数。这些参数功能与pf参数类似，不过不需要q参数中所有词项，它们将词项分解为二元（pf2）或三元（pf3），只对包含少量词项的文档调整权重。在查询<code>Solr finds relevant documents</code>中，pf3参数会对包含短语<code>&quot;solr finds relevant&quot;</code>或<code>&quot;finds relevant documents&quot;</code>的文档调整权重，而pf2参数会对包含短语<code>&quot;solr finds&quot;</code>、<code>&quot;find relevant&quot;</code>、<code>&quot;relevant documents&quot;</code>的文档调整权重。<br><a name="jDuKm"></a></p>
<h4 id="ps（短语间隔）、ps2和ps3参数"><a href="#ps（短语间隔）、ps2和ps3参数" class="headerlink" title="ps（短语间隔）、ps2和ps3参数"></a>ps（短语间隔）、ps2和ps3参数</h4><p>使用pf参数时，你可能不希望查询中的所有词项作为一个精确的短语出现。使用ps（短语间隔）参数可以指定查询中的词项间隔位置界限，以此在短语字段上判断匹配情况。<br />eDisMax查询解析器还支持ps2和ps3参数，允许为pf2和pf3修改短语间隔值。若未指定ps2和ps3，则它们的默认值是ps参数。<br><a name="aNLsx"></a></p>
<h4 id="qs（查询短语间隔）参数"><a href="#qs（查询短语间隔）参数" class="headerlink" title="qs（查询短语间隔）参数"></a>qs（查询短语间隔）参数</h4><p>正如ps参数可以对短语字段（pf参数）上的短语匹配定义间距（编辑距离），qs参数对用户在主查询q参数上明确指定短语的处理方法类似。将qs参数视为重新定义要匹配的确切内容，可以将间距默认值0（词项彼此相邻）修改为更高的数值。<br><a name="ax4qo"></a></p>
<h4 id="tie（决胜局）参数"><a href="#tie（决胜局）参数" class="headerlink" title="tie（决胜局）参数"></a>tie（决胜局）参数</h4><p>当查询的词项与文档的多个字段匹配时，tie参数可以决定如何处理这种情况。为匹配到的每个字段的每个词项计算其相关度得分，默认情况下，每个文档中得分最高的字段用于该词项的相关度计算。这是析取的最大得分，也是该查询解析器的名“析取最大值”原因所在。这与Lucene查询解析器形成鲜明对比，Lucene查询解析器通常将每个字段的每个词项的相关度得分相加，计算出每个文档的综合相关度得分。<br />tie参数决定了最匹配的字段之外的其他字段的词项相关度得分有多少应该贡献给总体相关度得分。tie参数的默认值是0.0，这表示其他字段不贡献权重。如果tie参数值为1.0，则表示所有字段为总体相关度得分贡献他们的全部权重，就跟Lucene查询解析器中的做法一样了。在这种情况下，相关度评分使用的是析取和，而不是析取最大值。<br><a name="SMhOq"></a></p>
<h4 id="bq（提升查询）参数"><a href="#bq（提升查询）参数" class="headerlink" title="bq（提升查询）参数"></a>bq（提升查询）参数</h4><p>bq参数接受查询字符串，其包含在主查询q参数中，用来影响相关度得分。它不会修改匹配到的文档数，只修改文档返回的顺序。如果想为最近的文档提升相关度，可以在请求中添加以下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bq=date:[NOW/DAY-1YEAR TO NOW/DAY]</span><br></pre></td></tr></table></figure>
<pre><code>这将有效提升日期属于去年的所有文档的相关度得分。另外，还可以指定多个bq参数，在查询解析时针对不同字句分别进行提升。
</code></pre>
<p><a name="aAT5O"></a></p>
<h4 id="bf（提升函数）查询"><a href="#bf（提升函数）查询" class="headerlink" title="bf（提升函数）查询"></a>bf（提升函数）查询</h4><p>正如bq参数能能够通过另一个查询来提升主查询的相关度一样，bf参数能够通过函数查询来提升主查询的相关度。函数查询会在第十五章详细介绍，这里仅举例说明如何使用函数来提升日期较新的文档的相关度。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">recip(rord(date), 1, 1000, 1000)</span><br></pre></td></tr></table></figure>
<pre><code>bf参数介绍Solr支持的所有函数及其权重值。
</code></pre>
<p><a name="FVpWX"></a></p>
<h3 id="7-5-5-字段别名"><a href="#7-5-5-字段别名" class="headerlink" title="7.5.5 字段别名"></a>7.5.5 字段别名</h3><p>有时需要在Solr中使用内部字段名，这些字段名并不适合显示给用户。对于动态字段尤其如此，动态字段名可能类似title_t_en的这样，但是我们希望在搜索中使用对用户更友好的语法，例如，<code>title:&quot;some title&quot;</code>。eDisMax查询解析器为此提供了字段别名机制。<br />eDisMax查询中的字段别名通过在请求中添加参数<code>f.&#123;alias&#125;.qf=&#123;realfield&#125;</code>来实现。在上一个例子中，Solr查询如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?defType=edismax&amp;q=title:&quot;some title&quot;&amp;f.title.qf=title_t_en</span><br></pre></td></tr></table></figure>
<pre><code>在本例中，查询在title_t_en字段上执行，接下来它会被查询中出现的title字段替换。字段别名参数在默认的qf参数后使用，这意味着，可以将一个别名分别以不同的权重对应到多个内部字段。在请求中添加任意数量的别名也是可以的。距离来说，有以下字段：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">personFirstName , personLastName , itemName , companyName , cityName , stateName , postalCodeName</span><br></pre></td></tr></table></figure>
<pre><code>你可以使用一下Solr请求为用户简化查询：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/select?defType=edismax&amp;</span><br><span class="line">f.who.qf=personLastName^30 personFirstName^10&amp;</span><br><span class="line">f.what.qf=itemName company^5&amp;</span><br><span class="line">f.where.qf=city^10 stat^20 country^35 postalCode^30&amp;</span><br><span class="line">q=...</span><br></pre></td></tr></table></figure>
<pre><code>在这样的请求中，用户可以使用以下语法进行查询：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">who:(trey grainger) what:(solr) where:(dacatur, ga)</span><br></pre></td></tr></table></figure>
<pre><code>图7.5解释了该查询的关键词在Solr索引字段之上的三个字段别名who、what和where的对应情况。&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2021/png/2668706/1629636472307-8143f3c8-8555-4373-a337-31985535d10d.png#clientId=ue57a8729-240a-4&amp;from=paste&amp;id=ue248ab37&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=766&amp;originWidth=1842&amp;originalType=binary&amp;ratio=1&amp;size=469439&amp;status=done&amp;style=none&amp;taskId=uf614d6d4-d5a6-47c5-ae8e-c8e01ddd7c4)&lt;br /&gt;正如你所期望的，多别名字段的搜索类似于默认字段的搜索，其中每个查询词项被分布在别名定义的查询字段上。唯一的区别在于，可以为每个别名定义单独的qf字段，而不是为默认字段定义一个qf字段，而不是为默认字段定义一个qf参数。因此，与每个别名相关的查询部分会对字段列表进行搜索。&lt;br /&gt;图7.5解释了词项在多个字段上的分布情况，但这不代表字段权重与每个底层的查询相关。内部指定的查询通过eDisMax查询解析器自动扩展为以下完整的查询，在Solr索引上进行搜索。
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(</span><br><span class="line"> (</span><br><span class="line">	(personFirstName:trey^10.0 | personLastName:trey^30.0)</span><br><span class="line">  (personFirstName:grainger^10.0 | personLastName:grainger^30.0)</span><br><span class="line"> )(</span><br><span class="line"> (itemName:solr | company:solr^5.0)</span><br><span class="line"> )(</span><br><span class="line"> (state:decatur^20.0 | postalCode:decatur^30.0</span><br><span class="line"> 	| country:decatur^35.0 | city:decatur^10.0)</span><br><span class="line"> )(</span><br><span class="line"> (state:ga^20.0 | postalCode:ga^30.0</span><br><span class="line">  | country:ga^35.0 | city:ga^10.0)</span><br><span class="line"> )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<pre><code>将任意数量的字段别名映射为查询字段列表的做法，向用户提供了更简单的查询语法。这应该可以实现任意数量的字段权重规则，无须预先解析用户的查询或仅依赖于默认的qf参数。当然，如果不想向每个用户公开所有字段或别名，也是可以做到的。下一节介绍如何处理基于字段或别名的访问限制。
</code></pre>
<p><a name="OkJj9"></a></p>
<h3 id="7-5-6-可访问字段"><a href="#7-5-6-可访问字段" class="headerlink" title="7.5.6 可访问字段"></a>7.5.6 可访问字段</h3><p>在许多情况下，用户只能对默认字段以及（可能的）一小部分其他字段进行关键词搜索。由于有些内部字段可能会包含某些敏感信息（例如，用户ID或其他内部标识符），你可能不希望用户从Solr索引中踩出其他字段并查询它们。<br />虽然eDisMax查询解析器允许主查询q参数对任何字段进行搜索，但也可以使用uf（用户字段）参数加以限制。默认值是uf=*，允许用<code>field:expression</code>语法查询所有字段。如果要限制可用字段为单个title字段，指定uf=title即可。多字段的访问限制使用空格隔开:<code>uf=title city date</code>。如果要对用户禁用所有字段，则使用否定语法:<code>uf=-*</code>。如果要对指定字段列表之外的字段进行访问，则使用:<code>uf=* -hiddenField1 -hiddenField2</code>。<br />为确保完全控制用户查询，可以将uf参数与上一节介绍的字段别名参数结合使用。uf参数既接受真是字段，也接受别名，因此构造出如下查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/select?defType=edismax&amp;</span><br><span class="line">	df=text&amp;</span><br><span class="line">	f.who.qf=lastName^30 firstName^10&amp;</span><br><span class="line">	f.what.qf=itemName companyName^5&amp;</span><br><span class="line">  uf=who what&amp;</span><br><span class="line">  q=+who:(timothy potter) +what:(solr in action) +&quot;big data&quot;</span><br></pre></td></tr></table></figure>
<pre><code>在本例中，查询扩展为：timothy和potter在firstName和lastName字段上搜索，solr、in和action在itemName和companyName字段上搜索。该查询还在默认的text字段上搜索短语&quot;big data&quot;。如果查询尝试对who和what别名字段之外的其他字段进行搜索，将会不起作用。以下面的查询为例：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">q=+who:(timothy potter) +what:&quot;solr in action&quot; +firstName:timothy</span><br></pre></td></tr></table></figure>
<pre><code>在本例中，查询不会将firstName解析为字段，而是将默认的text字段中的完整短语作为关键词进行搜索。因此，除非文档包含&quot;fistName:timothy&quot;这个搜索文本，否则该查询没有结果返回，从而保护搜索引擎不访问未经授权的字段。如果需要在搜索应用中限制访问字段，eDisMax查询解析器应该能处理此类情况。
</code></pre>
<p><a name="REKDK"></a></p>
<h3 id="7-5-7-最小匹配"><a href="#7-5-7-最小匹配" class="headerlink" title="7.5.7 最小匹配"></a>7.5.7 最小匹配</h3><p>在布尔逻辑讨论中已经介绍过二元运算符：AND和OR。它们是Lucene对必须匹配和应该匹配的内部表示形式。查询表达式<code>hello AND world</code>可以改写为<code>+hello +world</code>，这表示hello和world都必须匹配。查询<code>big OR brown OR cow</code>表示big、brown或cow其中一个词必须匹配即可。然而，如果一个查询要匹配多个表达式，却又不在意匹配的是哪些表达式，又该如何实现呢？<br />eDisMax查询解析器通过mm（最小匹配）参数模糊了传统布尔逻辑的界限。为了让文档实现匹配，mm参数在查询中可以定义必须匹配的特定数量的词项或词项的百分比。这是对搜索应用的查准率与查询量进行操作的一个好工具。原因在于，它不要求所有词项必须匹配（默认运算符是AND），或仅需要其中一个词项匹配即可（默认运算符是OR）。<br />mm参数语法很丰富，很难一下子掌握。表7.2给出了各种mm参数值及相关说明。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1630203673593-0673fc3a-02e4-461c-9a94-6995f64ff8e5.png#clientId=ubf890281-bd20-4&from=paste&id=ude933fc5&margin=%5Bobject%20Object%5D&name=image.png&originHeight=904&originWidth=1896&originalType=binary&ratio=1&size=864891&status=done&style=none&taskId=u521605c0-c7f3-441f-9cf6-872a0c0e4ea" alt="image.png"><br />从表7.2可以看出，最小匹配语法规范内容非常丰富。它可以定义必须匹配的表达式数量（正整数）、遗漏的表达式数量（负整数）、必须匹配的表达式百分比（正百分数）以及遗漏的表达式百分比（福百分比）。要进一步控制的话，根据查询中现有的表达式数量，可以定义不同的最小匹配规则。<br />以下面的查询结构为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax mm=&quot;2&lt;50% 4&lt;-45%&quot; v=$example&#125;&amp;example=...</span><br></pre></td></tr></table></figure>
<pre><code>对于该查询，以下规则将对不同的实力参数值生效：&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2021/png/2668706/1630217330237-05395e8f-abe9-488b-99f6-c74d2478633d.png#clientId=ubf890281-bd20-4&amp;from=paste&amp;id=u959d30ea&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=418&amp;originWidth=1876&amp;originalType=binary&amp;ratio=1&amp;size=297071&amp;status=done&amp;style=none&amp;taskId=uf976ded6-20f9-45a8-919c-e78ec0e1e72)&lt;br /&gt;eDisMax查询解析器的最小匹配功能可以对包含多个关键词的查询进行匹配质量与数量的细粒度控制。图7.6从交集的角度解释了最小匹配阈值的作用。&lt;br /&gt;![image.png](https://cdn.nlark.com/yuque/0/2021/png/2668706/1630217420435-227eac27-b625-453e-a7b6-17981765e713.png#clientId=ubf890281-bd20-4&amp;from=paste&amp;id=u1be5ff12&amp;margin=%5Bobject%20Object%5D&amp;name=image.png&amp;originHeight=808&amp;originWidth=1866&amp;originalType=binary&amp;ratio=1&amp;size=529570&amp;status=done&amp;style=none&amp;taskId=u866f8110-8658-4b9a-8a11-d288c69caa5)&lt;br /&gt;在图7.6中，阴影是词项所代表的的圆的重合部分，表示与该查询中词项相匹配的文档交集。你会注意到，由于必须匹配40%的词项，也就是2/5，这个文氏图看起来和第三章介绍的传统布尔运算符AND和OR有所不同。AND运算符默认匹配所有的词项，OR运算符默认仅匹配一个词项，而通过mm参数可以实现更细致的匹配目的。mm参数变大通常会提高查准率，mm参数变小通常会提高查全率。有关查准率和查全率请参考第三章。&lt;br /&gt;不过，使用mm参数需要注意以下几点。首先，如果计算中确定不需要子句，例如，指定的多个表达式可以不包含在查询中，那么默认的布尔逻辑至少需要一个子句才能使用。这同样适用于上限。从本质上讲，小于1的最小匹配值永远不会被使用（因为至少需要一个），大于子句数量的最小匹配值也不会被使用（因为最大值是查询中的子句数量）。其次，处理5个子句时，80%和-20%产生的结果相同；处理四个子句时，80%表示需要3个子句，即80%约等于3/4，不超过4个，而-20%表示4个子句都需要，即-20%约等于0，缺失的不超过1个。eDisMax查询解析器的这些细微差别和整体表达能力使其成为查询工具包中的一个有力工具。
</code></pre>
<p><a name="do1XL"></a></p>
<h3 id="7-5-8-eDisMax的优缺点"><a href="#7-5-8-eDisMax的优缺点" class="headerlink" title="7.5.8 eDisMax的优缺点"></a>7.5.8 eDisMax的优缺点</h3><p>eDisMax查询解析器除了支持Lucene查询解析器的所有查询语法之外，还提供了许多附加功能。例如，多字段搜索、清理用户输入、字段别名与字段限制，以及通过许多查询修正来改进短语相关度和其他权重因素。eDisMax查询解析器包含了Lucene查询解析器的所有可用功能，你可能想要知道，为什么还有人会考虑直接使用Lucene查询解析器呢？<br />对于典型的面向用户的搜索应用，一般会使用eDisMax查询解析器。但是，在搜索应用程序层使用eDisMax查询解析器重新实现对用户有好的查询功能，这样做是无意义的，除非搜索应用中包含非常特殊的需求。对于搜索应用中所有Solr请求与的生成，如果不需要eDisMax查询解析器提供的附加功能，那么倾向于直接使用Lucene查询解析器。<br />使用eDisMax查询解析器也有一些缺点。首先是eDisMax查询解析器进行多字段搜索相关的处理问题。如果将所有词项放入一个字段并对其进行搜索，查询速度比使用eDisMax查询解析器在相同的查询表达式搜索多个字段要快。这不是Lucene查询解析器本身优于eDisMax查询解析器的一个方面，你仍然可以使用eDisMax查询解析器像Lucene查询解析器那样搜索单个字段。然而，eDisMax查询解析器可以轻松实现多字段搜索的同时，会为许多基于Solr的搜索应用带来额外的执行开销。<br />eDisMax查询解析器会对相关度评分的影响应予以考虑。Lucene查询解析器会考虑q参数中每个词项的相关度，不管该字段是否被搜索过。与之不同，eDisMax查询解析器仅考虑与词项匹配（默认情况下）的得分最高字段的相关度。以下面的两个查询为例来说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax qf=title content&#125;solr</span><br><span class="line">/select?q=title:solr OR content:solr</span><br></pre></td></tr></table></figure>
<pre><code>理论上，与这些查询匹配的文档的相关度得分相同，这是因为eDisMax查询要求Solr对两个字段都进行搜索。然而，从内部看，默认情况下eDisMax查询只使用与词项最匹配的字段的相关度。因此，如果solr的相关度在title字段更高，那么只有title字段的相关度会被用于相关度评分，同样道理也适用于content字段。Lucene查询解析器的处理方法不同，它会使用每个字段的得分来提高总体相关度，因此返回的相关度得分更复杂。eDisMax查询解析器的全称是`扩展的析取最大（Extended Disjunction Maximum）`，字面意思也就是说，仅使用默认的析取得分的最大值。现实中某些字段比其他字段重要，eDisMax解析器会对最佳字段中的文档与词项的匹配情况进行评分，而不对文档做整体评分。&lt;br /&gt;客观讲，在大多是情况中使用这种方式会得到较好的相关度得分，不过你还是需要了解一下eDisMax查询解析器的相关度处理方式。eDisMax查询解析器通过`tie`请求参数改变这种行为。如果指定`tie=0（默认值）`，就会得到相应的析取最大值。如果指定`tie=1.0`，就会得到Lucene查询解析器的析取值之和。&lt;br /&gt;另外，也可以将tie参数的取值介于0.0与1.0之间，若最匹配的字段拥有相关度权重的绝大多部分，则tie参数值越接近0.0.大多数Solr应用对相关度并不那么敏感，不会注意到评分间的这种细微差异。因此，对于大多数新建的搜索应用，推荐使用eDisMax查询解析器及其默认配置。如果相关度方面的需求非常关键，你需要关注所有这些细节，第十六章会介绍更复杂的方法来提升搜索应用的相关度。&lt;br /&gt;以上详细介绍了两种最常见的查询解析器：Lucene查询解析器和eDisMax查询解析器，Solr的其他解析器也有必要介绍一下，下一节简要介绍一些有趣的查询解析器。
</code></pre>
<p><a name="XoLn1"></a></p>
<h2 id="7-6-其他有用的查询解析器"><a href="#7-6-其他有用的查询解析器" class="headerlink" title="7.6 其他有用的查询解析器"></a>7.6 其他有用的查询解析器</h2><p>Solr提供了一些开箱即用的查询解析器，本节简要介绍其中一些有趣的查询解析器。<br><a name="xVmKW"></a></p>
<h3 id="7-6-1-字段查询解析器"><a href="#7-6-1-字段查询解析器" class="headerlink" title="7.6.1 字段查询解析器"></a>7.6.1 字段查询解析器</h3><p>字段查询解析器在指定字段中搜索词项或短语，可以使用该字段定义的任何文本分析方法。f参数指明要进行词项或短语搜索的字段，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;!field f=myfield&#125;hello world</span><br></pre></td></tr></table></figure>
<pre><code>该语法与使用Lucene查询解析器搜索短语`myfield:&quot;hello world&quot;`是等价的。
</code></pre>
<p><a name="Ziu47"></a></p>
<h3 id="7-6-2-词项查询解析器和原始查询解析器"><a href="#7-6-2-词项查询解析器和原始查询解析器" class="headerlink" title="7.6.2 词项查询解析器和原始查询解析器"></a>7.6.2 词项查询解析器和原始查询解析器</h3><p>词项查询解析器可以直接在Solr索引上进行检索，但不能使用字段上定义的文本分析方法。这是它与字段查询解析器的不同之处。词项查询解析器可以对分面搜索（详见第八章）返回的值进行过滤，或对Solr索引中直接提取的词项组件进行过滤。词项查询解析器的语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;!term f=mystemmedtextfield&#125;engin</span><br><span class="line">&#123;!term f=mystringfield&#125;Single Term with Space</span><br><span class="line">&#123;!term f=myintfield&#125;1.5</span><br></pre></td></tr></table></figure>
<p>在之前的例子中，搜索到的值是查询提问中该字段在Solr索引中词项的可读版本。与字段查询解析器一样，f参数指向的是搜索的字段。<br />Solr还提供一个类似的实现形式——原始查询解析器。词项查询解析器与原始查询解析的唯一区别是，原始查询解析器在Solr索引中搜索确切的词项，而词项查询解析器搜索该词项的可读版本。<br />在特定字段中，例如，为了提高搜索效率，数值字段的内部存储采用了trie结构，此时词项查询解析器接受数值的刻度版本（1.5），而原始查询解析器接受Solr索引中该字段内部存储的机读版本。整数字段的数值1可能表示Solr索引中诸如``#8;#0;#0;#1`此类的词项trie结构。以下两个查询都返回包含整数1的文档。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;!term f=myintfield&#125;1</span><br><span class="line">&#123;!term f=myintfield&#125;`#8;#0;#0;#1</span><br></pre></td></tr></table></figure>
<pre><code>你可能已经发现，原始查询解析器是一个高级功能，在典型的搜索应用中很少用到。Solr的美好之处在于，用户不必完全理解那些让搜索更加有效的内部数据结构，就可以执行高效的搜索。因此，建议选择使用词项查询解析器，而不是原始查询解析器。
</code></pre>
<p><a name="XyEgA"></a></p>
<h3 id="7-6-3-函数查询解析器和函数区间解析器"><a href="#7-6-3-函数查询解析器和函数区间解析器" class="headerlink" title="7.6.3 函数查询解析器和函数区间解析器"></a>7.6.3 函数查询解析器和函数区间解析器</h3><p>Solr更强大的一个功能是在搜索过程中使用函数查询来生成动态值。这样的动态计算值包括确定地理空间距离、执行数学计算、转换字符串或在自定义的函数插件中执行任意代码。函数可能相当复杂，我们会用几乎一章的篇幅来详细介绍这一内容丰富的主题。函数查询解析器和函数区间查询解析器会在第十五章介绍，到时还会介绍如何编写自定义的函数插件。<br><a name="dnP5k"></a></p>
<h3 id="7-6-4-嵌套查询和嵌套查询解析器"><a href="#7-6-4-嵌套查询和嵌套查询解析器" class="headerlink" title="7.6.4 嵌套查询和嵌套查询解析器"></a>7.6.4 嵌套查询和嵌套查询解析器</h3><p>截至目前，查询解析器是单独分别介绍的。我们已经了解如何为给定查询更改查询解析器，如果需要以特定方式将多个查询解析器组合起来，那该如何做呢？<br />Lucene查询解析器和eDisMax查询解析器的查询语法支持一个特殊的运算符<code>__query__</code>，利用它可以轻松地对默认的Lucene查询解析器中其他查询解析器进行替换。这使得我们可以在任意复杂的布尔表达式中组合不同的查询解析器。<br />执行嵌套查询的语法为<code>__query_:&quot;[QUERY]&quot;_</code>，其中<code>[QUERY]</code>表示在q或qf参数中单独使用的任意查询。以下面的查询为例说明：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=category:&#123;&quot;techology&quot; OR &quot;business&quot;&#125; AND _query_:&quot;&#123;!edismax qf=title^10 category^4 text&#125;&quot;solr lucene hadoop mahout&quot;</span><br></pre></td></tr></table></figure>
<pre><code>在本例中，eDisMax查询嵌套在Lucene查询解析器的一个请求中。完整的嵌套查询必须使用引号括起来，这表示查询内部的任何引号都必须使用反斜杠转义。应该注意的是，在许多情况下没有必要显式使用`_query_`语法，当Lucene查询解析器和eDisMax查询解析器发现查询中包含局部参数时，一般会推测出需要使用嵌套查询。越是复杂的查询，在`_query_`语法中需要使用嵌套查询的可能性就越大，这样做是为了确保按查询意图进行解析。&lt;br /&gt;除了特殊的`_query_`运算符之外，Solr还提供了一个内置的嵌套查询解析器，它也能处理嵌套查询。嵌套查询解析器的局部参数类型是query，通过以下方式调用：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=&#123;!edismax v=$nestedQuery&#125;</span><br></pre></td></tr></table></figure>
<pre><code>以这种方式定义查询时，可以使用任意查询进行替换，包括新的局部参数部分。如果要在solrconfig.xml中预先定义部分查询，之后动态地替换查询解析器类型和查询值的话，这种方式会非常有用：
</code></pre>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;1st name=&quot;defaults&quot;&gt;</span><br><span class="line">  <span class="tag">&lt;<span class="name">str</span> <span class="attr">name</span>=<span class="string">&quot;nestedQuery&quot;</span>&gt;</span>&#123;!func&#125;product(popularity, 0.25)</span><br><span class="line"><span class="tag">&lt;/<span class="name">str</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>在本例中，一个函数查询替换了solrconfig.xml中的查询，省去了创建查询时必须知道被替换的查询时什么类型这一步。当然，嵌套查询解析器可以与`_query_`嵌套查询语法结合起来使用，用来创建功能复杂的查询表达式，甚至可能是嵌套和替换了多个层级的查询。现实中往往大多数搜索应用都不会那么复杂。&lt;br /&gt;嵌套查询功能可以在主查询中将任意数量的子查询替换为不同的查询解析器，支持所有的布尔表达式，已确定如何组合这些查询。这一功能对通过函数提升查询的相关度非常有用，包括地理空间距离和相关度得分的其他函数计算。
</code></pre>
<p><a name="LXBMr"></a></p>
<h3 id="7-6-5-调整权重查询解析器"><a href="#7-6-5-调整权重查询解析器" class="headerlink" title="7.6.5 调整权重查询解析器"></a>7.6.5 调整权重查询解析器</h3><p>调整权重查询解析器允许根据一个文档是否与特定查询匹配，自行定义相关度的调整策略，无须过滤掉与要调整的查询不相匹配的文档。你可能还记得，q参数通常用于过滤搜索结果，并获得相关度评分中涉及的表达式的相似度情况。调整权重查询解析器可以提交相关度评分中所涉及的词项，而不将其作为过滤器使用。调整权重查询解析器的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;!boost b=1000&#125;shouldboost:true</span><br><span class="line">&#123;!boost b=log(popularity)&#125;category:trending</span><br><span class="line">&#123;!boost b=recip(ms(NOW,articledate),3.16e-11,1,1)&#125;category:news</span><br></pre></td></tr></table></figure>
<pre><code>这三个例子对那些与特定查询值匹配的文档的相关度进行调整，但不会将文档限制为仅与该查询值匹配的那些文档。另外也可以使用嵌套查询将调整权重查询解析器与其他查询解析器结合使用：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/select?q=_query_:&quot;&#123;!edismax qf=title content&#125;data science&quot; AND</span><br><span class="line">					_query_:&quot;&#123;!boost b=log(popularity)&#125;*:*&quot; AND</span><br><span class="line">          _query_:&quot;&#123;!boost b=recip(</span><br><span class="line">          ms(NOW,articledate),3,3.16e-11,1,1)&#125;category:news&quot;</span><br></pre></td></tr></table></figure>
<pre><code>该查询会搜索关键词`data science`，并根据流行度和发布时间（如果文档属于&quot;新闻&quot;类别）并对这些文档进行相关度调整。该查询的结果数量与直接搜索`data science`的结果数量相同，对子句的权重调整只是影响了文档的相关度。
</code></pre>
<p><a name="wtehl"></a></p>
<h3 id="7-6-6-前缀查询解析器"><a href="#7-6-6-前缀查询解析器" class="headerlink" title="7.6.6 前缀查询解析器"></a>7.6.6 前缀查询解析器</h3><p>前缀查询解析器可用于通配符查询，其语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;!prefix f=myfield&#125;engin</span><br></pre></td></tr></table></figure>
<pre><code>该查询等同于使用Lucene查询解析器搜索`myfield:engin*`，对`myfield`字段匹配诸如`engine、engineer和engineering`这样的词项。应该注意到，前缀是直接对Solr索引进行所搜，所以在与索引比对之前，不会对输入进行文本分析。采用词项的索引表示是为了避免前缀输入与要搜索的词项之间出现匹配失误。在大多数情况下，更好的做法是使用Lucene查询解析器或eDisMax查询解析器进行通配符搜索。
</code></pre>
<p><a name="VkHVY"></a></p>
<h3 id="7-6-7-空间查询解析器"><a href="#7-6-7-空间查询解析器" class="headerlink" title="7.6.7 空间查询解析器"></a>7.6.7 空间查询解析器</h3><p>Solr提供丰富的地理空间搜索功能，可以在索引好查询阶段定义位置或形状。通过给定一个具体点位可以过滤出特定范围内的文档。例如，给定旧金山的经纬度可以过滤出50公里半径内的所有文档。Solr提供两个用于空间查询的查询解析器，一个是空间框查询解析器（bbox），另一个是空间过滤查询解析器（geofit）。空间搜索是Solr的一个重要主题，第十五章会用大量篇幅介绍如何用好Solr的地理和空间搜索功能，空间查询解析器的有关内容也会在那里介绍。<br><a name="o9zU7"></a></p>
<h3 id="7-6-8-连接查询解析器"><a href="#7-6-8-连接查询解析器" class="headerlink" title="7.6.8 连接查询解析器"></a>7.6.8 连接查询解析器</h3><p>Solr的连接查询解析器可以执行子查询，实现文档集的伪连接。例如，要对查询进行限制，可以对不同的文档集执行子查询，并将原始查询结果集的限制条件设为文档只包含子查询文档中出现的字段值。Solr的连接功能还可以用于跨Solr内核的文档。连接功能与函数查询功能、空间搜索功能一样，它们都属于高级功能，第十五章会详细介绍，连接查询解析器也会在那里介绍。<br><a name="yKShF"></a></p>
<h3 id="7-6-9-分支查询解析器"><a href="#7-6-9-分支查询解析器" class="headerlink" title="7.6.9 分支查询解析器"></a>7.6.9 分支查询解析器</h3><p>分支查询解析器根据一些逻辑条件在多个查询/过滤器之间做出选择。它的操作与许多编程语言的分支语句类似。分支查询解析器的语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fq=&#123;!switch</span><br><span class="line">			case.day=&#x27;date:[NOW/DAY-1DAY TO *]&#x27;</span><br><span class="line">      case.week=&#x27;date:[NOW/DAY-7DAYS TO *]&#x27;</span><br><span class="line">      case.month=&#x27;date:[NOW/DAY-1MONTH TO *]&#x27;</span><br><span class="line">      case.year=&#x27;date:[NOW/DAY-1YEAR TO *]&#x27;</span><br><span class="line">      case.else=&#x27;*:*&#x27;</span><br><span class="line">      v=$withinLast&#125;</span><br></pre></td></tr></table></figure>
<pre><code>对于该过滤器，在Solr请求中可以传入以下参数，选择其中一只分支：`withinLast=day,withinLast=week,withinLast=month,withinLast=year`。`case.else`表示其他值将默认搜索全部文档。&lt;br /&gt;通过这个简单日期例子的启发，你可能会想出分支查询解析器的很多种用法。与分支语句匹配之后，可以选中任意值和执行查询。因此，通过分支查询解析器将业务规则映射到Solr查询，使用简单的请求参数轻松地调用该查询。
</code></pre>
<p><a name="SrNsH"></a></p>
<h3 id="7-6-10-外围查询解析器"><a href="#7-6-10-外围查询解析器" class="headerlink" title="7.6.10 外围查询解析器"></a>7.6.10 外围查询解析器</h3><p>为了较为全面地介绍Solr自带的查询解析器，这里介绍一个适用范围很小的查询解析器——外围查询解析器。该查询解析器是为跨度查询的充分使用而设计的，其用于掌握词项彼此之间的位置关系。外围查询解析器使用特殊的运算符n（有序）和w（无序），前面带一个1~99之间的整数值。举例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;!surround&#125;3w(solr,action)</span><br><span class="line">&#123;!surround&#125;5n(solr,action)</span><br><span class="line">&#123;!surround&#125;solr 3w action</span><br><span class="line">&#123;!surround&#125;solr 3n in 2w action</span><br></pre></td></tr></table></figure>
<pre><code>第一个例子在距离词项action 3个位置之内（无序、向前或向后）找到词项solr。第二个例子在距离词项action5个位置之内（action必须位于solr之后）找到solr。这两个例子都使用前缀表示，词项用圆括号括起来，运算符3w和5n作为函数，对输入值进行运算。&lt;br /&gt;第三个例子与第一个例子在逻辑上是一样的，但它没有使用前缀表示，而是使用中缀表示。第四个例子展示了多个词项的组合。第四个例子展示了多个词项的组合，其中词项solr必须出现在距离词项in之后的三个位置之内，而词项action必须出现在距离词项in之前或之后的两个位置之后。&lt;br /&gt;外围查询解析器还支持在前缀表示中使用`AND`和`OR`运算符，在中缀表示中使用`AND`、`OR`、`NOT`以及`()`运算符。虽然增加的邻近运算符似乎是Solr可用查询语法的有力补充，但外围查询解析器存在一个主要限制：它不支持文本分析。遗憾的是，与词项解析器类似，外围查询解析器不先执行执行字段类型定义的分析器，而是直接在Solr索引上检索词项。虽然外围查询解析器支持常见查询运算符，例如，字段权重(field^10)和通配符(hel*ow?rld)，但不支持文本分析，会降低它对典型的关键词搜索场景的可用性。除非在构造查询时你对字段所需的文本分析有着深度了解，并能重构该查询。
</code></pre>
<p><a name="bAFat"></a></p>
<h3 id="7-6-11-最大得分查询解析器"><a href="#7-6-11-最大得分查询解析器" class="headerlink" title="7.6.11 最大得分查询解析器"></a>7.6.11 最大得分查询解析器</h3><p>当使用Lucene查询解析器对查询进行评分时，每个词项和子句都会被评分，所有这些评分汇总在一起作为每个文档的总相关度得分。在某些情况下，使用多个子句的最大得分会比使用子句的总得分更好一些。<code>MaxScoreQParserPlugin</code>的使用方法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;!maxscore&#125;term1 term2 term3</span><br></pre></td></tr></table></figure>
<pre><code>在该查询中，每个文档都要对这三个词项进行评分，得分最高的词项（而不是三个词项的得分和）将被用作整体相关度得分。如果有需求，可以在同一个查询中结合使用两个查询解析器：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?q=one OR two OR _query_=&quot;&#123;!maxscore v=$maxQ&#125;&quot;&amp;maxQ=three OR fout OR five</span><br></pre></td></tr></table></figure>
<pre><code>与该查询匹配的所有文档的总得分由三部分组成：词项one的得分、词项two的得分与词项three、four、five中的最大得分。MaxScoreQParserPlugin扩展了LuceneQParserPlugin，因此，要对所有子句的得分求和或仅使用子句最大的分，选择其中一种查询解析器即可。
</code></pre>
<p><a name="Rk0L5"></a></p>
<h3 id="7-6-12-折叠查询解析器"><a href="#7-6-12-折叠查询解析器" class="headerlink" title="7.6.12 折叠查询解析器"></a>7.6.12 折叠查询解析器</h3><p>折叠查询解析器能够从搜索结果集中删除重复的文档（即这些文档包含指定字段中的相同值），这称之为字段折叠。在确保搜索结果多样性方面，它起到了重要作用。在Solr中，字段折叠有两种实现方法。第一种是使用功能更丰富的结果分组，将字段中具有相同值的文档合在一起，每一组返回文档的具体数量。第二种是使用折叠查询解析器，将相同字段值的文档和在一起。第十一章会详细介绍结果分组和字段折叠，你可以在11.7节中找到折叠查询解析器的具体用法。<br />至此，你已经了解了Solr的很多查询解析器。除了Solr的标准查询解析器之外，你应该也能以插件方式编写自己的查询解析器了。对于大多数用户而言，Solr的内置查询解析器其实已经能满足所有需求了。对查询解析器构造查询的方法有了充分理解之后，接下来介绍如何处理查询结果。<br><a name="i1mIr"></a></p>
<h2 id="7-7-返回搜索结果"><a href="#7-7-返回搜索结果" class="headerlink" title="7.7 返回搜索结果"></a>7.7 返回搜索结果</h2><p>本章已经介绍了如何构造查询来找到所需的匹配文档集，执行查询最终会返回一些结果。在许多情况下，我们希望返回一小部分文档并显示在页面上，每个文档包含一个或多个字段，还要根据相关度对这些文档进行排序。在另一些情况下，我们可能希望为每个字段返回动态计算值，或指定返回的最大文档数和偏移值，对完整的文档列表进行分页显示，或根据其他因素（非相关度）对文档进行排序。本节介绍搜索结果的排序、返回所需字段和文档数，以及为搜索应用选择适当的响应格式。<br><a name="pxfl7"></a></p>
<h3 id="7-7-1-选择响应格式"><a href="#7-7-1-选择响应格式" class="headerlink" title="7.7.1 选择响应格式"></a>7.7.1 选择响应格式</h3><p>为了便于阅读，本书的绝大数例子都选择JSON作为响应格式。之前你已经见过几个XML结果示例，这是Solr的默认响应格式。从Solr的角度看，什么样的响应格式并不重要。第四章介绍过，Solr可以返回XML、JSON、Ruby、Python、PHP、二进制Java等，甚至还可以返回自定义格式。<br />使用<code>wt(write type)</code>参数修改响应格式。Solr的wt参数的可用格式如表7.3所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634087696160-a6a19a23-c698-46be-a353-4c7eddb7df8f.png#clientId=u8e69c703-dcd1-4&from=paste&id=ua20f2a98&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1162&originalType=binary&ratio=1&size=207775&status=done&style=none&taskId=u714ea0fa-67b7-46e2-9f79-eec09e524b7" alt="image.png"><br />为了更改Solr的响应格式，需要在请求中将wt参数设置为表7.3中的某些值。代码清单7.4使用三种可用格式表示搜索结果。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634089010544-3b04c5ef-0fc5-4eeb-a4db-97ded2e0a15d.png#clientId=u8e69c703-dcd1-4&from=paste&id=u0cca63c1&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1606&originWidth=1158&originalType=binary&ratio=1&size=470988&status=done&style=none&taskId=u6f63d85d-771b-4265-aefa-f1c75a84fd1" alt="image.png"><br />正如你所见，使用wt请求参数就可以轻松地配置Solr的响应格式。如有需要，还可以为搜索应用编写专门的相应格式。为此，你需要编写一个继承Solr的<code>QueryResponseWriter</code>的类。然后，在solrconfig.xml文件中注册该响应读写器，如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">queryResponseWriter</span> <span class="attr">name</span>=<span class="string">&quot;myapp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;...MyAppResponseWriter&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>由于大多数现代编程语言都拥有简单易用的代码库来处理XML和Json格式，一般没必要花时间来编写一种响应格式，虽然这样做肯定是可以的。如果出于严格的安全考虑，例如，在返回给请求程序之前需要对结果进行加密，你可能会想到要自定义一个响应读写器。或者，需要对Solr返回的字段进行限制，下一届会讨论这个问题。
</code></pre>
<p><a name="NEV8I"></a></p>
<h3 id="7-7-2-选择返回字段"><a href="#7-7-2-选择返回字段" class="headerlink" title="7.7.2 选择返回字段"></a>7.7.2 选择返回字段</h3><p>在Solr的schema中指定字段是，其中有一个选项是指定该字段是否被存储。第五章床架创建索引时介绍过存储字段，它可以将原始文本与搜索结果一并返回。然而，并不是所有存储字段都必须在搜索结果中与文档一并返回。事实上，如果只需一小部分字段的话，可以通过限制搜索结果中要返回的字段数来加速搜索响应，这样做也会减少搜索结果的大小。<br><a name="rOjXN"></a></p>
<h4 id="返回存储字段"><a href="#返回存储字段" class="headerlink" title="返回存储字段"></a>返回存储字段</h4><p>你可能还记得第二章介绍过，字段列表<code>fl</code>参数，决定从Solr返回哪些字段。字段列表定义了搜索结果中每个文档需要返回的字段，字段之间以逗号分隔，使用语法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/select?...&amp;fl=id,name</span><br><span class="line">/select?...&amp;fl=*</span><br></pre></td></tr></table></figure>
<pre><code>第一个例子定义了每个文档需要返回id字段和name字段的存储值。如果要返回所有的存储字段，Solr提供了一个通配符选项`*`，这样就不需要明确指定字段了。除了返回存储字段之外，Solr还可以返回动态生成的值，作为文档的伪字段。
</code></pre>
<p><a name="bvK2T"></a></p>
<h4 id="返回动态值"><a href="#返回动态值" class="headerlink" title="返回动态值"></a>返回动态值</h4><p>除了存储字段之外，文档还包含一种可以了解该文档的有用信息，即相关度得分。通过请求特殊的的分字段可以返回每个文档的相关度得分：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?...&amp;fl=*,score</span><br></pre></td></tr></table></figure>
<pre><code>这个例子返回了文档的所有存储字段以及一个动态生成的相关度得分字段。由于相关度得分不属于存储字段，因此不能使用通配符自动返回，必须在请求中明确指定。当然，没有必要为了获得相关度得分而获取所有字段，只需要请求`score`字段即可。&lt;br /&gt;相关度仅仅是文档返回的各种动态值中的一种。Solr还有函数查询功能，它能计算出文档的各种有趣值。举例来说，返回一个数学函数的计算值作为一个伪字段：
</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?...&amp;fl=id,sum($&#123;IntegerField&#125;,10)</span><br></pre></td></tr></table></figure>
<p>这个例子对整数字段的值加10，将其作为文档的一个附加字段，与id字段一并返回。函数查询的动态计算能力将在第十五章中详细介绍。除了对字段值进行动态计算之外，还可以通过文档转换步骤，进一步返回文档的一些其他信息。<br><a name="gDiS7"></a></p>
<h4 id="文档转换"><a href="#文档转换" class="headerlink" title="文档转换"></a>文档转换</h4><p>有时在最终文档写入Solr响应结果之前，获取文档的一些额外信息也是有帮助的。这些额外信息可能包括相关度得分如何计算的可读解释、分布式搜索中文档所在的分片（有关分片与分布式搜索，参见第十二章），甚至是Lucene内部的文档编号。Solr使用文档变换器来返回此类信息。文档变换器的调用方法如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?...&amp;fl=*,[explain],[shard]</span><br></pre></td></tr></table></figure>
<p>该请求调用了两个特殊字段：<code>[explain]</code>、<code>[shard]</code>。这些方括号括起来的字段调用文档转换器会获得每个文档的一些原信息。表7.4是Solr内置的常用文档转换器列表。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634166011449-e3102f2f-b2b3-4353-a6b2-173c5fa35ca2.png#clientId=ua98dad8c-cd9e-4&from=paste&id=u772c5233&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=1156&originalType=binary&ratio=1&size=401661&status=done&style=none&taskId=ua7682c90-b240-4b86-bb76-92cf3686487" alt="image.png"><br /><code>[docid]</code>字段通常只用于需要与Lucene基础索引层面进行交互的情况，这对大多数Solr用户来说不常见。<code>[shard]</code>字段主要用于在分布式搜索中查找文档所在的Solr服务器和内核。<code>[explain]</code>字段（详见第十六章）有助于理解文档相关度得分的计算原理。<code>[value]</code>字段用于返回文档的静态值。<br />除了Solr内置文档的文档变换器，还可以通过集成<code>org.apache.solr.response.transform.DocTransformer</code>类，以插件方式编写自己的文档变换器，从而对整个文档进行操作与变换。要在Solr中使用自定义的文档变换器，需要创建一个工厂类来包装文档变换器，该工厂类继承自<code>org.apahce.solr.response.transform.TransformerFactory</code>，使用时需要在<code>solrconfig.xml</code>中注册这个变换工厂类：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">transformer</span> <span class="attr">name</span>=<span class="string">&quot;magic&quot;</span> <span class="attr">class</span>=<span class="string">&quot;magicTransformer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;yourSetting&quot;</span>&gt;</span>abracadabra<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">transformer</span>&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>虽然文档变换器不是Solr最常用的功能，但它在搜索结果的文档返回之前，为文档操作（字段添加、删除和编辑）提供了有用的扩展点。
</code></pre>
<p><a name="x3nFW"></a></p>
<h4 id="返回字段的别名"><a href="#返回字段的别名" class="headerlink" title="返回字段的别名"></a>返回字段的别名</h4><p>除了通过动态生成值返回伪字段之外，在搜索结果的文档返回之前，Solr还提供了一种字段重命名方法。字段别名在实际字段值之前出现，使用冒号分隔，在搜索结果中使用一个新字段来返回实际字段名（或动态生成值）的值，别名则作为新字段的名字，举例说明如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/select?...&amp;fl=id,$&#123;betterFieldName&#125;:$&#123;actualFieldName&#125;</span><br></pre></td></tr></table></figure>
<pre><code>如果想要使用`fieldname_t_is`（该文本字段既索引也存储）这样的动态字段来返回一个对用户更友好的字段名`fieldname`，字段别名方法在这里就能发挥作用了。只需在字段列表中指定`fieldname:fieldname_t_is`就可以了。另外，可以对任何字段以任何名称重命名。如果请求的字段是函数查询，提供比函数语法（默认字段名）更有理解含义的字段名称会变得更容易。&lt;br /&gt;第十五章会进一步介绍如何在文档中将函数作为字段使用。在返回文档时，特别是请求返回许多字段时，要确保一次不要检索太多文档，以保持Solr响应结果的大小合理。这通常要求一次返回较少数量的文档，根据需要在多个请求中对结果进行分页，下一节将介绍搜索结果页面。
</code></pre>
<p><a name="ZekBF"></a></p>
<h3 id="7-7-3-搜索结果分页"><a href="#7-7-3-搜索结果分页" class="headerlink" title="7.7.3 搜索结果分页"></a>7.7.3 搜索结果分页</h3><p>一个查询可能会匹配出许多文档（数百个甚至数十亿个），但是搜索结果通常以一页一页的方式显示给用户，每页包含一定数量的搜索结果。虽然Solr能够以毫秒级别对数百万或数十亿文档进行高效地查询匹配，但它并没有对返回大量文档的处理方面进行优化。Solr返回数十个或数百个文档不在话下，但从千位数量级开始，请求速度和吞吐速度会大幅降低。Solr的最佳实践是，首先只返回最相关的一页结果，然后允许用户继续翻阅后面的结果页面。这样做的话，Solr的每个请求都只返回有限数量的文档，避免了某个查询请求为了一次获取太多数据，占用资源并影响其他查询的执行速度的情况出现。<br />Solr的搜索结果分页需要用到第二章介绍过的两个请求参数：<code>start</code>和<code>rows</code>。<code>start</code>参数表示搜索结果返回的起始位置，从0开始。<code>rows</code>参数表示该请求返回的文档数。假设有<code>ID</code>编号从1~100000的十万个文档，代码清单7.5给出了<code>rows</code>参数和<code>start</code>参数的一些组合方式。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634230716862-cedd1370-795a-449c-9188-d104a0d1c736.png#clientId=ua98dad8c-cd9e-4&from=paste&id=uba2f40fa&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1202&originWidth=1162&originalType=binary&ratio=1&size=702552&status=done&style=none&taskId=uce6dc82f-1eed-43d4-bfe0-293da5daf39" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634230756431-8d5a68d1-9a1a-43de-a42f-922db0ca2b49.png#clientId=ua98dad8c-cd9e-4&from=paste&id=u14b0c141&margin=%5Bobject%20Object%5D&name=image.png&originHeight=910&originWidth=908&originalType=binary&ratio=1&size=451096&status=done&style=none&taskId=uc45b82fa-19b1-46ab-84fd-47ed40fd4d2" alt="image.png"><br />正如你所见，一次返回一页是非常直观的。要查看下一页结果，例如，查看页面1之后的页面2，将<code>rows</code>参数值与当前的<code>start</code>参数值相加，作为新的<code>start</code>参数值，继而重新执行查询，如查询1和查询2所示。查询3用来说明，可以指定搜索结果范围内的任何数字作为结果返回的起始位置。查询4用来说明，最后一页的结果数量可能比其他页面要少。因此，如果<code>start</code>参数的起始位置高于匹配的文档数量，则不会返回任何结果。各个搜索引擎的结果分页原理大体相同。<br />在这4个查询中，搜索结果都是按顺序排序的。事实上，你可能已经注意到，代码清单7.5使用了<code>sort</code>参数。Solr可以对很多东西进行排序，包括字段和动态计算值的组合。下一节介绍排序功能。<br><a name="I7au6"></a></p>
<h2 id="7-8-搜索结果排序"><a href="#7-8-搜索结果排序" class="headerlink" title="7.8 搜索结果排序"></a>7.8 搜索结果排序</h2><p>搜索得到的结果按一定的次序返回。默认按关键词相关度得分进行排序，除此之外，日期、词项、数字以及函数等都可以作为排序依据。本节介绍搜索结果的排序机制。<br><a name="Y1LnK"></a></p>
<h3 id="7-8-1-按字段排序"><a href="#7-8-1-按字段排序" class="headerlink" title="7.8.1 按字段排序"></a>7.8.1 按字段排序</h3><p>执行关键词搜索，搜索结果默认按照文档的相关度得分以降序方式(得分越高越靠前，得分越低越靠后)进行排序。对于得分相同的文档，根据搜索索引的Lucene内部文档编号以升序方式进行排序。如果没有相关度得分，则按Lucene内部文档编号进行排序。通过<code>sort</code>参数可以轻松地在搜索请求中修改默认排序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sort=$&#123;someField&#125; desc,$&#123;someOtherField&#125; asc</span><br><span class="line">sort=score desc, date desc</span><br><span class="line">sort=date desc, popularity desc, score desc</span><br></pre></td></tr></table></figure>
<pre><code>正如你所见，字段排序的语法是由字段和排序方向组成的列表，字段与排序方向之间使用空格分隔，各组字段之间使用逗号分隔。排序字段必须在schema.xml中标记为indexed=true，排序方向用asc`升序`、desc`降序`两种。&lt;br /&gt;按字段排序非常直观，不过有几种情况需要说明一下。首先，你应该知道排序是基于索引词项的次序。距离来说，使用字符串字段索引`1、2、3、10、20、30`，他们按照字典顺序的排序为`1、10、2、20、3、30`。&lt;br /&gt;此外，字段不同语言的排序也不尽相同，Solr内置了针对特定语言排序的分词过滤器，有关信息参见`http://wiki.apache.org/solr/UnicodeCollation`。如果字段使用这个分词过滤器，搜索结果的排序可能符合该语言规则，但与标准字符串字段的排序有所不同。&lt;br /&gt;需要注意一点：由于排序使用了索引词项，如果修改了索引词项，而非字段的原始值，那么排序结果可能对用户而言没有意义。如果在Solr中进行词项替换，那么最终的索引值（而非发送到Solr的原始值）将是排序的键。
</code></pre>
<p><a name="m5p05"></a></p>
<h4 id="对缺失值排序"><a href="#对缺失值排序" class="headerlink" title="对缺失值排序"></a>对缺失值排序</h4><p>还有一种特殊情况是，文档排序中<code>sort</code>字段缺少取值。由于Solr默认情况下不要求大多数字段都必备，因此很容易出现一个字段只有部分文档具备。在这种情况下，如果要对该字段进行排序，与查询相匹配但不包含该排序字段的文档应该出现在搜索结果列表中的前面还是后面呢？具体视情况而定，Solr为我们提供了<code>sortMissingLast</code>和<code>sortMissingFirst</code>两个属性，用来选择适合的字段排序行为，这两个属性在schema.xml中的定义如下所示：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;string&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.StrField&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">sortMissingLast</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">sortMissingFirst</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>如果`sortMissingLast`属性设置为`true`，则不管排序方向如何，不包含该字段值的所有文档都会显示在搜索结果排序列表的末尾。如果`sortMissingFirst`属性设置为`true`，则不管排序方向如何，不包含该字段值的所有文档都会显示在搜索结果排序列表的开头。`sortMissingLast`和`sortMissingFirst`的默认设置都是`false`。在默认设置下，缺少的文档会以升序显示在任何一种排序显示在任何一种排序方式的开头，或以降序方式显示在任何一种排序方式的末尾。
</code></pre>
<p><a name="karz8"></a></p>
<h4 id="排序的内存占用"><a href="#排序的内存占用" class="headerlink" title="排序的内存占用"></a>排序的内存占用</h4><p>关于排序的最后一点，排序是一个非常占用内存的过程。为了对文档进行排序，Solr使用Lucene的字段缓存，在首次请求排序时将字段的所有唯一值加载到内存中，可能也存在其他原因导致缓存已经加载过了。这意味着，要对包含数百万个唯一词项的索引进行排序的话，每个字排序字段都会消耗大量内存。首次请求字段排序时需要构建内存结构，这可能导致初始排序查询变慢。这里不是说不应该对文档进行排序，而是需要意识到，需要有足够的内存来执行排序。此外，你可能希望通过实例搜索预热Solr实例来实现缓存加载，有关内容参见第四章。如果能使用不同的数据建模，则有可能避免对包含数百万个唯一词项的字段进行排序。<br><a name="A4Mlz"></a></p>
<h3 id="7-8-2-按函数排序"><a href="#7-8-2-按函数排序" class="headerlink" title="7.8.2 按函数排序"></a>7.8.2 按函数排序</h3><p>除了按字段排序，还可以根据函数查询的计算值进行排序。举例来说，根据距离某一点的地理距离（使用<code>geodist</code>函数）或文档的流行度与新旧程度（对流行度字段和日期字段使用数学函数）进行排序。甚至还可以将字段排序与函数排序结合起来使用，产生有趣的排序效果。第十五章会详细介绍函数查询，你可以在15.1.4节中找到如何进行函数排序的详细讲解。<br><a name="OiVwD"></a></p>
<h3 id="7-8-3-模糊排序"><a href="#7-8-3-模糊排序" class="headerlink" title="7.8.3 模糊排序"></a>7.8.3 模糊排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">模糊排序-对给定的区间数字①集合进行排序</span><br><span class="line">① 区间数字：该数字不具有一个明确的值，而是一个数字的区间范围，即I∈[a,b]。</span><br><span class="line">注：不建议花精力在此，其一网上并无相关信息，其次应用范围不大。</span><br></pre></td></tr></table></figure>
<p>排序通常被认为是一个全有或全无的操作。通过Solr的相关度计算可以实现所谓的模糊排序。如果将相关度计算视为多因素的综合体（这里的多因素通常指关键词搜索，不过也可以搜索其他内容），那么通过对其进行提升，可以区分出查询中每个因素的权重。<br />将一个查询元素的重要性相较于另一个查询元素提升数千倍，这是提升相关度得分的一种直接手段。这样做的话，首先会匹配第一个查询元素的文档，其次才会匹配第二个查询元素。如果将相关度得分之间的差异控制在一定范围内，则可以进行模糊排序。相关度得分的两部分通常一个高于另一个，有时候也会存在一些重合，导致得分较低的文档的相关度高于得分较低的文档。<br />模糊排序在大多数情况下更多的是一种相关度考虑，它有很多种处理方法。第十一章会介绍如何根据单独的选择标准返回一定数量的文档，第十五章和第十六章会介绍如何使用函数查询来影响文档的排序，以期最大限度地改进搜索应用的相关度。在许多情况下，应该根据相关度进行排序，构造相应的查询，已返回文档以期望的次序进行排序，而不是使用之前章节讨论的字段硬排序技术。虽然有时两者都可以排序，但应视搜索应用的需求而定。<br><a name="eclg8"></a></p>
<h2 id="7-9-调试查询结果"><a href="#7-9-调试查询结果" class="headerlink" title="7.9 调试查询结果"></a>7.9 调试查询结果</h2><p>及时你拥有丰富的Solr使用经验，仍有可能对有些搜索结果感到困惑。例如，查询解析问题导致产生多种搜索结果、相关度得分有时不显示、查询执行时间变长等。所幸，搜索处理器附带的特殊搜索组件<code>DebugComponent</code>可以解决以上问题。<br><a name="yGkZB"></a></p>
<h3 id="7-9-1-返回调试信息"><a href="#7-9-1-返回调试信息" class="headerlink" title="7.9.1 返回调试信息"></a>7.9.1 返回调试信息</h3><p>在Solr请求期间，要了解查询背后发生了什么，最简单的方法是开启调试选项，在请求中传入<code>debug=true</code>，激活<code>DebuuComponent</code>，返回信息类似于代码清单7.6所示的信息。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1634389410557-c1feb6ec-dca8-4e4c-9045-ba8f46a29581.png#clientId=ua98dad8c-cd9e-4&from=paste&id=ufe73da17&margin=%5Bobject%20Object%5D&name=image.png&originHeight=768&originWidth=1154&originalType=binary&ratio=1&size=700649&status=done&style=none&taskId=u42600954-4ff8-4f2a-8373-1068217dc5e" alt="image.png"><br />从代码清单7.6中可以看出，<code>DebugComponent</code>返回了一些有用信息：① 原始查询<code>rawquerystring</code>,② 解析后的查询在Lucene对象中的表示<code>parsequery</code>，③ 解析后的查询可读版本<code>parsequery_toString</code>，④ 文档相关度得分的数学计算过程<code>explain</code>，⑤ 查询中使用的默认查询解析器<code>QParse</code>，⑥ 每个<code>searchComponent</code>处理所花费时间<code>timing</code>。<br />此外，在调试参数中还可以进一步指定返回的具体内容。与指定<code>debug=true</code>不同，如果指定<code>debug=query</code>，则只返回与查询解析器有关的部分调试信息。如果指定<code>debug=results</code>，则只返回相关度得分计算的解释内容。第十六章会进一步介绍如何对相关度得分进行调试。如果指定<code>debug=timing</code>，则只返回每个<code>searchComponent</code>处理所花费的时间，这对调试执行较慢的请求很有帮助。通过调用<code>DebugComponent</code>的不同方面，你可以更好地了解Solr请求的解析原理以及查询中哪些部分耗时最多，这将有助于更有效地构建Solr请求。<br><a name="vWU0R"></a></p>
<h2 id="7-10-本章小结"><a href="#7-10-本章小结" class="headerlink" title="7.10 本章小结"></a>7.10 本章小结</h2><p>本章回顾了第四章中有关执行查询的请求处理流程。进行搜索时，<code>SearchHandler</code>处理搜索请求，调用一个或多个<code>SearchComponent</code>。<code>QueryComponent</code>是最重要的一种<code>SearchComponent</code>，负责执行主查询。本章套；讨论了Solr如何处理查询和过滤器，介绍了Solr的各种查询器解析器及其语法。特别地，在处理用户查询和多个字段搜索方面，对比分析了<code>eDisMax</code>查询解析器与默认的Lucene查询解析器的优缺点。本章还介绍了如何提交查询、返回字段、对结果进行排序和分页、使用局部参数和引用参数、使用<code>DebugComponent</code>调试查询问题等内容。本章还演示了在同一查询中如何结合使用多个查询解析器，实现了在一个请求中使用全部查询功能。<br />至此，你应该对执行查询、处理和调试搜索结果有了较为充分的了解。返回搜索结果集的同时，获取搜索结果集和有关汇总信息，这将有助于更好地理解搜索结果并对其进行优化。Solr的分面功能可以实现这一目的，这是下一章要介绍的主题。</p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="weibo share-sns" href="javascript:;" data-type="weibo">
            <i class="ri-weibo-fill"></i>
          </a>
          <a class="weixin share-sns wxFab" href="javascript:;" data-type="weixin">
            <i class="ri-wechat-fill"></i>
          </a>
          <a class="qq share-sns" href="javascript:;" data-type="qq">
            <i class="ri-qq-fill"></i>
          </a>
          <a class="douban share-sns" href="javascript:;" data-type="douban">
            <i class="ri-douban-line"></i>
          </a>
          <!-- <a class="qzone share-sns" href="javascript:;" data-type="qzone">
            <i class="icon icon-qzone"></i>
          </a> -->
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%B8%83%E7%AB%A0-Solr%E6%9F%A5%E8%AF%A2%E4%B8%8E%E6%90%9C%E7%B4%A2%E7%BB%93%E6%9E%9C/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AB%E7%AB%A0-Solr%E5%88%86%E9%9D%A2%E6%9F%A5%E8%AF%A2/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Solr手册-第八章 Solr分面查询
          
        </div>
      </a>
    
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AD%E7%AB%A0-Solr%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Solr手册-第六章 Solr文本分析</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="J`Han&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HomePage</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Document</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Solr/">Solr</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>如果觉得对您有帮助，来个打赏吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>