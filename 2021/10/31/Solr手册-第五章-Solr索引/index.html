<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title>Solr手册-第五章 Solr索引 |  J`Han&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      <section class="outer">
  <article
  id="post-Solr手册-第五章-Solr索引"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h1 class="article-title sea-center" style="border-left:0" itemprop="name">
  Solr手册-第五章 Solr索引
</h1>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/" class="article-date">
  <time datetime="2021-10-31T02:17:02.000Z" itemprop="datePublished">2021-10-31</time>
</a>   
<div class="word_count">
    <span class="post-time">
        <span class="post-meta-item-icon">
            <i class="ri-quill-pen-line"></i>
            <span class="post-meta-item-text"> Word count:</span>
            <span class="post-count">20.4k</span>
        </span>
    </span>

    <span class="post-time">
        &nbsp; | &nbsp;
        <span class="post-meta-item-icon">
            <i class="ri-book-open-line"></i>
            <span class="post-meta-item-text"> Reading time≈</span>
            <span class="post-count">71 min</span>
        </span>
    </span>
</div>
 
    </div>
      
    <div class="tocbot"></div>




  
    <div class="article-entry" itemprop="articleBody">
       
  <meta name="referrer" content="no-referrer"/>

<p><a name="z7b4D"></a></p>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>本手册源自《Solr in action》，并修正了部分翻译和说辞，并引入了部分自身的理解，即基于原书进行了二次整理翻译，并不持有任何版权。<br /><br><a target="_blank" rel="noopener" href='https://livebook.manning.com/book/solr-in-action/about-this-book/'>《Solr in action》英文书籍链接(Original Book Link)</a><br /><br><a target="_blank" rel="noopener" href='https://www.manning.com/'>《Solr in action》英文书籍版权归Manning出版社</a><br /><br><a target="_blank" rel="noopener" href='https://www.phei.com.cn/'>《Solr in action》中文译版版权归电子工业出版社</a><br><a name="EYV54"></a></p>
<h1 id="修整说明"><a href="#修整说明" class="headerlink" title="修整说明"></a>修整说明</h1><p>本篇文章于2021/10/31日上传GitHub，如遇版权问题请邮件<code>privatejhan@gmail.com</code>。<span id="more"></span></p>
<h1 id="Chapter-Five-创建索引"><a href="#Chapter-Five-创建索引" class="headerlink" title="Chapter Five 创建索引"></a>Chapter Five 创建索引</h1><p>本章要点</p>
<ul>
<li>为待索引的文档设计模式</li>
<li>在schema.xml中定义字段和字段类型</li>
<li>对结构化数据使用字段类型</li>
<li>处理更新请求、提交和原子更新</li>
<li>在solrconfig.xml中管理索引配置</li>
</ul>
<p>第3章介绍了Solr如何使用倒排索引查找文档。倒排索引最简单的形式是由词项字段和出现每个词项的文档列表两部分构成。Solr使用倒排索引将用户查询中的词项与文档中出现的词项进行匹配。本章介绍Solr如何对文档创建索引，而创建索引中一个重要工作是文本分析。本章具体讲解索引的创建过程和非文本字段，下一章将详细讨论文本分析。<br />学完本章，你将了解如何在Solr中对文档进行索引，掌握字段、字段类型和模式设计等核心概念。如果你已经将第2张介绍的Solr示例服务器运行在本地计算机上，那么这一张内容掌握起来会容易一些。当然，如果没有运行Solr的话，先阅读本章，然后再动手操作，你也能搞清楚大多数示例。<br><a name="1Dfnp"></a></p>
<h2 id="微博搜索应用示例"><a href="#微博搜索应用示例" class="headerlink" title="微博搜索应用示例"></a>微博搜索应用示例</h2><p>贯穿本章，<strong>我们将通过索引创建与文本分析，设计并实现一个针对流行社交媒体网络的微博搜索</strong>。你可以把这里的微博当做成一个代名词，指代那些较短的、非正式消息及人们在社交网络上相互分享的内容。微博示例来自Twitter的推文、Facebook的帖子、Foursquare的签到信息等。<strong>本章将介绍如何使用Solr内置工具对微博内容进行文本分析</strong>。首先，让我们看看这些<strong>要处理的文档</strong>和<strong>用户可能想要搜索它们的方式</strong>。<br><a name="h5H4d"></a></p>
<h3 id="面向搜索的内容表示"><a href="#面向搜索的内容表示" class="headerlink" title="面向搜索的内容表示"></a>面向搜索的内容表示</h3><p>首先，表5.1列举了一条虚构的微博应有的一些字段，接下来我们会使用这些内容来学习在Solr中如何索引文档。即便你对社交媒体内容分析不感兴趣，那也没关系，这个示例的学习经验适用于大多数搜索应用。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623740179018-bdc92e5a-0e73-4e03-8fdc-6a5477a43f77.png#height=618&id=uic0j&margin=%5Bobject%20Object%5D&name=image.png&originHeight=618&originWidth=1218&originalType=binary&ratio=1&size=506727&status=done&style=none&width=1218" alt="image.png"><br /><strong>Solr索引中的每个文档由字段组成，每个字段拥有具体类型，字段类型决定了文档将如何被存储、搜索与分析</strong>。在表5.1中，微博文档有8个字段。从搜索角度看，我们认为 <code>screen_name</code> 、 <code>type</code> 、 <code>timestamp</code> 、 <code>lang</code> 和 <code>text</code> 这些字段是不错的索引字段备选，它们包含了典型用户在构造查询时用到的内容。例如，一个用户可能想要查看 <code>**特定用户**``(screen_name:thelabdude)</code> 在 <code>**特定时间**``(timestamp:[2012-05-01T00:00Z TO *])</code> 以后的所有 <code>**英文微博**``(lang:en)</code> 。<br />当然，也可以索引所有的字段。但是如果开发一个支持百万级别文档与高查询量的大规模系统，那么<strong>只用包含用户会搜索的那些字段即可</strong>。例如，user_id字段是Twitter的内部识别符，用户不大可能想要搜索这个字段。一般情况下，每增加一个字段就会增加索引的提及，因此在索引中仅包含用户会搜索的字段即可。<br />favorite_count字段是微博作者的粉丝数，不是该条博文的点赞数。这个字段很有趣，从UI角度看，它提供了有用的信息，但不适合作为搜索查询参数的备选。在之后介绍存储字段和索引字段时，会顺带讨论这些已显示为目标的字段的处理方法。<br />让我们想想用户如何使用这些字段来构造查询，这有助于确定如何在Solr索引中表示这些字段。图5.1展示了一个虚构的搜索表单，其中的字段来自之前讨论的微博搜索应用。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623741245409-c8e9a9c9-5c70-4695-89ca-ce49f03f6fda.png#height=904&id=eBYGB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=904&originWidth=1154&originalType=binary&ratio=1&size=1196834&status=done&style=none&width=1154" alt="image.png"><br />从搜索角度看，我们认为搜索表单的每个字段都是有用的。搜索应用设计的一个关键是，考虑用户如何对索引中的特定字段进行搜索。这一点很关键，这也有助于确定在Solr中定义那些字段。<br />现在，我们已经从概念上理解了微博搜索示例中的字段，了解到用户如何使用这些字段搜索文档。接下来，我们从宏观层面理解如何向Solr添加文档。<br><a name="Xt0oL"></a></p>
<h3 id="Solr索引构建概览"><a href="#Solr索引构建概览" class="headerlink" title="Solr索引构建概览"></a>Solr索引构建概览</h3><p>从宏观层面看，Solr的索引构建可分解为三个主要任务：</p>
<ol>
<li><strong>将文档从原始格式转换为Solr支持的格式</strong>，例如，XML或者JSON；</li>
<li><strong>从良好定义的接口方法中选择一种，通常使用Http Post，将文档添加到Solr</strong>；</li>
<li>在索引中，<strong>通过配置Solr，对文档的文本进行转换</strong>。</li>
</ol>
<p>图5.2展示了Solr索引文档过程的宏观概览，包括三个基本步骤。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623741670966-695d2de8-78e8-458f-9ea0-ff9b52e304c5.png#height=1082&id=iqG9H&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1082&originWidth=1296&originalType=binary&ratio=1&size=1402790&status=done&style=none&width=1296" alt="image.png"><br />Solr的索引构建支持多种文档格式，包括XML、JSON和CSV。由于XML的字描述格式易于理解，所以在图5.2中使用XML表示。示例微博在Solr中的XML格式详见代码清单5.1.<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1623741804132-2af31e2b-cc6c-429e-a774-997c4884b2ee.png#height=546&id=prpg4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=546&originWidth=1392&originalType=binary&ratio=1&size=830455&status=done&style=none&width=1392" alt="image.png"><br />请注意，X<strong>ML文件中表示的每个字段和语法都非常简单，只需要定义字段名称和字段值</strong>。<strong>这里还没有设计文本分析和字段类型</strong>。图5.2展示了再schema.xml中定义字段的分析方式。<br />回想一下，第2章介绍了Solr对所有核心服务提供基本的Http接口，包括添加和更新文档的文档更新服务。如图5.2左上角所示，我们使用Http Post方法将示例微博的XML文档发送至Solr的文档更新服务。本章后续小节会详细介绍不同文档类型(如XML、JSON和CSV)的添加方法。现在，<strong>将文档更新服务视为一个抽象组件，用来验证文档中每个字段的内容，之后进入文本分析阶段</strong>。<strong>每个字段经过分析后的结果文本将被添加到索引中，这样文档就可以用于搜索了</strong>。<br />之后将详细介绍索引构建原理。目前，索引构建的宏观概览已经介绍到位了，接下来需要多掌握一些基本原理，比如，需要掌握图5.2中Solr如何使用schema.xml文件来驱动索引的构建过程。<br />schema.xml文件定义了文档的字段和字段类型。对于简单的搜索应用而言，可供搜索的字段和它们的类型可能是显而易见的。一般而言，这些显而易见的字段有助于对模式设计的前期规划。<br><a name="4hf6P"></a></p>
<h2 id="设计自己的schema"><a href="#设计自己的schema" class="headerlink" title="设计自己的schema"></a>设计自己的schema</h2><p>在微博搜索应用示例中，我们定义了文档的内容和希望索引的字段。但是实际操作层面，对于一个真实搜索应用而言，这个过程不总是显而易见的，所以做一些前期设计与工作规划是很有帮助的。本节介绍搜索应用应考虑的关键设计问题。具体而言，我们应该对应用的一下关键问题作出应答：</p>
<ul>
<li><strong>索引中的文档内容有哪些</strong>？</li>
<li><strong>每个文档如何做到唯一识别</strong>？</li>
<li><strong>用户会搜索文档中的哪些字段</strong>？</li>
<li><strong>在搜索结果中应该向用户显示哪些字段</strong>？</li>
</ul>
<p>针对特定搜索应用，我们先从如何决定合适的文档粒度入手，因为这个问题会影响到其他问题。<br><a name="Y6AGa"></a></p>
<h3 id="文档粒度"><a href="#文档粒度" class="headerlink" title="文档粒度"></a>文档粒度</h3><p><strong>schema的设计过程实际是确定文档如何表征为Solr的索引过程</strong>。某些情况下这个过程是显而易见的，例如，我们示例中的微博内容通常很短，所以每条推文就是一个文档。然而，如果待索引的内容量大，例如，计算机技术书籍，可能要将大文档的各个子节视为索引单元。问题的关键在于，考虑用户希望看到什么样的搜索结果。让我们来看一个不同的例子，一遍更好理解索引中的文档构成。<br />假设在出售计算机技术书籍的网站上搜索’text analysis’。如果网站<strong>将每本书视为一个文档</strong>，用户在搜索结果中看到《Solr实战》，但需<strong>要翻阅目录或索引</strong>，找到书中出现’text analysis’的具体位置。如图5.3所示，左侧图显示了将整本书视为一个文档进行索引后的搜索结果。<br />如果网站<strong>将每本书的章节作为索引的文档</strong>，那么搜索结果可能会在一开始向用户显示《Solr实战》的’text analysis’章节，如图5.3右侧所示。由于’text analysis’是搜索的核心概念，本书的很多地方和其他有关搜索的书籍都与其高度相关，因此都出现在了搜索结果中。由此可见，<strong>文档粒度过细会导致用户面对过多的搜索结果</strong>。<br /><strong>内容类型也是索引创建时需要考虑的</strong>。按照章节对计算机技术书籍的内容进行拆分是行得通的，但对科幻小说进行章节拆分，似乎并不合适。也就是说，索引中的文档可以由你自主决定，但要充分考虑文档粒度对用户搜索体验造成的影响。通常，<strong>文档粒度的选择尽量不要让用户感到’见木不见林’（只看得到局部，看不到整体或全部）</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624154213383-81382471-44ee-48c7-891b-cb873202989e.png#height=700&id=bUEhl&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1400&originWidth=1932&originalType=binary&ratio=1&size=1287140&status=done&style=none&width=966" alt="image.png"><br><a name="eq9Gw"></a></p>
<h4 id="Solr搜索结果高亮"><a href="#Solr搜索结果高亮" class="headerlink" title="Solr搜索结果高亮"></a>Solr搜索结果高亮</h4><p>另外需要留意，Solr提供搜索结果高亮功能，对搜索结果中长文档的相关部分进行高亮显示。<strong>当无法将长文档分成小单元，但仍希望帮助用户在长文档中快速定位高度相关的章节时，高亮功能非常有用</strong>。例如，使用高亮对包含’text analysis’的文档显示该短语周围的文本片段。第9章将讨论搜索结果高亮。<br><a name="NsQJ2"></a></p>
<h3 id="唯一键"><a href="#唯一键" class="headerlink" title="唯一键"></a>唯一键</h3><p>一旦确定了待索引的文档的构成，接下来就需要确定<strong>如何在索引中唯一识别每个文档</strong>。对于整本书，可能是ISBN号；对于章节，可能是ISBN号加上章节号。<strong>Solr不要求每个文档都有一个唯一识别符，但若提供，Solr会将其用于去除索引中的重复文档</strong>。如果你了解数据库，应该知道唯一识别<strong>类似于二维表中元组的主键</strong>。如果将相同主键的文档添加到索引，Solr会用最新的文档覆盖已有的字段。<br />微博搜索应用中的微博已经包含一个唯一识别符：id。如果索引的内容来自不同社交媒体，可能会出现相同ID的文档，那么需要增加前缀进行区分，例如，加前缀Twitter：已示于Facebook区分。<br><a name="ILs6Y"></a></p>
<h3 id="索引字段"><a href="#索引字段" class="headerlink" title="索引字段"></a>索引字段</h3><p>确定了索引的文档构成以及文档的唯一识别符后，接下来是确定文档中的索引字段(<strong>indexed fields</strong>)。索引字段选择的最佳方法是，询问典型用户<strong>是否能使用该字段构造有意义的查询表达式</strong>。另一种方法是，如果搜索表单没有提供该字段的查询选项，但用户会提及它，那么这个字段就应该被索引。<br />例如，每本书都有书名和作者。搜索图书时，人们通常希望通过书名和作者找到感兴趣的书籍，因此这两个字段应该被索引。人虽然每本书都有一个责任编辑，但读者找书时通常不会搜索编辑的名字，因此，编辑的名字无须作为索引字段。相反的，如果为图书出版业构建一个索引以供搜索，那么用户会搜索编辑的名字，这时可以将其作为索引字段。<br />为了启用搜索，需要对索引字段进行标记，还需要对字段值进行排序、分面、分组、查询建议及执行函数查询等。当启动了特定高级设置时(第9章会介绍)，标记索引字段会有效提升搜索结果高亮处理效率。以上这些功能将在本书后续介绍，很多都以独立章节出现。从本质上讲，如果搜索结果中不止返回原始的字段值，还需对字段值进行运算的话，那么大多是情况下都需要索引这个字段。<br />对不同搜索引用而言，需要索引的字段都是不一样的。花点时间考虑一下文档的待索引字段，记录下来，随后会要用到这些字段。之前讨论过，screen_name、type、timestamp、lang和text字段是微博搜索应该索引的字段。id和user_id是Twitter的内部使用字段，如果不允许用户搜索它们，那就可以不理会了。<br><a name="8y3lh"></a></p>
<h3 id="存储字段"><a href="#存储字段" class="headerlink" title="存储字段"></a>存储字段</h3><p>虽然用户不会通过编辑的名字去找要读的书，但我们仍希望在搜索结果中显示编辑的名字。一般情况下，<strong>文档可能包含了一些对搜索本身无用的字段，但这些字段显示在搜索结果中仍然是有用的</strong>。Solr将这些字段成为<strong>存储字段</strong>(<strong>stored fields</strong>)。favorites_count字段是一个典型的存储字段，<strong>它不会被索引，只用于显示</strong>。设想一下，当用户在搜索结果中查询哪位作者更受欢迎时，favorites_count就会很有用，但用户并不希望通过这个字段进行搜索。当然，<strong>一个字段可以同时被索引和存储</strong>，例如，搜索引用的screen_name、timestamp及text字段。每个字段都能被搜索和显示在搜索结果中。<br />作为一名搜索应用架构师，你的任务目标之一是<strong>尽量降低索引的大小</strong>。如果你正在考虑使用Solr，那么你手头很可能有一个待扩容的应用，以应对大规模的文档和用户请求。<strong>索引中每个存储字段都需要占用磁盘空间，请求CPU和I/O资源来读取存储值，将其返回在搜索结果中</strong>。应谨慎地选择存储字段，尤其是对于大规模应用而言。<br />基于这一点，设计搜索应用时需要认真思考所需的字段类型。一旦选定了一个方案，接下来就该着手在schema.xml中进行设计。如图5.2所示，schema.xml是Solr的主要配置文件，从中可以了解如何进行文档索引。让我们预览一下schema.xml的主要部分，以便熟悉后续梁小姐中存储的字段情况。<br><a name="Okb1T"></a></p>
<h3 id="schema-xml概览"><a href="#schema-xml概览" class="headerlink" title="schema.xml概览"></a>schema.xml概览</h3><p>在接下来的几个小节中，我们为微博搜索应用设计一个有效的schema.xml文件。schema.xml文件位于Solr内核的conf/目录下。示例Solr服务器的schema.xml文件位于￥SOLR_INSTALL/example/solr/collection1/conf/中。代码清单5.2是Solr示例schema.xml的简要版，展示了XML语法和重要元素。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624239642197-66c174c2-c038-4d7b-a531-6dd1386710f9.png#height=493&id=Bd33T&margin=%5Bobject%20Object%5D&name=image.png&originHeight=986&originWidth=1260&originalType=binary&ratio=1&size=1175021&status=done&style=none&width=630" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624239703096-6c699915-37da-46ef-a8e9-4fc4e50332cf.png#height=139&id=rygDz&margin=%5Bobject%20Object%5D&name=image.png&originHeight=278&originWidth=1028&originalType=binary&ratio=1&size=209293&status=done&style=none&width=514" alt="image.png"><br />初看之下，很容易被内容细节吓到。等读完本章，你就会对所有细节了如指掌，并能够创建自己的schema.xml。<br />schema.xml文档由三个主要部分组成：</p>
<ul>
<li><p>**<fields><strong>元素：</strong><fields>元素包含<field>和<dynamicField>**，用来定义文档的基本结构；</p>
</li>
<li><p>其他元素：如<uniqueKey>和<copyField>，位于<fields>元素之后；</p>
</li>
<li><p>**<types>**元素：该元素下的字段类型包括Solr能够处理的日期、数字和文本字段。<br><a name="eJBcG"></a></p>
<h2 id="在shema-xml中定义字段"><a href="#在shema-xml中定义字段" class="headerlink" title="在shema.xml中定义字段"></a>在shema.xml中定义字段</h2><p>schema.xml的<fields>一节定义文档中所有用到的<field>元素。<strong>Solr根据schema.xml中的字段定义来调用适合的字段分析器，将字段内容解析为词项，继而添加到倒排索引中</strong>。本节中我们学习如何<strong>在schema.xml中定义字段、动态字段和复制字段</strong>。之前已经介绍了schema设计的主要理念，现在可以为微博搜索应用定义<field>元素了。代码清单5.3定义了示例搜索应用的索引字段和存储字段。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624240617933-7fb14ff3-189e-47eb-89a7-cf07a72de984.png#height=297&id=zZdAm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=594&originWidth=1270&originalType=binary&ratio=1&size=807611&status=done&style=none&width=635" alt="image.png"><br />有了这些字段定义，Solr就知道如何索引微博文档了，之后这些字段可以通过图5.1所示的表单进行搜索。在schema.xml中定义一个字段时还有一些必填属性。<br><a name="YsKkc"></a></p>
<h3 id="必备字段属性"><a href="#必备字段属性" class="headerlink" title="必备字段属性"></a>必备字段属性</h3><p>每个字段都有唯一名称，查询构造时会调用这个名称。例如，查询语句为q=screen_name:thelabdude，它会搜索字段名为screen_name，字段值为thelabdude的文档。在代码清单5.3中，screen_name字段定义如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;screen_name&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>通俗点讲，此定义表示screen_name字段即被索引又被存储，其内容包含字符串值。每个字段必须定义类型属性，通过<fieldType>识别字段类型。下一节将详细介绍字段类型。不论字段是否被索引或存储，每个字段都需要进行定义。正如第五章第二节所讨论到的，<strong>索引字段可以被搜索和排序</strong>(其他功能将在本书其他地方介绍)。<strong>出于显示目的，存储字段也会返回在搜索结果中</strong>。一个字段可以同时被索引和存储，就像微博搜索应用示例的大多数字段情况。<br />另外，<strong>Solr不允许嵌套字段</strong>。schema.xml的所有字段都是同级的，也就是一个平面文档结构。正如第三章讨论过的，Solr的文档需要进行非规范化处理，转化成平面结构，必须包含搜索需求所要求的所有字段。这意味着并不存在关系结构，查询处理与搜索结果生成中无法连接其他文档以提供更多信息。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Solr的连接操作</span><br><span class="line">毫无疑问，你一定要会在Solr中遇到文档连接情况，第15章会详细介绍连接功能。现在要清楚一点，Solr的连接更像是SQL的子查询。一个典型的用例是找到符合搜索条件的文档的父文档。以微博搜索应用为例说明，就是通过Solr的连接找回转发微博的原始微博。</span><br></pre></td></tr></table></figure>
<p>当一个字段被存储时可能会造成混淆，Solr存储的是原始值，而非分析后的值。例如，代码清单5.3中奖text字段定义为既可索引也可存储(indexed=’true’,stored=’true’)。这意味着text字段可以被搜索，并在搜索结果中返回原始的文本。当请求字段返回值时，Solr不会在搜索结果中返回分析后的值。当然，如果在搜索结果中不用返回整个字段，那么它就无须存储。<br />虽然随着索引大小的增长，查询速度会降低，但仍然有需要存储所有字段的情况。如果字段已经被索引了，你又计划在Solr中对文档的字段进行更新，而不是从外部来源重新提交全部文档，那么就要存储所有字段，让Solr保留每个字段原始内容的副本。5.6.3节将会介绍如何更新文档。<br><a name="NeTMg"></a></p>
<h3 id="多值字段"><a href="#多值字段" class="headerlink" title="多值字段"></a>多值字段</h3><p>截止目前，微博搜索应用仅适用了几个简单字段。接下来，让我们添加和混合一些字段，来看看Solr在处理更复杂文档结构上的优势。具体来说，添加一个links字段，包含0个或者多个与每个文档相关的连接。就像Twitter上那样，用户能插入相关内容链接，如网格上的一张照片或一篇文档。下面是虚构的嵌入两个连接的微博举例：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624242518670-4ca78bdd-bc6c-4b07-923d-c32ebdb594ba.png#height=189&id=JVpaB&margin=%5Bobject%20Object%5D&name=image.png&originHeight=378&originWidth=1224&originalType=binary&ratio=1&size=441688&status=done&style=none&width=612" alt="image.png"><br />从搜索的角度看，为索引添加解析后的链接可以让用户查找链接到特定网站或网页的社交媒体。想象一下，用户想要找到包含《Solr实战》页面链接<a target="_blank" rel="noopener" href="http://manning.com/grainger/%E7%9A%84%E6%89%80%E6%9C%89%E5%BE%AE%E5%8D%9A%E3%80%82%E7%94%B1%E4%BA%8E%E4%BE%8B%E5%AD%90%E5%8C%85%E5%90%AB%E4%B8%A4%E4%B8%AA%E9%93%BE%E6%8E%A5%EF%BC%8C%E9%9C%80%E8%A6%81%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E5%B0%86%E4%B8%A4%E4%B8%AA%E5%80%BC%E7%BC%96%E7%A0%81%E5%9C%A8%E4%B8%80%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%B8%AD%E3%80%82%E5%9C%A8Solr%E4%B8%AD%EF%BC%8C**%E5%A4%9A%E4%BA%8E%E4%B8%80%E4%B8%AA%E5%8F%96%E5%80%BC%E7%9A%84%E6%96%87%E6%A1%A3%E5%AD%97%E6%AE%B5%E6%88%90%E4%B8%BA%E5%A4%9A%E5%80%BC%E5%AD%97%E6%AE%B5**%E3%80%82%E5%9C%A8schema.xml%E7%9A%84%E5%AD%97%E6%AE%B5%E5%AE%9A%E4%B9%89%E4%B8%AD%EF%BC%8C%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AE**multiValued=&#39;true&#39;**%E6%9D%A5%E5%A3%B0%E6%98%8E%E5%A4%9A%E5%80%BC%E5%AD%97%E6%AE%B5%EF%BC%9A">http://manning.com/grainger/的所有微博。由于例子包含两个链接，需要一种方法将两个值编码在一个字段中。在Solr中，**多于一个取值的文档字段成为多值字段**。在schema.xml的字段定义中，通过设置**multiValued=&#39;true&#39;**来声明多值字段：</a></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;link&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">type</span>=<span class="string">&quot;string&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">multiValued</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果添加的文档包含多个链接，向XML文档添加多个link字段，如代码清单5.4所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624342684813-16ea7fb6-039e-4421-9956-9d7bf8370891.png#height=185&id=w9Ox4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=1174&originalType=binary&ratio=1&size=347616&status=done&style=none&width=587" alt="image.png"><br />这样就可以查询<a target="_blank" rel="noopener" href="http://maning.com/grainger/%E9%93%BE%E6%8E%A5%E4%BA%86%EF%BC%8CSolr%E4%BC%9A%E5%AF%B9%E5%A4%9A%E5%80%BC%E5%AD%97%E6%AE%B5%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89%E5%80%BC%E8%BF%9B%E8%A1%8C%E5%8C%B9%E9%85%8D%E6%89%AB%E6%8F%8F%E3%80%82">http://maning.com/grainger/链接了，Solr会对多值字段中的所有值进行匹配扫描。</a><br />截止目前，微博文档仅包含了几个字段而已，很容易在schema.xml中单独声明每个字段。在现实中，并非所有文档都是如此简单或字段稀少。接下来介绍另一种字段类型——动态字段，它有助于处理规模更大更复杂的文档结构。<br><a name="Bnrhq"></a></p>
<h3 id="动态字段"><a href="#动态字段" class="headerlink" title="动态字段"></a>动态字段</h3><p>Solr的<strong>动态字段</strong>可以<strong>对文档中的一些字段赋予相同的定义</strong>，其<strong>名称匹配采用前缀或后缀</strong>的模式，例如s_<em>或</em>_s。动态字段使用特定的命名方案，对符合全局样式的一类字段赋予相同的字段定义。动态字段有助于解决搜索应用构建的一些常见问题：</p>
</li>
<li><p><strong>多字段的文档建模</strong></p>
</li>
<li><p><strong>支持多来源的文档</strong></p>
</li>
<li><p><strong>添加新的文档来源</strong></p>
</li>
</ul>
<p>依次来看动态字段的这三种应用场景。首先要明确，使用Solr时，并不一定需要使用动态字段。如果搜索应用中没有以上任何一种情况，则完全没有必要使用动态字段。<br />此外除非<strong>在开始进行文档索引时使用动态字段</strong>，否则Solr会在schema.xml中忽略动态字段定义。现实情况是，许多Solr用户只保留了Solr示例模式所提供的动态字段扩展列表，已供货需要时使用。<br><a name="UW3VY"></a></p>
<h4 id="多字段的文档建模"><a href="#多字段的文档建模" class="headerlink" title="多字段的文档建模"></a>多字段的文档建模</h4><p><strong>动态字段使用前缀或后缀模式，在schema.xml中对匹配到的字段赋予相同的字段定义，从而实现多个字段的文档建模</strong>。如代码清单5.3所示，为type、screen_name和lang三个字段赋予字符串字段类型。此外，每个字段既要存储也要索引。除了字段名称不同，字段的定义都是完全一样的。<br />想象一下，除了这三个字段，还有几十个字符串字段都是既要存储也要索引。你可以对每个字段进行显示定义，或者使用一个<dynamicField>元素，在字段名称上加后缀来统一定义这些字符串字段。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>借助这个全局模式，名称以_s结尾的字段都会继承这个字段定义，例如，subject_s。当然，也可以使用前缀模式s_*。因此，面对许多字段时，<strong>动态字段可以减少输入并简化schema.xml文件</strong>。<br />还可以对多值字段使用动态字段，如前一小结中的link字段。下面的动态字段定义包含multiValue=”true”：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> <span class="attr">multiValue</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>对于多值link字段，XML文档使用link_ss作为多个连接的字段名，如代码清单5.5所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624344884411-e1925927-832b-4131-9f7a-437add09d127.png#height=185&id=IsrAP&margin=%5Bobject%20Object%5D&name=image.png&originHeight=370&originWidth=1148&originalType=binary&ratio=1&size=351902&status=done&style=none&width=574" alt="image.png"><br><a name="YcCT3"></a></p>
<h4 id="支持多来源的文档"><a href="#支持多来源的文档" class="headerlink" title="支持多来源的文档"></a>支持多来源的文档</h4><p>动态字段的另一个好处是，<strong>有助于那些基础模式相同但又各自拥有独立字段的文档进行整合</strong>。当然，如果文档之间不具有共同的基础模式，那就不应该处于同一个索引中。以社交媒体为例，如果要对Twitter、Facebook、youtube和google+的文档进行索引，每个来源的文档都有一些字段是代表各自所属的社交网络的。<strong>将不同来源的特定字段作为动态字段会更加直观和易于维护</strong>。距离来说，为每个来源定义多个字段的做法如下，<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624344953428-d3f0059f-cfc0-491c-9943-d5e85e0ba409.png#height=121&id=Zn9mg&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=1384&originalType=binary&ratio=1&size=375266&status=done&style=none&width=692" alt="image.png"><br />现在只要使用一个简单的后缀*_s模式的字符串动态字段就可以完成以上的字段定义。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dynamicField</span> <span class="attr">name</span>=<span class="string">&quot;*_s&quot;</span> <span class="attr">type</span>=<span class="string">&quot;string&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>进行索引时，需要提交_s后缀的字段，如下代码清单5.6所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624345076206-ac9e583c-db2d-4587-9665-2ecb82b0ee8c.png#height=218&id=MJ2O3&margin=%5Bobject%20Object%5D&name=image.png&originHeight=436&originWidth=1150&originalType=binary&ratio=1&size=462541&status=done&style=none&width=575" alt="image.png"><br><a name="si3ym"></a></p>
<h4 id="添加新的文档来源"><a href="#添加新的文档来源" class="headerlink" title="添加新的文档来源"></a>添加新的文档来源</h4><p>如果<strong>向搜索应用添加新的数据来源</strong>，<strong>其中包含之前没有的字段</strong>，那么<strong>可以在索引过程中通过动态字段自动添加进来</strong>。几乎每天都有新上线的社交网络，所以我们不希望不断重复修改schema.xml来处理这些新来源。通过动态字段可以不修改schema.xml，为新的文档来源添加新字段。<br />加入想要添加一个新的社交网路，在该网站发文时需要添加一个记录月相的字段。使用动态字段，可以将月相作为字符串添加到文档中：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;moon_phase_s&quot;</span>&gt;</span>waxing crescent<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>虽然动态字段对索引而言是一个很方便的功能，但对搜索起不到什么作用。对<strong>动态字段索引的文档</strong>进行搜索时，<strong>必须在查询中使用完整的字段名称</strong>。使用前缀或后缀模式来匹配所有字符串字段(例如，*_s:coffee)的查询时无法做到的。相反，查询时需要明确指定字符串，例如，subject_s:coffee、keyword_s:coffee等。但是，如果需要查找多个字段，动态的或者静态的，Solr提供复制字段来处理这种情况。<br><a name="6ILlr"></a></p>
<h3 id="复制字段"><a href="#复制字段" class="headerlink" title="复制字段"></a>复制字段</h3><p><strong>Solr的复制字段允许将一个或多个字段值填充到一个字段中</strong>。具体来说，在大多数搜索应用中复制字段支持以下两种情况：</p>
<ul>
<li><strong>将多个字段内容填充到一个字段</strong>；</li>
<li><strong>对同一个字段内容进行不同的文本分析，创建一个新的可搜索字段</strong>。<br><a name="51kVp"></a><h4 id="创建多字段的汇聚字段"><a href="#创建多字段的汇聚字段" class="headerlink" title="创建多字段的汇聚字段"></a>创建多字段的汇聚字段</h4>绝大多数搜索应用都只提供一个搜索框，供用户输入查询内容。这样做的目的是，帮助用户快速查找文档，而无需填写复杂的表单。想想看，一个简单的搜索框成就了Google。在微博搜索示例中，你可能会觉得只要能搜索微博文本就大功告成了，这也太简单了。但如果用户搜索@thelabdude，由于它包含在screen_name字段中，而不是text字段中，那么使用一个搜索框就无法找到想要的结果。另外，如果微博包含了短网址，由于他们都存储在links字段中，所以搜索text字段时，已解析的网址将不会被匹配出来。所以，我们想要一个将screen_name、text和已解析的link字段汇聚在一起的字段。所幸，在Solr中很容易做到这一点，使用<copyField>可以将文档中的多个字段汇聚成一个搜索字段。<br />首先，需要定义一个让其他字段能复制到一起的目标字段，这里命名为catch_all字段：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624346665089-808607bd-f46b-435e-b4c0-11de28c455ca.png#height=90&id=xJocm&margin=%5Bobject%20Object%5D&name=image.png&originHeight=180&originWidth=1032&originalType=binary&ratio=1&size=187672&status=done&style=none&width=516" alt="image.png"><br />这看起来和其他字段没什么差别，不过有两点需要注意。<br />首先，该字段不存储(stored=”false”)，这样做是有一定道理的。我们不希望向用户显示多个字段连接在一起的一堆东西。事实上，即使想这样做也无法做到，Solr不能返回复制字段的原始值。请记住，Solr能返回存储字段的原始值。<br />其次，如果来源字段是多值字段，目标字段也必须设置为多值字段(multiValue=”true”)。在微博搜索示例中，link字段是多值字段，因此复制字段也必须是多值字段。此外，如果从多个来源字段复制到目标字段，即使所有的来源字段是单值字段，目标字段也必须设置为多值字段。<br />现在已经定义好了目标字段，需要<strong>使用<copyField>来明确Solr要从哪些字段进行复制</strong>。代码清单5.7展示了如何使用<copyFiled>从screen_name、text和link字段中复制字段值到catch_all字段：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624346967634-82eb993b-8d6f-4338-97a3-56489fc61e56.png#height=193&id=p6G0j&margin=%5Bobject%20Object%5D&name=image.png&originHeight=386&originWidth=1146&originalType=binary&ratio=1&size=351802&status=done&style=none&width=573" alt="image.png"><br />需要注意的是，<strong>在schema.xml中<copyField>元素是<fields>和<type>的同级元素。首先必须定义来源(source)和目标(dest)字段</strong>。当所有字段都定好之后，通过copyField将他们连接起来。这是作为同级元素的最佳解释。<br><a name="jZWj0"></a><h4 id="对一个字段应用不同的分析器"><a href="#对一个字段应用不同的分析器" class="headerlink" title="对一个字段应用不同的分析器"></a>对一个字段应用不同的分析器</h4>你可能希望对一个字段的内容进行不同的分析。第6章将介绍词干提取技术，即<strong>把词项转换成通用的基础形式，也就是词干，以提高查全率</strong>。通过词干提取，fishing、fished和fiishes都会归一为fish这个词干。因此，<strong>词干提取让用户在搜索文档时不用考虑一个词的多种可能语言</strong>，这是一般文本搜索字段的好方法。<br />考虑一下词干提取是如何影响搜索输入时的建议框(自动建议)。在这种情况下，词干提取技能给用户建议词干本身，而不能建议完整的词项。例如，启用词干提取后，当用户开始输入human时，自动建议框无法给出humane或humanities这样的建议。**Solr的复制字段具有一定的灵活性，可选择启用或停用特定的文本分析功能(如词干提取)**。无须在索引中重复存储。代码清单5.8取自schema.xml。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624347400638-d2ab2cc6-625f-4e8f-a5c8-f20060bf7d74.png#height=158&id=qyo7I&margin=%5Bobject%20Object%5D&name=image.png&originHeight=316&originWidth=1150&originalType=binary&ratio=1&size=268236&status=done&style=none&width=575" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624414136104-447e3606-eae5-4ff7-bad0-b53c556179b5.png#height=82&id=XMt6l&margin=%5Bobject%20Object%5D&name=image.png&originHeight=164&originWidth=1156&originalType=binary&ratio=1&size=176190&status=done&style=none&width=578" alt="image.png"><br />在这种情况下，text字段是stemmed_text字段类型，也就是说这个字段中的文本是经过词干提取的。auto_suggest字段没有经过词干提取。我们使用<copyField>将text字段未经词干提取的文本赋予auto_suggest字段。在系统后端，Solr将text字段原生的、未被分析的内容发送给auto_suggest字段，以便于采取不同的文本分析策略。原始文本只存储一次。需要重申的是，搜索结果中不能返回auto_suggest字段的原始值，因此它的属性stored=”false”。第10章会介绍如何实现自动建议功能。<br><a name="Z1sO3"></a><h3 id="唯一键字段"><a href="#唯一键字段" class="headerlink" title="唯一键字段"></a>唯一键字段</h3></li>
</ul>
<p>5.2.2节中讨论过如何在索引中使用唯一的ID值来识别文档，这是一个好主意。重申一下，如果<strong>每个文档都赋予一个唯一标识符字段，Solr将在索引创建时避免产生重复索引</strong>。此外，<strong>如果计划将Solr的索引分发到多台服务器上，那就必须为文档提供唯一标识符</strong>。鉴于以上原因，<strong>建议从一开始就为文档定义唯一标识符</strong>。在微博搜索示例中，id字段是独一无二的，因此对Solr进行配置时，我们<strong>在schema.xml中使用<uniqueKey>元素，将id字段作为文档的唯一键</strong>。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624453395812-9804ce02-0dcb-4e18-97eb-499279ed643e.png#height=66&id=rKEH7&margin=%5Bobject%20Object%5D&name=image.png&originHeight=132&originWidth=1150&originalType=binary&ratio=1&size=146734&status=done&style=none&width=575" alt="image.png"><br />需要注意一点，这里<strong>最好使用基本字段类型</strong>，如<strong>字符串型或长整型</strong>。对确定为<uniqueKey>的字段，要确保Solr在索引时不会修改改字段值。在之前的例子中我们已经看到，如果不使用字符串作为文本型键值的类型，Solr就不能正确的返回结果。为减少麻烦，唯一键字段应使用字符串类型或其他基本字段类型。<br />至此，我们已经介绍了在schema.xml中进行字段定义的基本知识。你也应该已经掌握了如何使用多值字段、动态字段和复制字段。现在是时候进入Solr的schema.xml的下一个主要部分，学习如何定义字段类型。<br><a name="7oVfd"></a></p>
<h2 id="结构化非文本字段类型"><a href="#结构化非文本字段类型" class="headerlink" title="结构化非文本字段类型"></a>结构化非文本字段类型</h2><p>本节介绍如何定义结构化数据(如日期、语言代码和用户名)的字段类型。第6章将介绍类似微博搜索示例中正文文本字段的类型定义方法。通常Solr为结构化数据内建了许多字段类型，例如，数字、日期和地理位置字段等。图5.4是Solr中一些最常用字段类型的类图。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624453790120-dc6bde03-95cd-4d01-9e79-fb35f5823e35.png#height=628&id=AEo9H&margin=%5Bobject%20Object%5D&name=image.png&originHeight=628&originWidth=1216&originalType=binary&ratio=1&size=636925&status=done&style=none&width=1216" alt="image.png"><br />让我们从最常见的字符串string字段类型开始讨论非文本数据的字段类型。<br><a name="TQJwE"></a></p>
<h3 id="字符串字段"><a href="#字符串字段" class="headerlink" title="字符串字段"></a>字符串字段</h3><p>在前面的微博例子中，除了text字段之外，screen_name、type、timestamp和lang都应该是索引字段。那么，就需要为这四个字段确定合适的字段类型。事实上，<strong>每个字段包含的结构化数据都不需要进行分析</strong>。例如，lang字段包含ISO-630-1标准的语言代码，用来识别微博的语种，例如，en表示英语。用户通过搜索lang字段，可以找到英文微博，如图5.5所示。<br />因为语言代码已经标准化，所以Solr在索引与查询处理时无须进行任何更改。Solr为那些不需要变更结构化值提供string字段类型。下面的代码清单演示了在schema.xml中如何定义string字段类型。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624454024715-24ddd111-48e2-48ed-a243-6e6eabfeda66.png#height=63&id=smNpk&margin=%5Bobject%20Object%5D&name=image.png&originHeight=126&originWidth=1152&originalType=binary&ratio=1&size=178068&status=done&style=none&width=576" alt="image.png"><br />技术背后是，<strong>所有的字段类型由一个Java类来实现</strong>，这里使用solr.StrField。在执行阶段，<strong>solr.StrField解析为Solr的内置类org.apache.solr.schema.StrField</strong>。任何时候，你在schema.xml中都会看到 <code>solr.</code> 作为类的前缀，其对应的完整Java包是org.apache.solr.schema。这种简化标记有助于保持schema.xml的内容整齐。sortMissingLast和omitNorms属性高级选项，5.4.4节会详细介绍。<br />如果将lang字段设置为字符串类型，Solr会把文档的取值en存储在索引中，并作为不变的持久索引。查询时需要传递准确值en才能匹配出英文文档。图5.5中用户选择了英语，在表单处理时，需要转换为en。<fieldType>字符串也适用于screen_name字段和type字段，但timestamp时间戳字段怎么办呢？<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624454304546-b97626f1-e0bb-44b7-b4ec-16460865f300.png#height=840&id=ZDDZ6&margin=%5Bobject%20Object%5D&name=image.png&originHeight=840&originWidth=1018&originalType=binary&ratio=1&size=835658&status=done&style=none&width=1018" alt="image.png"><br><a name="ZUbMA"></a></p>
<h3 id="日期字段"><a href="#日期字段" class="headerlink" title="日期字段"></a>日期字段</h3><p>日期字段搜索的常见做法是<strong>允许用户指定日期范围</strong>。图5.5中用户搜索了某一特定日期(05/01/2012)之后发布的微博。在查询端，timestamp字段上执行的是一个区间查询：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">timestamp:[2012-05-01T00:00:00Z TO *]</span><br></pre></td></tr></table></figure>
<p>由于搜索日期区间是常见的用例，Solr提供了一个优化的内置<fieldType>，成为tdate，如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624454582333-ebeaa544-15c6-4f39-8395-ab10714f0746.png#height=140&id=WTQTd&margin=%5Bobject%20Object%5D&name=image.png&originHeight=140&originWidth=1148&originalType=binary&ratio=1&size=189238&status=done&style=none&width=1148" alt="image.png"><br />说实话，这看起来比字符串类型更唬人！像precisionStep和positionIncrementGap这样的附加属性都是高级选项，5.4.4节会介绍。再次强调，solr.TrieDateField是Solr的简化标记，用于<strong>代表此字段类型实现的org.apache.solr.schema.TrieDateField</strong>。trie是一种高级的基于树的结构数据，可以对数值和日期值进行不同精确程度的有效搜索。<br />Solr在索引时需要知道如何解析日期。回想5.1节的示例XML文档，我们将它提交给Solr进行索引，包含了以下timestamp字段：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624455180222-0c37aa09-e3a6-41b6-a4be-4db63445ccc8.png#height=216&id=Wuj2q&margin=%5Bobject%20Object%5D&name=image.png&originHeight=216&originWidth=880&originalType=binary&ratio=1&size=100170&status=done&style=none&width=880" alt="image.png"><br />在schema.xml中timestamp字段定义为tdate类型：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;timestamp&quot;</span> <span class="attr">type</span>=<span class="string">&quot;tdate&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>通常情况下，**Solr默认采用ISO-8601日期/时间格式(YYYY-MM-DDTHH:MM:SSZ)**，微博的日期(2012-05-22T09:30:22Z)分解如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">yyyy = 2012</span><br><span class="line">	MM = 05</span><br><span class="line">  HH = 09 (24-hr clock)</span><br><span class="line">  mm = 10</span><br><span class="line">  ss = 22</span><br><span class="line">  Z = UTC Timezone (z is for zulu)</span><br></pre></td></tr></table></figure>
<p>如果向Solr提交其他日期格式，索引时就会得到验证错误信息，待索引的文档会被拒绝。<br><a name="GHf30"></a></p>
<h4 id="日期粒度"><a href="#日期粒度" class="headerlink" title="日期粒度"></a>日期粒度</h4><p>接下来需要确定索引中的日期粒度。这又要回到实际需求，了解用户如何进行日期查询。如果用户只希望按照天来查询，那就不需要对日期索引精确到秒或毫秒。如果需要按日期对文档排序，那么小时级别的粒度可能就太粗了，这时候需要达到分钟级别的粒度。<br />在索引创建阶段，<strong>Solr支持日期的数学运算</strong>，可以帮助你毫不费力的达到日期字段准确的精确度。比方说，你决定需要在小时级别的粒度上索引日期字段，这样可以节省索引空间， 同时也意味着，用户搜索时无法在小时区间内指定更精确的搜索。当索引时，<strong>日期以 <strong><code>**/HOUR**</code></strong> 结尾</strong>，这将告诉<strong>Solr将日期”四舍五入”处理成小时级别</strong>。下面一起来看看如何将示例微博按照小时级别的粒度进行索引。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;timestamp&quot;</span>&gt;</span>2012-05-22T09:30:22Z/HOUR<span class="tag">&lt;/<span class="name">field</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>当索引时，示例文档的时间戳字段值等价于2012-05-22T09:00:00Z。除了指定准确的日期/时间之外，<strong>Solr还支持NOW关键字</strong>，<strong>它表示Solr服务器的当前系统时间</strong>。运用Solr的日期数学运算将具体日期或NOW关键字结合起来，可以实现强大的日期计算，例如，<strong>NOW/DAY表示当前日的午夜，NOW/DAY+1DAY表示明天午夜</strong>。要<strong>查询自今天起的所有文档</strong>，设置时间戳为：**[NOW/DAY TO NOW/DAY +1DAY]**。第7章会介绍更多的区间查询。<br />提醒一下，需要进行日期区间查询时，tdate是不错的选择，但这样会需要更多的索引空间，因为每个日期被分解成更多的时间单元进行存储。参考Solr的Java文档，precisionStep=”6”对长字段来说比较合适，详见5.4.4节。<br><a name="wBdQh"></a></p>
<h3 id="数值字段"><a href="#数值字段" class="headerlink" title="数值字段"></a>数值字段</h3><p>大多数情况下Solr对数值字段的处理方式与你所期望的相同。5.1节讨论了如何用favorites_count字段标示用户对微博点赞的次数。这不是一个可以直接用于搜索的字段，但从显示和排序角度看它是非常有用的。换句话说，假设用户想要根据favorites_count字段对最热门作者的微博进行排序，在schema.xml中定义字段如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">&quot;favorites_count&quot;</span> <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> <span class="attr">indexed</span>=<span class="string">&quot;true&quot;</span> <span class="attr">stored</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">···</span><br><span class="line"><span class="comment">&lt;!-- int字段类型定义如下 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;int&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.TrieIntField&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">percisionStep</span>=<span class="string">&quot;0&quot;</span> <span class="attr">positionIncrementGap</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于不需要在这个字段上进行区间查询，因此设定precisionStep=”0”。这是最佳的排序设定，不会带来额外的存储成本，而与之相关的是，更快的区间查询需要更高的精确梯度。另外，不应采用字符串字段排序那样对数值字段进行索引。如果字段类型是基于字符串的，那么Solr会进行词汇排序，而不是按数值排序。换句话说，如果使用基于字符串的字段类型对数值字段进行索引，排序结果会像 <code>1,10,2,3....</code> 而不是 <code>1,2,3,4...</code> 。<br />至此，我们已经讨论了包含结构化信息的索引字段的主要概念。后续章节会介绍这些非文本字段类型的具体应用。例如，第15章Solr的地理空间搜索使用<fieldType>来表示经度与纬度。接下来简要介绍字段类型的高级配置选项。<br><a name="J9fJ0"></a></p>
<h3 id="高级字段类型属性"><a href="#高级字段类型属性" class="headerlink" title="高级字段类型属性"></a>高级字段类型属性</h3><p>Solr支持字段类型的可选属性，通过可选属性启用高级功能。表5.3涵盖了<fieldType>元素的高级属性。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624685052482-c9e7aa10-3743-44d9-9102-61eac7588a61.png#height=758&id=w0tmH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=758&originWidth=1988&originalType=binary&ratio=1&size=812779&status=done&style=none&width=1988" alt="image.png"><br />Solr新手常常对precisionStep比较困惑，接下来会详细介绍它。不过当前你可以跳过下面的讨论，当部署好搜索应用后再回过头来看，寻求排序和区间查询的性能优化方法。<br><a name="ABzv5"></a></p>
<h4 id="sortMissingFirst空值优先排序"><a href="#sortMissingFirst空值优先排序" class="headerlink" title="sortMissingFirst空值优先排序"></a>sortMissingFirst空值优先排序</h4><p>当一个定义<strong>该属性为true</strong>的时候，solr会将返回的文档集中的<strong>该属性值为空的文档放在最前边</strong>，该排序优先级高于sort排序。<br><a name="qLJjo"></a></p>
<h4 id="sortMissingLast空值最次排序"><a href="#sortMissingLast空值最次排序" class="headerlink" title="sortMissingLast空值最次排序"></a>sortMissingLast空值最次排序</h4><p>当一个定义<strong>该属性为true</strong>的时候，solr会将返回的文档集中的<strong>该属性值为空的文档放在最后边</strong>，该排序优先级高于sort排序。<br><a name="lgvta"></a></p>
<h4 id="为数值字段选择最佳precisionStep"><a href="#为数值字段选择最佳precisionStep" class="headerlink" title="为数值字段选择最佳precisionStep"></a>为数值字段选择最佳precisionStep</h4><p>找寻文档时经常会碰到两种情况：<strong>对数值或日期字段进行区间匹配，称之为区间查询</strong>；<strong>按照数值和日期字段进行结果排序</strong>。之前提到过，Solr使用字典树(trie)数据结构来支持有效的区间查询，对数值和日期进行排序。接下来介绍如何选择precisionStep最佳值来支持Solr搜索应用中的区间查询和排序。<br />首先，当用户在数值或日期字段上<strong>通过区间搜索查找文档时</strong>，<strong>索引中是否存在数值或日期字段</strong>，然后再考虑precisionStep的问题。对于<strong>每个字段</strong>，<strong>考虑索引时可能的区间值</strong>，<strong>唯一值数量是潜在的百万级还是只有少数一些</strong>？在Solr中，<strong>字段唯一值的数量</strong>称之为<strong>字段的基数(cardinality)<strong>。<br />例如，在全美房屋出售信息的Solr索引上进行搜索，购房者通常会在特定区域和价格区间上搜索房屋。搜索应用中的典型查询可能是这样：city:Denver AND price:[250000 TO 300000]。房屋价格是典型的需要进行有效区间搜索的字段。</strong>由于这个搜索应用涵盖了美国各地的房屋信息，所以价格字段的取值从10000美元到1000万美元不等，因此价格区间的基数很大</strong>。<br />接下来，需要确定价格显示的最佳字段类型。一般而言，大多数的房屋价格会以美元标价，很少有房屋价格精确到美分。因此，int或long字段应该足够了。因此，Solr的最大整数值为2147483647(21亿)，事实上不可能有房屋价格超过这个上限。始终牢记，要<strong>尽可能节约的使用字段类型</strong>，也就是说，应避免出现浪费。例如，如果4个字节的整数型就够了，却使用了8个字节的长整型的情况。这样做<strong>会减少磁盘上的索引大小，并在搜索与排序时降低内存使用</strong>。房屋价格字段定义如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">fieldType</span> <span class="attr">name</span>=<span class="string">&quot;tint&quot;</span> <span class="attr">class</span>=<span class="string">&quot;solr.TrienIntField&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">precisionStep</span>=<span class="string">&quot;8&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">positionIncrementGap</span>=<span class="string">&quot;0&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>使用TrieInt字段，属性precisionStep=”8”，那么327500美元的房屋价格怎么索引？基于字典树的字段背后，<strong>Lucene会对字段里的每个值产生多个索引项，每个索引项的精确度都低于原始值</strong>。换句话说，<strong>两个不同的房屋价格在低精确度下会有重叠</strong>。<strong>Lucene这种做法是为了减少区间查询匹配中的索引项数量</strong>。表5.4列举了房屋价格为327500美元、precisionStep=”8”被索引后的索引项。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624685843878-11c1479d-8626-4c91-a161-3a0fa5bf3e94.png#height=566&id=l7Yre&margin=%5Bobject%20Object%5D&name=image.png&originHeight=566&originWidth=1998&originalType=binary&ratio=1&size=528831&status=done&style=none&width=1998" alt="image.png"><br />表5.4显示了不同的精确度步长。<strong>Lucene以8个字节为一个步长，从原始值中移除相应的字节数，得到的索引项精度逐步降低</strong>。例如，步长为2中的房屋价格327500美元和326800美元的索引项都是262144，这意味着区间查询中这两个房屋价格只需匹配262144即可。事实上，262144这个索引项是房屋价格区间在262144美元和327678美元内所有价格对应的索引项。换句话说，<strong>precisionStep为8的设定，允许Solr对262144美元与327679美元之间的所有房屋价格使用262144这个索引项</strong>。(通过提高精确度步长，复用索引)。<br />设定房屋价格的precisionStep=”4”，比较一下更小梯度带来的影响。表5.5列举了precisionStep=”4”的房屋价格327500的索引项。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624686118827-36b7b630-f207-4971-8ba7-914fed4d1332.png#height=716&id=wvLoK&margin=%5Bobject%20Object%5D&name=image.png&originHeight=716&originWidth=2012&originalType=binary&ratio=1&size=690029&status=done&style=none&width=2012" alt="image.png"><br />表5.5表示，<strong>精确步长越小产生的索引项越多</strong>，精确步长为4产生6个索引项，而精确步长为8产生4个索引项。一般情况下，每个字段值使用更小的精确步长时会产生更多的索引项，因此会增加索引大小。<strong>但是，Lucene在更多索引项中会更快的缩小搜索范围，因此更多的索引项会提高区间查询速度</strong>。直接的解释是，<strong>Lucene使用字典树中最低的可能精确度作为搜索区间的中心</strong>。然而，<strong>由于必须对搜索区间的上限和下限进行更精确的搜索，所以更多的索引项让区间边界匹配更加有效</strong>。<br />为了验证这一点，我们做一次非正式的基准测试。在房屋价格110000美元与5000000美元之间随机索引500000。索引完成后，随机生成10000个区间查询来体验平均性能。表5.6是测试结果总结。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624687773407-15b2f6c6-beea-4ef9-8a1b-bd07fb379748.png#height=428&id=mbrmJ&margin=%5Bobject%20Object%5D&name=image.png&originHeight=428&originWidth=1994&originalType=binary&ratio=1&size=477911&status=done&style=none&width=1994" alt="image.png"><br />请注意，每个文档的索引大小相差大约8个字节，这与表5.5的情况保持一致，当使用更小的精确步长时，每个文档生成了两个额外的4字节整数索引项。总之，<strong>选择精确步长时，必须对区间查询性能与索引空间进行权衡</strong>。房屋价格字段定义为TrieInt类型，精确步长为4时，对特定价格的查询会产生更多索引项，但区间搜索速度更快，特别是在字段的基数很大并包含许多唯一值的情况下。<br><a name="8Xxj2"></a></p>
<h2 id="发送文档到Solr进行索引"><a href="#发送文档到Solr进行索引" class="headerlink" title="发送文档到Solr进行索引"></a>发送文档到Solr进行索引</h2><p>现在我们已经有足够的索引处理知识，接下来将文档添加到Solr。本节讲解如何将文档发送到Solr进行索引，并简单介绍背后的原理。学习完本节，你就可以为搜索应用添加文档索引了。以本章示例微博为例介绍如何进行索引。<br><a name="gPI3Z"></a></p>
<h3 id="使用XML或JSON进行文档索引"><a href="#使用XML或JSON进行文档索引" class="headerlink" title="使用XML或JSON进行文档索引"></a>使用XML或JSON进行文档索引</h3><p>正如5.1节谈到的，Solr使用简单的XML文档结构来添加文档。代码清单5.12展示了本章之前使用的两个示例微博。在这里，我们更改了字段名称，以便使用动态字段。例如，由于字段名称里有_s后缀，所以screen_name_s是字符串类型。这样做只是为了图方便，当然也可以对schema.xml不做任何更改，将这些文档直接添加到Solr示例服务器。如果正在构建正式的搜索应用，那么需要在schema.xml中显式声明代码清单5.3中的字段。在当前这个示例中使用动态字段比较好。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624708400805-2648445d-bce2-43b8-9232-0fa7172dfcab.png#height=1484&id=uhxxb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1484&originWidth=2168&originalType=binary&ratio=1&size=1465641&status=done&style=none&width=2168" alt="image.png"><br />将这个XML文档发给Solr，生成了两条微博索引。Solr示例包含一个简单的命令程序，负责将XML文档发送到示例服务器。打开工作站上的命令行窗口，输入代码清单5.13中的命令：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624713308207-00f9c76f-b313-470e-8d08-c369a158e3de.png#height=562&id=FXgoX&margin=%5Bobject%20Object%5D&name=image.png&originHeight=562&originWidth=2244&originalType=binary&ratio=1&size=682686&status=done&style=none&width=2244" alt="image.png"><br />此时，在示例Solr服务器上应该索引了两条示例微博。验证一下索引是否成功，打开常用的Web浏览器，在地址栏输入<a target="_blank" rel="noopener" href="http://localhost:8983/solr/#/%EF%BC%8C%E8%BF%9B%E5%85%A5Solr%E7%AE%A1%E7%90%86%E9%9D%A2%E6%9D%BF%EF%BC%8C%E7%82%B9%E5%87%BB%E5%B7%A6%E4%BE%A7%E8%8F%9C%E5%8D%95%E4%B8%ADcollection1%E4%B8%8B%E7%9A%84Query%E9%93%BE%E6%8E%A5%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%9F%A5%E8%AF%A2type_s:post%EF%BC%8C%E5%A6%82%E5%9B%BE5.6%E6%89%80%E7%A4%BA%E3%80%82">http://localhost:8983/solr/#/，进入Solr管理面板，点击左侧菜单中collection1下的Query链接，执行查询type_s:post，如图5.6所示。</a><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624763853356-db5b3764-b4ff-4be4-8400-ec7d61b1a0d6.png#height=1644&id=waFDo&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1644&originWidth=2016&originalType=binary&ratio=1&size=1353253&status=done&style=none&width=2016" alt="image.png">    从技术上讲，借助post.jar这个工具，通过Http将XML文档发送给Solr的更新处理器(<a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/update)%E3%80%82**%E6%9B%B4%E6%96%B0%E5%A4%84%E7%90%86%E5%99%A8%E6%94%AF%E6%8C%81%E6%96%87%E6%A1%A3%E7%9A%84%E6%B7%BB%E5%8A%A0%E3%80%81%E6%9B%B4%E6%96%B0%E4%B8%8E%E5%88%A0%E9%99%A4**%E3%80%825.6%E8%8A%82%E4%BC%9A%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%E6%9B%B4%E6%96%B0%E5%A4%84%E7%90%86%E5%99%A8%E3%80%82">http://localhost:8983/solr/collection1/update)。**更新处理器支持文档的添加、更新与删除**。5.6节会详细介绍更新处理器。</a><br />除了XML以外，Solr的更新请求处理器还支持流行的JSON和CSV文档格式。示例微博XML文档的等价JSON文档格式如代码清单5.14所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624764378256-279c8e88-a1ea-4698-8df9-46b9b8be6ae2.png#height=1500&id=W2i5d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1500&originWidth=1976&originalType=binary&ratio=1&size=1082099&status=done&style=none&width=1976" alt="image.png"><br />同样的，可以使用post.jar工具将JSON文档发送给Solr，但XML是默认文档格式。因此，必须在搜索应用中设定type的系统属性为application/json，以指明发送的是JSON。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Dtype=application/json -jar post.jar ch5/tweets.json</span><br></pre></td></tr></table></figure>
<p>命令行中 <code>-Dtype=application/json</code> 参数的位置非常重要，必须位于-jar参数之前。要了解post.jar支持的完整选项列表，运行 <code>java -jar post.jar --help</code> 进行查看。<br />如果已经做完XML和JSON文档的添加联系，你可能会认为索引中现在已经有4个文件。然而，由于文档中使用了id字段，所以索引里只有2个文档。为了明确这一点，你可以重新提交type_s:post来验证。这也说明Solr如何使用唯一键字段对已有文档进行更新，示例schema.xml中的唯一键是id。<br />进一步仔细查看post.jar工具的输出，你会发现：当发送文档之后，post.jar向Solr发送了一个提交命令。不管如何将文档发送到Solr，在提交之前他们都无法被搜索。提交过程相当复杂，5.6节会详细介绍。下一小节介绍如何使用SolrJ(一个流行的Java客户端)来索引文档。<br><a name="NgQvf"></a></p>
<h3 id="使用SolrJ客户端库添加文档索引"><a href="#使用SolrJ客户端库添加文档索引" class="headerlink" title="使用SolrJ客户端库添加文档索引"></a>使用SolrJ客户端库添加文档索引</h3><p>SolrJ是一个由Solr项目提供的基于Java的客户端库，用于Java程序与Solr服务器进行通信。本节将编写一个简单的SolrJ客户端，使用Java发送文档。如果你不熟悉Java开发，或者搜索应用不是使用Java编写的，那么可以选择其他编程语言版本的Solr客户端，如.NET、Ruby、Python和PHP。第12章(12.8.2节)会介绍各种编程语言的Solr客户端库。<br />代码清单5.15是使用SolrJ添加两个示例微博文档进行索引的简单例子，执行的是硬提交。提交之后，示例代码向Solr发送一个匹配所有文档的查询(<em>:</em>)，在搜索结果中返回已经索引的文档。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624767131920-8d557c4c-d791-427a-9321-abdfcfe7504c.png#height=944&id=ErRMU&margin=%5Bobject%20Object%5D&name=image.png&originHeight=944&originWidth=1960&originalType=binary&ratio=1&size=855598&status=done&style=none&width=1960" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624767196875-17d59c3c-6f4f-430d-98bc-ec529649fff3.png#height=2780&id=bl3Lc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=2780&originWidth=2210&originalType=binary&ratio=1&size=2506678&status=done&style=none&width=2210" alt="image.png"><br />从这个基础例子可以看出，SolrJ的API可以很容易的连接到Solr，进行文档添加、查询发送与搜索结果处理等操作。首先需要Solr服务器的地址，示例中的地址是<a target="_blank" rel="noopener" href="http://localhost:8983/solr/colletion1%E3%80%82%E8%83%8C%E5%90%8E%E4%BD%BF%E7%94%A8%E7%9A%84%E6%8A%80%E6%9C%AF%E6%98%AF%EF%BC%8CSolrJ%E4%BD%BF%E7%94%A8Apache%E7%9A%84HttpComponents%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93%EF%BC%8C%E9%80%9A%E8%BF%87Http%E4%B8%8ESolr%E6%9C%8D%E5%8A%A1%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%E3%80%82%E5%9C%A85.5.1%E8%8A%82%E4%B8%AD%E4%B8%80%E7%9B%B4Solr%E6%94%AF%E6%8C%81XML%E5%92%8CJSON%EF%BC%8C%E5%9B%A0%E6%AD%A4%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93SolrJ%E4%BD%BF%E7%94%A8%E5%85%B6%E4%B8%AD%E5%93%AA%E4%B8%80%E7%A7%8D%E6%A0%BC%E5%BC%8F%E4%B8%8ESolr%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A5%E3%80%82%E4%BA%8B%E5%AE%9E%E4%B8%8A%EF%BC%8CSolrJ%E9%BB%98%E8%AE%A4%E4%BD%BF%E7%94%A8javabin%E4%BD%9C%E4%B8%BA%E5%86%85%E9%83%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E5%8D%8F%E8%AE%AE%E3%80%82%E5%BD%93%E8%BF%9B%E8%A1%8CJava-to-Java%E7%9A%84%E9%80%9A%E4%BF%A1%E6%97%B6%EF%BC%8Cjavabin%E5%8D%8F%E8%AE%AE%E6%AF%94%E4%BD%BF%E7%94%A8XML%E6%88%96JSON%E6%95%88%E7%8E%87%E6%9B%B4%E9%AB%98%E3%80%82">http://localhost:8983/solr/colletion1。背后使用的技术是，SolrJ使用Apache的HttpComponents客户端库，通过Http与Solr服务进行通信。在5.5.1节中一直Solr支持XML和JSON，因此需要知道SolrJ使用其中哪一种格式与Solr进行连接。事实上，SolrJ默认使用javabin作为内部二进制协议。当进行Java-to-Java的通信时，javabin协议比使用XML或JSON效率更高。</a><br />处理向单台Solr服务器发送请求之外，SolrJ内置了文档批处理机制，以支持大规模索引、Solr实例间的负载平衡、SolrCloud配置中Solr服务器位置的自动发现，以及将Solr作为非服务器模式内嵌在Java应用中。第12章会详细的介绍这些内容。<br><a name="r8k7B"></a></p>
<h3 id="向Solr导入文档的其他工具"><a href="#向Solr导入文档的其他工具" class="headerlink" title="向Solr导入文档的其他工具"></a>向Solr导入文档的其他工具</h3><p>我们已经学会了向Solr导入文档的两种基本方法：使用Http Post方式的post.jar应用和使用Java编程的SolrJ客户端。但这不是向Solr导入的全部方法。作为成熟的、广泛应用的开源技术，Solr提供了许多功能强大的工具，用于从其他系统中添加文档。本节介绍3种流行的文档导入工具。</p>
<ul>
<li><strong>数据导入处理器(Data Import Hadndler，DIH)</strong></li>
<li><strong>ExtractingRequestHandler，又名Solr Cell</strong></li>
<li><strong>Nutch</strong></li>
</ul>
<p>上述每个工具都很强大，如果展开来介绍都需要一整章的篇幅。此处指简要介绍这些工具，现在只要知道有些文档索引的导入方法即可。<br><a name="tk7Me"></a></p>
<h4 id="数据导入处理器DIH-Solr8-6标记弃用，Solr9-0移除"><a href="#数据导入处理器DIH-Solr8-6标记弃用，Solr9-0移除" class="headerlink" title="数据导入处理器DIH-(Solr8.6标记弃用，Solr9.0移除)"></a>数据导入处理器DIH-(Solr8.6标记弃用，Solr9.0移除)</h4><p><strong>数据导入处理器(DIH)是从一个或多个外部来源(网站或关系型数据库)将数据导入到Solr的一个扩展</strong>。DIH可以与<strong>具备主流JDBC驱动的任何数据库</strong>对话，例如，Oracle、Postgres、MySQL及MS SQL Server。概括而言，<strong>将数据库连接参数和SQL查询语句提供给Solr，DIH组件会对数据库进行查询，将查询结果转换为Solr索引所需的文档</strong>。第12章会更详细的介绍DIH，附录C提供了外部数据导入的映射处理。现在我们来看看另一个处理二进制文件(如PDF与Word文档)的索引工具。<br><a name="3TlF1"></a></p>
<h4 id="ExtractingRequestHandler"><a href="#ExtractingRequestHandler" class="headerlink" title="ExtractingRequestHandler"></a>ExtractingRequestHandler</h4><p>ExctractingRequestHandler，又名Solr Cell，可以<strong>抽取二进制文件中的文本(如PDF、微软Office和OpenOffice等)内容进行索引</strong>。这背后的技术是，<strong>Solr Cell使用Apache的Tika工具进行文本抽取。具体来说，Tika提供组件来检测文档类型，并从二进制文件中抽取文本和元数据</strong>。例如，向ExtractingRequestHandler发送一个PDF文件，它会自动在Solr索引中生成title(标题)、subject(主题)、keywords(关键词)与text(正文文本)这样的索引字段。本书不会涉及很多有关ExtractingRequestHandler的配置说明，第12章会再介绍一些，通过一个完整的教程将二进制文件索引到Solr中。<br><a name="gmdTU"></a></p>
<h4 id="Nutch"><a href="#Nutch" class="headerlink" title="Nutch"></a>Nutch</h4><p><strong>Apache的Nutch是一个基于Java的开源网络爬虫</strong>。<strong>Nutch与Solr无缝集成，开箱即用</strong>。通过Nutch采集网页，然后Solr实现采集到的的网页可被搜索。因此，如果搜索应用需要大规模采集超链接网页，Nutch可能是一个不错的起点。有关Nutch的更多信息，请访问Nutch项目的猪业<a target="_blank" rel="noopener" href="http://nutch.apache.org./">http://nutch.apache.org。</a><br />了解了如何向Solr发送文档进行索引，接下来介绍Solr如何使用更新处理器处理这些请求。<br><a name="93dzy"></a></p>
<h2 id="更新处理器"><a href="#更新处理器" class="headerlink" title="更新处理器"></a>更新处理器</h2><p>上一节中使用Http Post方式向Solr发送了新的文档。添加新文档的请求提交给了Solr的更新处理器。通常情况下，更<strong>新处理器负责索引的所有更新请求，包括提交与优化请求</strong>。表5.7是更新处理器支持的常见请求类型概览。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624795976232-805b1c24-1a45-43a2-983d-24591180ee4f.png#height=1112&id=YPn2x&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1112&originWidth=1974&originalType=binary&ratio=1&size=756046&status=done&style=none&width=1974" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624796007471-794e01d8-b28b-416d-94c1-d3d47d82280a.png#height=1154&id=sNHKH&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1154&originWidth=1982&originalType=binary&ratio=1&size=752135&status=done&style=none&width=1982" alt="image.png"><br />表5.7给出了使用XML的更新请求示例，更新请求处理器还支持其他格式，如JSON、CSV和javabin。其<strong>背后的技术原理是，更新请求处理器根据Http头部的Content-Type来识别请求的格式</strong>，例如，Content-Type:text/xml。代码清单5.16是solrconf.xml中更新处理器的配置信息。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624796122363-e1aaccd4-a8a5-4670-9bb7-188e9055634e.png#height=934&id=MESUs&margin=%5Bobject%20Object%5D&name=image.png&originHeight=934&originWidth=1968&originalType=binary&ratio=1&size=756570&status=done&style=none&width=1968" alt="image.png"><br /><strong>更新处理器最重要的任务是处理文档提交到索引的请求，并让这些文档可以被搜索</strong>。<br><a name="moDTt"></a></p>
<h3 id="将文档提交到索引"><a href="#将文档提交到索引" class="headerlink" title="将文档提交到索引"></a>将文档提交到索引</h3><p>本节<strong>介绍Solr如何通过将文档提交到索引，让这些文档可被搜索</strong>。当一个文档被添加到Solr中，在没有提交给索引之前，这个文档无法被搜索。换句话说，<strong>从查询的角度看</strong>，<strong>文档直到提交之后才是可见的</strong>。Solr4有两种类型的提交：软提交和正常提交(俗称硬提交)。首先介绍正常提交的工作原理，这将有助更好的理解软提交。<br><a name="FzKK8"></a></p>
<h4 id="正常提交"><a href="#正常提交" class="headerlink" title="正常提交"></a>正常提交</h4><p>Solr的<strong>正常提交(硬提交)是将所有未提交的文档写入磁盘</strong>，<strong>并刷新一个内部搜索器组件</strong>，<strong>让新提交的文档能够被搜索</strong>。<strong>搜索器实际上可以看作索引中所有已提交文档的只读视图</strong>。参见4.3节有关搜索器工作原理的详细讨论。可以这样说，硬提交是花销较大的操作，由于硬提交需要开启一个新的搜索器，所以会影响到查询性能。<br />当<strong>正常提交成功后</strong>，<strong>新提交的文档被安全保存在持久存储器上</strong>，<strong>不会因为正常的维护操作或服务器崩溃后重启而丢失</strong>。处于高可用性考虑，如果磁盘发生故障，就需要一套故障转移方案。第13章将讨论高可用性功能。<br><a name="mSPZs"></a></p>
<h4 id="软提交"><a href="#软提交" class="headerlink" title="软提交"></a>软提交</h4><p><strong>软提交是Solr4的一项新功能，支持近实时搜索(Near Real-Time ,NRT)<strong>。第13章会详细讨论近实时搜索。这里将</strong>软提交作为文档近乎实时可被搜索到的一种机制，跳过了硬提交的高消耗</strong>，例如，刷新到持久存储器就是花销较大的操作。软提交相对而言花销较低，我们可以每一秒都执行一次软提交，使得新进被索引的文档在添加到Solr之后很快能被搜索到。但要记住，在某一时刻仍然需要执行硬提交操作，以确保文档最终写入到持久存储器上。<br />综上所述：</p>
<ul>
<li><strong>硬提交让文档可被搜索，由于需要将其写入到持久存储器上，所以花销较大。</strong></li>
<li><strong>软提交也可以让文档被搜索，不需要将其写入到持久存储上。</strong></li>
</ul>
<p>第13章将继续讨论这个话题，到时会在SolrCloud中讨论近实时搜索。<br><a name="lXmMb"></a></p>
<h4 id="自动提交"><a href="#自动提交" class="headerlink" title="自动提交"></a>自动提交</h4><p>不管是正常提交还是软提交，都可以采用以下三种策略中的任意一种来自动提交文档：</p>
<ul>
<li><strong>在指定时间内提交文档。</strong></li>
<li><strong>一旦达到用户指定的未提交文档阈值，就提交那些未提交的文档。</strong></li>
<li><strong>每隔特定时间间隔提交所有文档</strong>，例如，每隔10分钟。</li>
</ul>
<p><strong>Solr硬提交与软提交的自动提交行为需要在solrconfig.xml中进行配置</strong>。以下XML片段是配置距离，Solr每隔10分钟或最大文档数达到5000个时自动进行提交。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624797056193-6afdb26a-b726-4e4c-8a4d-d8627b07b768.png#height=300&id=JlQHD&margin=%5Bobject%20Object%5D&name=image.png&originHeight=300&originWidth=1876&originalType=binary&ratio=1&size=250436&status=done&style=none&width=1876" alt="image.png"><br /><strong>执行自动提交时通常会打开一个新搜索器</strong>。<strong>Solr通过指定<openSearcher>false</openSearcher>可以禁用这一行为</strong>。在这种情况下，该文件将被写入到磁盘，但在搜索结果中不可见。Solr之所以提供这个选项，是为了减少未提交更新到事务日志大小(参见下一节)，并避免在大规模索引过程中打开太多搜索器。<br />假设有500万个文档需要索引，Solr的自动提交条件设置为文档阈值达到50000。这意味着，Solr在索引500万个文档的过程中会执行100次自动提交。如此一来，索引完所有文档后打开一个新搜索器，要比打开100个新搜索器要更现实些。当然，客户端应用也可以每100万个文档发送一次硬提交请求，这样做的话，有一些文档很快就可以被搜索了。考虑的重点在于，是否每次自动提交后都需要打开一个新搜索器。如果索引的文档数量大于自动提交的阈值，那么可能需要考虑设置成<openSearcher>false</openSearcher>。索引完所有文档后，最后执行一次硬提交。<br />另外，不要把表5.7中的<Commit>元素的waitSearcher属性与<autoCommit>元素openSearcher属性搞混淆了。当发送一个<commit>请求时，通常会打开一个新搜索器并进行预热。waitSearcher属性决定新搜索器完全启动后，客户端代码是否应该被阻止。正如第4章介绍的，新搜索器的启动需要很长时间，所以要谨慎使用waitSearcher=”true”。<br />在solrconfi.xml中使用<autoSoftCommit>元素也可以自动配置软提交。如果想要设置更小的软提交间隔值，例如，每秒(1000毫秒)，如下XML片段所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624797580359-6303d3eb-a319-4794-a694-eff60f58c2b8.png#height=172&id=oxxXN&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=1406&originalType=binary&ratio=1&size=101262&status=done&style=none&width=1406" alt="image.png"><br />接下来介绍更新处理器的另一个强大功能，确保不会丢失未提交的更新。<br><a name="fhxLj"></a></p>
<h3 id="事务日志"><a href="#事务日志" class="headerlink" title="事务日志"></a>事务日志</h3><p><strong>Solr使用事务日志来确保提交到索引并已接受的更新保存在持久存储器</strong>。假设这样的常见，客户端应用每10000个文档发送一次提交。如果在客户端发送的文档已被索引，但还没来得及执行提交操作的情况下Solr崩溃了。那么，没有事务日志的话，这些未被提交的文档将会丢失。具体来说，事务日志主要有三个作用：</p>
<ul>
<li><strong>支持近实时获取和原子更新</strong></li>
<li><strong>解除提交过程中写入的持久性</strong></li>
<li><strong>通过SolrCloud的分片代表支持副本的同步</strong>(参见第13章)</li>
</ul>
<p>在solrconfig.xml中一个Solr内核的事物日志配置如下：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624801134718-0687465c-4549-44bc-a5f7-d543ae1aecb0.png#height=76&id=kuMay&margin=%5Bobject%20Object%5D&name=image.png&originHeight=152&originWidth=1608&originalType=binary&ratio=1&size=105833&status=done&style=none&width=804" alt="image.png"><br /><strong>每次更新请求都会被记录到事务日志</strong>。直到发起提交，事物日志会持续增长。在提交期间会处理活动事务日志，之后将打开一个新的事物日志。图5.7展示了更新请求处理的步骤。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1624801230032-59bbd3a0-41c9-4f13-8fc3-d08f14c2c08e.png#height=702&id=zXbld&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1404&originWidth=1844&originalType=binary&ratio=1&size=1314371&status=done&style=none&width=922" alt="image.png"><br />图5.7的一些组件，如请求调度器和回复写入器，应该是你熟悉的。这些与第4章介绍的查询请求处理组件相同。接下来，通过图5.5的时间处理顺序来了解一下重要概念：</p>
<ol>
<li><strong>客户端应用程序使用Http Post方式发送一个更新请求，可以使JSON、XML或Solr内部二进制javabin格式。</strong>代码清单5.15使用SolrJ编写了一个示例客户端</li>
<li><strong>Jetty将此请求发送给Solr的Web应用程序</strong></li>
<li><strong>Solr的请求调度器通过请求路径中的”collection1”这一部分来确定Solr的内核名称。接下来，调度器定位到/update请求处理器，它在solrconfig.xml的collection1内核上注册过</strong></li>
<li><strong>更新请求处理器对该请求进行处理。当添加或更新文档时，更新处理器依据schema.xml依次处理请求中的每个文档的每个字段。以外，该请求处理器将调用一个可配置的更新处理器链，在索引时为每个字段进行额外的处理。第6章将举例说明如何在索引期间使用更新请求处理器来检测语种</strong></li>
<li><strong>Add请求写入到事务日志中</strong></li>
<li><strong>一旦更新请求被安全的保存到持久存储器，就会通过响应读写器回应客户端应用。这时，客户端应用得知更新请求成功执行，就可以继续接下来的处理了。</strong></li>
</ol>
<p><strong>事务日志的关键在于权衡事务日志的长度(多少个未提交的更新)与硬提交的执行频率</strong>。如果<strong>事务日志变得很庞大，重启就需要更长时间来处理更新，也会造成恢复过程延缓</strong>。<br />举例来说，如果文档的平均大小为5KB，达到100000个文档时进行提交，那么事务日志的大小会超过3.7GB。当然，5KB大小的文档也不是小文档。与此相对，本章的微博示例文档每当达到100000个文档进行提交就不存在什么问题。关键点在于，当配置自动提交设置时需要考虑的事务日志大小。在上一节已经知道，通过设置<openSearcher>false</openSearcher>执行硬提交，这样不会影响查询性能。但是，这意味着在某些时候，客户端应用必须执行一个完整的硬提交，才能让搜索结果中的所有更新可见。<br><a name="PiByq"></a></p>
<h3 id="原子更新"><a href="#原子更新" class="headerlink" title="原子更新"></a>原子更新</h3><p>在Solr中，通过<strong>发送文档的新版本可以实现对已有文档的更新</strong>。数据库可以在一行中更新特定的列，与此不同的是，使用Solr必须更新整个文档。<strong>Solr实际执行的操作是，删除现有的文件并创建一个新的文档。不管是更改一个字段还是全部字段</strong>，都会这样执行。<br />从客户端的角度看，应用程序必须发送整个文档的新版本。对于文档来自于其他来源的应用程序，这不是什么大问题。但是，对于那些将Solr作为主要数据存储的应用程序来说，为了更新单个字段而要重新创建全部文档，这可能会产生问题。在实践中，这需要用户查询整个文档，进行更新，并将指定的文档整体发回给Solr。<br />对已存在的文档请求所有字段，更新字段的子集，并发送新版本给Solr。这样的做法在实践中很常见。因此，原子更新是Solr的一项功能，通过它可以实现仅对需要修改的字段进行更新。这让Solr更符合数据库的更新操作。Solr仍可以删除与新建文档，但这些对客户端应用程序代码来说是透明的。<br><a name="Rn5XK"></a></p>
<h4 id="字段级别的更新"><a href="#字段级别的更新" class="headerlink" title="字段级别的更新"></a>字段级别的更新</h4><p>回到之前的微博搜索示例，假设我们要在已有文档上索引一个新字段，用来保存微博的转发次数。我们把这个新字段作为微博热门程度的一个指标。为了简单起见，此字段每天更新一次。当然，我们都知道日统计量是有用的，但为了简单起见，我们把它处理成累计值。此处的重点是掌握原子更新。<br />将新字段命名为retweet_count_ti，表示这是个动态字段。因此，添加新字段不需要更新schema.xml。_ti后缀来源于以下schema.xml中的动态字段定义：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625037419541-87f60bd4-2ec0-47f4-a7da-213635625593.png#height=350&id=RZF7h&margin=%5Bobject%20Object%5D&name=image.png&originHeight=350&originWidth=1230&originalType=binary&ratio=1&size=437178&status=done&style=none&width=1230" alt="image.png"><br />实际执行的操作是，<strong>Solr定位到已存在的id为1文档，从索引中检索所有的存储字段，删除已有文档，创建了一个新文档，包含所有已有字段和retweet_count_ti这个新字段</strong>。虽然客户端应用仅发送了id字段和新字段，但需要对所有字段重新存储。其他所有字段必须从已有文档中取出来。<br /><strong>通过update=”set”来设置retweet_count_ti字段</strong>。或者，由于更新进程每日运行一次，因此可以从前一天开始计算，<strong>通过update=”inc”增加已有字段值</strong>。除了set和inc之外，还可以将新值附加到多值字段上。<br><a name="B466n"></a></p>
<h4 id="积极地并发控制"><a href="#积极地并发控制" class="headerlink" title="积极地并发控制"></a>积极地并发控制</h4><p>现在考虑稍微复杂一些的例子，我们希望使用众包的方法对微博进行情感分类。简单的说，我们支付给用户一定费用，让他们对每个文档做出正面、中性或负面的分类。情感字段对于找出产品或餐厅的负面信息来说是有用的。<br />完成分类后，每个带着情感标签的微博文档都需要在Solr中进行更新。在微博转发示例中，通过自动化处理方式每天更新一次retweet_count_ti字段。但对于情感分类，sentiment_s字段的更新可以在任何时间进行。因此，两个用户在相同时间对同一个文档进行情感标签的更新，这种情况是可能出现的。当然，我们也可以通过一些烦琐的过程，在用户打情感标签之前，显式锁定文档，但这会降低处理效率，完全没有必要。此外，我们也不希望为一个文档多支付一次分类费用。因此，需要一些方法来防止同一文档上的并发更新，也就是积极的并发控制。<br /><strong>为避免冲突，Solr通过版本跟踪字段_version_来支持积极的并发控制</strong>。在schema.xml中定义版本字段，如下所示：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625058186599-79a8ac77-0abe-46c0-bd81-5f43f355c820.png#height=240&id=opirt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=240&originWidth=2162&originalType=binary&ratio=1&size=153492&status=done&style=none&width=2162" alt="image.png"><br />当添加一个新文档时，Solr会自动分配一个唯一版本号。当需要进行并发更新时，则在更新请求中包含精确的更新版本。以下是包含具体_version_的更新请求：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625058301214-0e84b7a4-87c5-46f7-a47d-9ed7c7050b0f.png#height=468&id=YaqMc&margin=%5Bobject%20Object%5D&name=image.png&originHeight=468&originWidth=2232&originalType=binary&ratio=1&size=472377&status=done&style=none&width=2232" alt="image.png"><br />当Solr处理此更新时，它会比较更新请求的_version_值与此文档最新版本。<strong>文档的最新版本从索引或事务日志中获得。如果版本匹配，则Solr执行此更新请求；如果不匹配，则更新请求失败，将错误信息返回给用户</strong>。客户端应用可以处理错误响应，让用户知道该文档已被其他用户标注过了。由于假定大多数更新在初次尝试会正常更新，冲突比较少见，所以我们称这种方式为”积极的”。<br />使用_version_字段执行并发控制会产生一个问题：客户端应用该如何从Solr获得当前_version_值？最好的方法是使用近实时的get请求。例如，在微博搜索示例中，为了获得id为1的文档的_version_字段值，需要发送以下Http Get请求：<a target="_blank" rel="noopener" href="http://localhost:8983/solr/collection1/get?id=1&amp;fl=id,_version_%E3%80%82">http://localhost:8983/solr/collection1/get?id=1&amp;fl=id,_version_。</a><br />不论该文档是否提交到索引，近实时get会返回该文档的最新版本，因此，<strong>近实时get请求和原子更新依赖于索引开启事务日志</strong>。<br />Solr还提供_version_字段的其他并发更新方法。表5.8给出了Solr根据更新请求的_version_值采取的更新策略。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625059222866-ca03660f-94ee-4f71-a46d-74732b835204.png#height=528&id=SXVi8&margin=%5Bobject%20Object%5D&name=image.png&originHeight=528&originWidth=1972&originalType=binary&ratio=1&size=417478&status=done&style=none&width=1972" alt="image.png"><br /> 通过这个简单的示例，我们已经看到了原子更新的强大作用。原子更新是Solr数据管理方面的一个新武器。在Solr4中，你可以通过发送需要更新的字段和待更新文档的唯一标识符，对已有文档进行更新。<br><a name="RXTMX"></a></p>
<h2 id="索引管理"><a href="#索引管理" class="headerlink" title="索引管理"></a>索引管理</h2><p>由于需要先掌握Solr索引创建的知识，所以第4章推迟了有关solrconfig.xml中索引管理设置的讨论。现在可以介绍Solr的索引管理设置了。本节重点介绍最有可能需要调整的索引设置，首先从索引文档的存储设置谈起。应该说，大部分Solr索引相关的设置仅面向技术专家。这就意味着，应该谨慎做出修改。默认设置适用于大多数Solr的装机情况。<br><a name="ykfza"></a></p>
<h3 id="索引存储"><a href="#索引存储" class="headerlink" title="索引存储"></a>索引存储</h3><p>当文档提交到索引之后，directory目录组件将他们写入到持久存储器。Solr的目录组件具有以下重要特点：</p>
<ul>
<li><strong>隐藏持久存储的读写细节，例如，将文档写入到磁盘或通过JDBC在数据库中存储文档</strong></li>
<li><strong>实现特定的存储锁定机制，防止索引出错。例如，在操作系统级别上基于文件系统的存储锁定</strong></li>
<li><strong>将Solr从JVM和操作系统的专有制中解脱出来</strong></li>
<li><strong>启用基础目录方案的拓展机制，以支持特定应用，如近实时搜索</strong></li>
</ul>
<p>Solr提供不同的目录方案，但没有所谓的适用于所有Solr装机情况的最佳目录方案。根据Solr应用的具体情况，思考如何确定最佳方案。实践中取决于操作系统本身、JVM类型及应用场景。第4章层提到，Solr在启用时就尝试做好开箱即用的配置。首先来看Solr索引存储的默认配置，为进一步修改打下基础。<br><a name="UQVYf"></a></p>
<h4 id="默认存储配置"><a href="#默认存储配置" class="headerlink" title="默认存储配置"></a>默认存储配置</h4><p><strong>默认情况下，Solr为一个内核设置一个数据目录，将数据存储在本地文件系统中</strong>。举例来说，示例服务器将索引存储在**$SOLR_INSTALL/example/solr/colletion1/data/<strong>目录。</strong>在solrconfig.xml中使用<dataDir>元素定位data目录**。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625382875809-c6bf3d1f-134f-4318-858f-2e6d51c20544.png#height=138&id=Yv19U&margin=%5Bobject%20Object%5D&name=image.png&originHeight=138&originWidth=1890&originalType=binary&ratio=1&size=130266&status=done&style=none&width=1890" alt="image.png"><br /><strong>solr.data.dir属性是内核的默认数据目录，但可以在solr.xml中修改</strong>，例如：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625383929589-540a99f2-e35e-4ea4-b061-de4c91323a14.png#height=172&id=mukvq&margin=%5Bobject%20Object%5D&name=image.png&originHeight=172&originWidth=1890&originalType=binary&ratio=1&size=179375&status=done&style=none&width=1890" alt="image.png"><br />首先要考虑，索引的数据目录是否有足够的存储容量。此外，数据目录支持快速读写也很重要。其中对读性能要多做一些考虑。虽然磁盘I/O优化策略超出了本书讲解的范畴，但有一些基础的知识点需要了解：</p>
<ul>
<li><strong>每个内核不应与其他进程争夺磁盘空间</strong></li>
<li><strong>如果同一台服务器上有多个内核，建议的做法是每个索引使用独立的物理磁盘进行存储</strong></li>
<li><strong>如果预算允许，考虑使用高质量、高速磁盘，如固态硬盘SSD</strong></li>
<li><strong>花一些时间于系统管理员讨论服务器RAID策略</strong></li>
<li><strong>操作系统中文件系统用于缓存的内存容量也会对磁盘I/O需求产生不可小觑的影响</strong></li>
</ul>
<p>以上考虑及其对Solr性能的影响将在第12章中详细讨论。<br><a name="WEHGX"></a></p>
<h4 id="选择一个目录方案"><a href="#选择一个目录方案" class="headerlink" title="选择一个目录方案"></a>选择一个目录方案</h4><p>一旦解决了存储方面的顾虑，还需考虑存储方案的最佳目录方案。<strong>Solr使用solr.NRTCachingDirectoryFactory启用默认目录</strong>，<strong>在solrconfig.xml中配置<directoryFactory>元素来指定此目录</strong>。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">direcoryFactory</span> <span class="attr">name</span>=<span class="string">&quot;DirectoryFactory&quot;</span></span></span><br><span class="line"><span class="tag">                 <span class="attr">class</span>=<span class="string">&quot;$&#123;solr.directoryFactory:solr.NRTCachingDirectoryFactory&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>NRTCachingDirectoryFactory是solr.StandardDirectoryFactory的一个封装类，用来添加对近实时搜索的支持。在运行时，StandardDirectory-Factory根据操作系统与JVM类型来选择一个具体的陆慕方案，如图5.8所示。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625385817490-be9a5cf7-5452-4b1d-bab2-cc194eabf7f5.png#height=1382&id=xBsCG&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1382&originWidth=1936&originalType=binary&ratio=1&size=1255296&status=done&style=none&width=1936" alt="image.png"><br />根据图5.8，Solr包含三个基于文件系统的目录备选项。</p>
<ul>
<li><strong>MMapDirectory：读取索引时使用内存映射I/O。这是安装了Oracle JVM的64位Windows、Solritas或Linux类操作系统的最佳选择</strong></li>
<li><strong>SimpleFSDirectory：使用Java的RandomAccessFile方法。除非是32位Windows操作系统，否则应避免使用此方法</strong></li>
<li><strong>NIOFSDirectory：通过java.nio进行优化，以避免同一个文件的同步读操作。这是JVM长期存在的一个问题，应避免在Windows上使用此方法。</strong></li>
</ul>
<p>通过Solr控制台的内核管理页，为Solr服务器指定数据目录。图5.9说明了如何寻找示例collection1内核的目录信息。<br /><strong>通过在solrconfig.xml指定目录来修改默认目录</strong>。例如，图5.9中Solr使用了NRTCachingDirectory。<strong>如果想要修改为MMapDirectory，则需要对solrconfig.xml作以下修改</strong>：<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625386099659-977f7c53-843b-4831-aad6-53fd31a0b107.png#height=160&id=cwWBR&margin=%5Bobject%20Object%5D&name=image.png&originHeight=160&originWidth=2104&originalType=binary&ratio=1&size=152019&status=done&style=none&width=2104" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625386122417-c00dcbcc-33c7-476d-a89b-6d36ebe21657.png#height=1350&id=Z5GIt&margin=%5Bobject%20Object%5D&name=image.png&originHeight=1350&originWidth=1916&originalType=binary&ratio=1&size=1153224&status=done&style=none&width=1916" alt="image.png"><br /><strong>如果运行在64位Windows、Solritas和Linux操作系统上，MMapDirectory是最佳选择</strong>。因为MMapDirectory使用了现代操作系统的虚拟内存管理功能，对读性能进行了优化，使其更加智能化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Tips：如果想要深入了解MMApDirectory，推荐查看Uwe Schindler的博客文章Use Lucene&#x27;s MMapDirectory on 64bit plateforms，please!</span><br><span class="line">http://blog.thetaphi.de/2012/07/use-lucenes-mmapdirectory-on-64bit.html</span><br></pre></td></tr></table></figure>
<p><a name="G9tft"></a></p>
<h3 id="索引片段合并"><a href="#索引片段合并" class="headerlink" title="索引片段合并"></a>索引片段合并</h3><p><strong>索引片段是Lucene完整索引的子集，具有自包含和只读特点</strong>。<strong>索引片段写入持久存储器之后，它就无法再更改</strong>。<strong>向索引添加新文档时，它们被写入一个索引片段中</strong>。因此，索引里可能存在许多活动的索引片段。每个查询必须读取了全部索引片段的数据，才能得到完整的搜索结果集。基于这一点考虑，过多的小片段对查询性能造成负面影响。将多个小索引片段组合成大索引片段的做法成为索引片段合并。<br><a name="1IMja"></a></p>
<h4 id="索引是否需要优化"><a href="#索引是否需要优化" class="headerlink" title="索引是否需要优化"></a>索引是否需要优化</h4><p>优化要求Lucene将已有的索引片段合并成一定数量(默认值为1)的大索引片段。举例来说，将32个片段组成索引在优化之后会变成一个大索引片段。在Solr中，优化会对内存、CPU与磁盘I/O的花销较大，特别是对大索引而言。花费数小时对一个大索引进行全面优化，这很常见。<br />是否需要优化索引是Solr用户邮件列表中最常见的问题。这可以理解，谁不想要一个优化好的索引？但是，Solr技术社区对此的建议和当前看法是，与其对索引进行优化，不如微调Solr的索引合并策略。对此，优化过的索引并不能迅速提高查询速度。相反，未优化索引的查询性能也不是那么糟糕。索引优化的一些有效案例会在第12章介绍。<br><a name="sp5CP"></a></p>
<h4 id="专家级索引片段合并设置"><a href="#专家级索引片段合并设置" class="headerlink" title="专家级索引片段合并设置"></a>专家级索引片段合并设置</h4><p>默认情况下，有关索引片段合并的设置在solrconfig.xml中被注释掉了。这样做的原因是，默认设置适用于大多数情况，特别是学习Solr的入门阶段。你应该注意到了，每个元素都被标记为专家级别的设置。图5.9列举了solrconfig.xml中索引片段合并的相关元素。<br /><img src="https://cdn.nlark.com/yuque/0/2021/png/2668706/1625392722242-c5140e82-2db2-4a72-8c13-01c42724cb63.png#height=904&id=HpXIO&margin=%5Bobject%20Object%5D&name=image.png&originHeight=904&originWidth=1982&originalType=binary&ratio=1&size=1066183&status=done&style=none&width=1982" alt="image.png"><br />这里需要明确，尽管这些专家级设置被注释掉了，但仍然能在后台进行索引片段合并操作④。当前的建议是，<strong>除非有充分理由修改这些设置，否者跳过优化，直接使用索引片段合并的默认配置即可</strong>。当服务器做该索引片段合并时，很可能不作为就是正确的选择⑤。如果搜索应用的索引吞吐量出问题了，请参照第12章修改这些配置。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">④：参考Mike McCandless的博客文章 Visualizing Lucene&#x27;s segment merges，了解索引片段合并的可视化(http://blog.mikemccandless.com/2011/02/visualizing-lucenes-segment-merges.html)。</span><br><span class="line">⑤：更多合并的知识，请参考Lucene in actio(2e)的2.13.6节。</span><br></pre></td></tr></table></figure>
<p><a name="ZkfQN"></a></p>
<h4 id="删除处理"><a href="#删除处理" class="headerlink" title="删除处理"></a>删除处理</h4><p><strong>当索引片段写入持久存储器之后就不能更改了</strong>。那么，此处的删除并不是从已有的索引片段中删除文档。删除的文档不会从索引中消失，除非包含删除的索引片段被合并。简言之，<strong>Lucene将删除操作记录在一个单独的数据结构中，合并时执行这些删除操作</strong>。大多数情况下无须担心合并过程，第12章会深入介绍索引片段合并原理及带来的性能影响。<br><a name="dvmbA"></a></p>
<h2 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a>本章小结</h2><p>读到这里，你应该对Solr的创建索引过程有了很好的理解。回顾一下，首先我们学习了schema的设计过程。具体来讲，讨论了文档粒度、文档唯一性，以及字段是否应该被索引、存储或两者兼具的考虑因素。<br />接下来学习了再schema.xml中如何定义字段，包括多值字段与动态资源。多值字段对多字段的文档和多来源的文档非常有用。另外，为了实现全字段文本搜索，或在创建索引时对同一文本使用不同文本分析器，我们还学习了Solr的<copyField>用法。<br />接下来，了解了结构化数据的使用方法。Solr支持字符串、日期与数值等字段类型。Solr使用/操作符来设置日期值的精确度，例如，小时级别的精度使用/HOUR。另外，我们还学习了Solr基于字典树的字段，用来支持有效的区间查询，以及对数值和日期字段进行排序。通过调整数值字段和日期字段的precisionStep属性，在较大索引与较慢的区间查询性能之间做出权衡。<br />在充满熟悉schema.xml的基础上，我们学习了如何通过Http和SolrJ向Solr发送XML和JSON文档。除了这两种文档提交方法之外，还介绍了从关系型数据库(DIH)导入文档，使用抽取请求处理器(Solr Cell)对PDF、微软的Word文档等二进制文档进行索引。<br />当文档处理好之后，需要执行正常提交或近实时搜索的软提交。本章展示了Solr如何使用事务日志来避免未提交更新的丢失。除了介绍如何添加新文档，还介绍了如何使用Solr的原子更新功能对已有文档进行更新。根据特定的_version_字段实现乐观的并发控制，以确保正常有序的并发更新。<br />本章结尾处讨论了solrconfig.xml中索引相关的设置。具体来说，介绍了如何使用目录组件对索引进行存储。索引片段合并是避免索引优化的好方法。在没有对索引吞吐量需求有更透彻的理解之前，不要修改索引片段合并的设置。第12张会深入讨论专家级的索引性能的影响因素。<br />下一章将深入介绍索引郭晨给的文本分析。读完第6章，你就有能力为搜索应用设计与实现一个强大的索引解决方案了。<br /></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <div class="declare">
      <ul class="post-copyright">
        <li>
          <i class="ri-copyright-line"></i>
          <strong>Copyright： </strong>
          
          Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source.
          
        </li>
      </ul>
    </div>
    
    <footer class="article-footer">
       
<div class="share-btn">
      <span class="share-sns share-outer">
        <i class="ri-share-forward-line"></i>
        分享
      </span>
      <div class="share-wrap">
        <i class="arrow"></i>
        <div class="share-icons">
          
          <a class="facebook share-sns" href="javascript:;" data-type="facebook">
            <i class="ri-facebook-circle-fill"></i>
          </a>
          <a class="twitter share-sns" href="javascript:;" data-type="twitter">
            <i class="ri-twitter-fill"></i>
          </a>
          <a class="google share-sns" href="javascript:;" data-type="google">
            <i class="ri-google-fill"></i>
          </a>
        </div>
      </div>
</div>

<div class="wx-share-modal">
    <a class="modal-close" href="javascript:;"><i class="ri-close-circle-line"></i></a>
    <p>扫一扫，分享到微信</p>
    <div class="wx-qrcode">
      <img src="//api.qrserver.com/v1/create-qr-code/?size=150x150&data=http://example.com/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E4%BA%94%E7%AB%A0-Solr%E7%B4%A2%E5%BC%95/" alt="微信分享二维码">
    </div>
</div>

<div id="share-mask"></div>  
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr/" rel="tag">Solr</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Solr%E5%9F%BA%E7%A1%80/" rel="tag">Solr基础</a></li></ul>

    </footer>
  </div>

   
  <nav class="article-nav">
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%85%AD%E7%AB%A0-Solr%E6%96%87%E6%9C%AC%E5%88%86%E6%9E%90/" class="article-nav-link">
        <strong class="article-nav-caption">上一篇</strong>
        <div class="article-nav-title">
          
            Solr手册-第六章 Solr文本分析
          
        </div>
      </a>
    
    
      <a href="/2021/10/31/Solr%E6%89%8B%E5%86%8C-%E7%AC%AC%E5%9B%9B%E7%AB%A0-Solr%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/" class="article-nav-link">
        <strong class="article-nav-caption">下一篇</strong>
        <div class="article-nav-title">Solr手册-第四章 Solr简单配置</div>
      </a>
    
  </nav>

  
   
     
</article>

</section>
      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2021
        <i class="ri-heart-fill heart_icon"></i> John Doe
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer-side.svg" alt="J`Han&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">HomePage</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Document</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/Solr/">Solr</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/">Tags</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>如果觉得对您有帮助，来个打赏吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/img/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->
 
<script src="/js/tocbot.min.js"></script>

<script>
  tocbot.init({
    tocSelector: ".tocbot",
    contentSelector: ".article-entry",
    headingSelector: "h1, h2, h3, h4, h5, h6",
    hasInnerContainers: true,
    scrollSmooth: true,
    scrollContainer: "main",
    positionFixedSelector: ".tocbot",
    positionFixedClass: "is-position-fixed",
    fixedSidebarOffset: "auto",
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->

<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    

  </div>
</body>

</html>